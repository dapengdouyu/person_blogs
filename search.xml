<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[loader]]></title>
    <url>%2F2019%2F01%2F15%2Floader%2F</url>
    <content type="text"><![CDATA[loader运行的总体流程(一个函数) loader配置loader是导出为一个函数的node模块。该函数在loader转换资源的时候调用。给定的函数将调用loader API(loaderContext)，并通过this上下文访问。 匹配(test)单个 loader匹配(test)单个 loader，你可以简单通过在 rule 对象设置 path.resolve 指向这个本地文件123456789&#123; test: /\.js$/ use: [ &#123; loader: path.resolve('path/to/loader.js'), options: &#123;/* ... */&#125; &#125; ]&#125; 匹配(test)多个 loaders你可以使用 resolveLoader.modules 配置，webpack 将会从这些目录中搜索这些 loaders123resolveLoader: &#123; modules: [path.resolve('node_modules'), path.resolve(__dirname, 'src', 'loaders')]&#125;, npm link 确保正在开发的本地Npm 模块（也就是正在开发的 Loader）的 package.json 已经正确配置好； 在本地 Npm 模块根目录下执行 npm link，把本地模块注册到全局； 在项目根目录下执行npm link loader-name，把第2步注册到全局的本地 Npm 模块链接到项目的 node_moduels 下，其中的 - loader-name 是指在第1步中的 package.json 文件中配置的模块名称。 1npm link alias123456789resolveLoader: &#123; alias: &#123; "babel-loader": resolve('./loaders/babel-loader.js'), "css-loader": resolve('./loaders/css-loader.js'), "style-loader": resolve('./loaders/style-loader.js'), "file-loader": resolve('./loaders/file-loader.js'), "url-loader": resolve('./loaders/url-loader.js') &#125; &#125;, loader用法单个loader用法 当一个 loader 在资源中使用，这个 loader 只能传入一个参数 - 这个参数是一个包含资源文件内容的字符串 同步 loader 可以简单的返回一个代表模块转化后的值。 在更复杂的情况下，loader 也可以通过使用 this.callback(err, values...)函数，返回任意数量的值。错误要么传递给这个this.callback 函数，要么扔进同步 loader 中。 loader只能传入一个包含包含资源文件内容的字符串 同步 loader可以简单的返回一个代表模块转化后的值 loader 也可以通过使用 this.callback(err, values...) 函数，返回任意数量的值 loader 会返回一个或者两个值。第一个值的类型是 JavaScript 代码的字符串或者 buffer。第二个参数值是SourceMap，它是个 JavaScript 对象 多个loader当链式调用多个 loader的时候，请记住它们会以相反的顺序执行。取决于数组写法格式，从右向左或者从下向上执行。 最后的 loader 最早调用，将会传入原始资源内容。 第一个 loader 最后调用，期望值是传出 JavaScript 和 source map（可选）。 中间的 loader 执行时，会传入前一个 loader 传出的结果。 单个loader用法 最后的 loader 最早调用，将会传入原始资源内容。 第一个 loader 最后调用，期望值是传出 JavaScript 和 source map（可选）。 中间的loader 执行时，会传入前一个 loader 传出的结果。 用法准则简单loaders 应该只做单一任务。这不仅使每个 loader 易维护，也可以在更多场景链式调用。 链式(Chaining)利用 loader 可以链式调用的优势。写五个简单的 loader 实现五项任务，而不是一个 loader 实现五项任务 模块化(Modular)保证输出模块化。loader 生成的模块与普通模块遵循相同的设计原则。 无状态(Stateless)确保 loader 在不同模块转换之间不保存状态。每次运行都应该独立于其他编译模块以及相同模块之前的编译结果。 loader 工具库(Loader Utilities)loader-utils 包。它提供了许多有用的工具，但最常用的一种工具是获取传递给 loader 的选项 schema-utils 包配合 loader-utils，用于保证 loader 选项，进行与 JSON Schema 结构一致的校验 loader 依赖(Loader Dependencies)如果一个 loader 使用外部资源（例如，从文件系统读取），必须声明它。这些信息用于使缓存 loaders 无效，以及在观察模式(watch mode)下重编译。 模块依赖(Module Dependencies)根据模块类型，可能会有不同的模式指定依赖关系。例如在 CSS 中，使用 @import 和 url(...) 语句来声明依赖。这些依赖关系应该由模块系统解析。 绝对路径(Absolute Paths)不要在模块代码中插入绝对路径，因为当项目根路径变化时，文件绝对路径也会变化。loader-utils 中的 stringifyRequest 方法，可以将绝对路径转化为相对路径。 同等依赖(Peer Dependencies)如果你的 loader 简单包裹另外一个包，你应该把这个包作为一个 peerDependency 引入。这种方式允许应用程序开发者在必要情况下，在 package.json 中指定所需的确定版本。 API缓存结果webpack充分地利用缓存来提高编译效率1this.cacheable(); 异步当一个 Loader 无依赖，可异步的时候我想都应该让它不再阻塞地去异步123456789// 让 Loader 缓存module.exports = function(source) &#123; var callback = this.async(); // 做异步的事 doSomeAsyncOperation(content, function(err, result) &#123; if(err) return callback(err); callback(null, result); &#125;);&#125;; raw loader默认的情况源文件是以 UTF-8字符串的形式传入给 Loader,设置module.exports.raw = true可使用 buffer 的形式进行处理1module.exports.raw = true; 获得 Loader 的 options123456const loaderUtils = require('loader-utils');module.exports = function(source) &#123; // 获取到用户给当前 Loader 传入的 options const options = loaderUtils.getOptions(this); return source;&#125;; 返回其它结果Loader有些场景下还需要返回除了内容之外的东西1234567module.exports = function(source) &#123; // 通过 this.callback 告诉 Webpack 返回的结果 this.callback(null, source, sourceMaps); // 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined， // 以让 Webpack 知道该 Loader 返回的结果在 this.callback 中，而不是 return 中 return;&#125;; 完整格式(见NormalModule.js----&gt;runLoaders)1234567891011this.callback( // 当无法转换原内容时，给 Webpack 返回一个 Error err: Error | null, // 原内容转换后的内容 content: string | Buffer, // 用于把转换后的内容得出原内容的 Source Map，方便调试 sourceMap?: SourceMap, // 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回， // 以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能 abstractSyntaxTree?: AST); 同步与异步Loader 有同步和异步之分，上面介绍的Loader 都是同步的 Loader，因为它们的转换流程都是同步的，转换完成后再返回结果。 但在有些场景下转换的步骤只能是异步完成的，例如你需要通过网络请求才能得出结果，如果采用同步的方式网络请求就会阻塞整个构建，导致构建非常缓慢。12345678module.exports = function(source) &#123; // 告诉 Webpack 本次转换是异步的，Loader 会在 callback 中回调结果 var callback = this.async(); someAsyncOperation(source, function(err, result, sourceMaps, ast) &#123; // 通过 callback 返回异步执行后的结果 callback(err, result, sourceMaps, ast); &#125;);&#125;; 处理二进制数据在默认的情况下，Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串。 但有些场景下 Loader 不是处理文本文件，而是处理二进制文件，例如 file-loader，就需要 Webpack 给 Loader 传入二进制格式的数据。 为此，你需要这样编写 Loader：123456789module.exports = function(source) &#123; // 在 exports.raw === true 时，Webpack 传给 Loader 的 source 是 Buffer 类型的 source instanceof Buffer === true; // Loader 返回的类型也可以是 Buffer 类型的 // 在 exports.raw !== true 时，Loader 也可以返回 Buffer 类型的结果 return source;&#125;;// 通过 exports.raw 属性告诉 Webpack 该 Loader 是否需要二进制数据 module.exports.raw = true; 缓存在有些情况下，有些转换操作需要大量计算非常耗时，如果每次构建都重新执行重复的转换操作，构建将会变得非常缓慢。 为此，Webpack会默认缓存所有Loader 的处理结果，也就是说在需要被处理的文件或者其依赖的文件没有发生变化时， 是不会重新调用对应的 Loader 去执行转换操作的。12345module.exports = function(source) &#123; // 关闭该 Loader 的缓存功能 this.cacheable(false); return source;&#125;; 其它 Loader API 完整API 方法名 含义 this.context 当前处理文件的所在目录，假如当前 Loader 处理的文件是 /src/main.js，则 this.context 就等于 /src this.resource 当前处理文件的完整请求路径，包括 querystring，例如 /src/main.js?name=1。 this.resourcePath 当前处理文件的路径，例如 /src/main.js this.resourceQuery 当前处理文件的 querystring this.target 等于 Webpack 配置中的 Target this.loadModule 但 Loader 在处理一个文件时，如果依赖其它文件的处理结果才能得出当前文件的结果时,就可以通过 this.loadModule(request: string, callback: function(err, source, sourceMap, module)) 去获得 request 对应文件的处理结果 this.resolve 像 require 语句一样获得指定文件的完整路径，使用方法为 resolve(context: string, request: string, callback: function(err, result: string)) this.addDependency 给当前处理文件添加其依赖的文件，以便再其依赖的文件发生变化时，会重新调用 Loader 处理该文件。使用方法为 addDependency(file: string) this.addContextDependency 和 addDependency 类似，但 addContextDependency 是把整个目录加入到当前正在处理文件的依赖中。使用方法为 addContextDependency(directory: string) this.clearDependencies 清除当前正在处理文件的所有依赖，使用方法为 clearDependencies() this.emitFile 输出一个文件，使用方法为 emitFile(name: string, content: Buffer/string, sourceMap: {…}) loader-utils.stringifyRequest Turns a request into a string that can be used inside require() or import while avoiding absolute paths. Use it instead of JSON.stringify(…) if you’re generating code inside a loader 把一个请求字符串转成一个字符串，以便能在require或者import中使用以避免绝对路径。如果你在一个loder中生成代码的话请使用这个而不要用JSON.stringify() loader-utils.interpolateName Interpolates a filename template using multiple placeholders and/or a regular expression. The template and regular expression are set as query params called name and regExp on the current loader’s context. 使用多个占位符或一个正则表达式转换一个文件名的模块。这个模板和正则表达式被设置为查询参数，在当前loader的上下文中被称为name或者regExp 参考 loader-utils schema-utils]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>loader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AST]]></title>
    <url>%2F2019%2F01%2F14%2FAST%2F</url>
    <content type="text"><![CDATA[抽象语法树(Abstract Syntax Tree)webpack和Lint等很多的工具和库的核心都是通过Abstract Syntax Tree抽象语法树这个概念来实现对代码的检查、分析等操作的。通过了解抽象语法树这个概念，你也可以随手编写类似的工具 抽象语法树用途 代码语法的检查、代码风格的检查、代码的格式化、代码的高亮、代码错误提示、代码自动补全等等 如JSLint、JSHint对代码错误或风格的检查，发现一些潜在的错误 IDE的错误提示、格式化、高亮、自动补全等等 代码混淆压缩 UglifyJS2等 优化变更代码，改变代码结构使达到想要的结构 代码打包工具webpack、rollup等等 CommonJS、AMD、CMD、UMD等代码规范之间的转化 CoffeeScript、TypeScript、JSX等转化为原生Javascript 抽象语法树定义这些工具的原理都是通过JavaScript Parser把代码转化为一颗抽象语法树（AST），这颗树定义了代码的结构，通过操纵这颗树，我们可以精准的定位到声明语句、赋值语句、运算语句等等，实现对代码的分析、优化、变更等操作 在计算机科学中，抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。Javascript的语法是为了给开发者更好的编程而设计的，但是不适合程序的理解。所以需要转化为AST来更适合程序分析，浏览器编译器一般会把源码转化为AST来进行进一步的分析等其他操作。 抽象语法树的生成过程（编译）js为例 词法分析（lexical analysis）：进行词法分析的程序或者函数叫作词法分析器（Lexical analyzer，简称Lexer），也叫扫描器（Scanner，例如typescript源码中的scanner.ts），字符流转换成对应的Token流。 tokenize：tokenize就是按照一定的规则，例如token令牌（通常代表关键字，变量名，语法符号等），将代码分割为一个个的串，也就是语法单元）。涉及到词法解析的时候，常会用到tokennize。 语法分析（parse analysis）：是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成语法树，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确。源程序的结构由上下文无关文法描述。 12const a = 1;const b = a + 1; 编译过程 词法解析过程：一边扫描源代码一边进行分类，例如扫描到第一行const a = 1,首先扫描到const，会生成一个语法单元说这是关键字const，接着扫描到a，这是变量名a，接着操作符=，接着常量1，等等，构成一个个token流。 语法分析过程：将token流转化为一个有元素层级嵌套所组成的代表程序语法结构的树，这个树被叫做抽象语法树AST。 JavaScript Parser JavaScript Parser:把js源码转化为抽象语法树的解析器 浏览器会把js源码通过解析器转为抽象语法树，再进一步转化为字节码或直接生成机器码。 一般来说每个js引擎都会有自己的抽象语法树格式，Chrome的v8引擎，firefox的SpiderMonkey引擎等等，MDN提供了详细SpiderMonkey AST format的详细说明，算是业界的标准。 常用的JavaScript Parser有 esprima traceur acorn(babel和webpack的实现) shift esprima 通过 esprima 把源码转化为AST 通过 estraverse 遍历并更新AST 通过 escodegen 将AST重新生成源码 astexplorer 1cnpm i esprima estraverse escodegen- S 12345678910111213141516171819202122232425let esprima = require('esprima');var estraverse = require('estraverse');var escodegen = require("escodegen");let code = 'function ast()&#123;&#125;';let ast=esprima.parse(code);let indent=0;function pad() &#123; return ' '.repeat(indent);&#125;estraverse.traverse(ast,&#123; enter(node) &#123; console.log(pad()+node.type); if(node.type == 'FunctionDeclaration')&#123; node.id.name = 'ast_rename'; &#125; indent+=2; &#125;, leave(node) &#123; indent-=2; console.log(pad()+node.type); &#125; &#125;);let generated = escodegen.generate(ast);console.log(generated); 12345678Program FunctionDeclaration Identifier Identifier BlockStatement BlockStatement FunctionDeclarationProgram 转换箭头函数 访问者模式Visitor 对于某个对象或者一组对象，不同的访问者，产生的结果不同，执行操作也不同 @babel/core babel-types它包含了构造、验证以及变换 AST 节点的方法 babel-types-api Babel 插件手册 babeljs.io babel-plugin-transform-es2015-arrow-functions 转换前1const sum = (a,b)=&gt;a+b 转换后123var sum = function sum(a, b) &#123; return a + b;&#125;; 实现1234567891011121314151617181920212223let babel = require('@babel/core');let t = require('babel-types'); //const code = `const sum = (a,b)=&gt;a+b`;// path.node 父节点// path.parentPath 父路径let transformArrowFunctions = &#123; visitor: &#123; ArrowFunctionExpression: (path, state) =&gt; &#123; let node = path.node; let id = path.parent.id; let params = node.params; let body=t.blockStatement([ t.returnStatement(node.body) ]); let functionExpression = t.functionExpression(id,params,body,false,false); path.replaceWith(functionExpression); &#125; &#125;&#125;const result = babel.transform(code, &#123; plugins: [transformArrowFunctions]&#125;);console.log(result.code); 预计算babel插件转换前1const result = 1 + 2; 转换后1const result = 3; 实现123456789101112131415161718192021222324252627let babel = require('@babel/core');let t=require('babel-types');let preCalculator=&#123; visitor: &#123; BinaryExpression(path) &#123; let node=path.node; let left=node.left; let operator=node.operator; let right=node.right; if (!isNaN(left.value) &amp;&amp; !isNaN(right.value)) &#123; let result=eval(left.value+operator+right.value); path.replaceWith(t.numericLiteral(result)); if (path.parent&amp;&amp; path.parent.type == 'BinaryExpression') &#123; preCalculator.visitor.BinaryExpression.call(null,path.parentPath); &#125; &#125; &#125; &#125;&#125;const result = babel.transform('const sum = 1+2+3',&#123; plugins:[ preCalculator ]&#125;);console.log(result.code); 把类编译为Function babel-plugin-transform-es2015-classes es612345678class Person &#123; constructor(name) &#123; this.name=name; &#125; getName() &#123; return this.name; &#125;&#125; es5123456function Person(name) &#123; this.name=name;&#125;Person.prototype.getName=function () &#123; return this.name;&#125; 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let babel = require('@babel/core');let t=require('babel-types');let source=` class Person &#123; constructor(name) &#123; this.name=name; &#125; getName() &#123; return this.name; &#125; &#125;`;let ClassPlugin=&#123; visitor: &#123; ClassDeclaration(path) &#123; let node=path.node; let id=node.id; let constructorFunction = t.functionDeclaration(id,[],t.blockStatement([]),false,false); let methods=node.body.body; let functions = []; methods.forEach(method =&gt; &#123; if (method.kind == 'constructor') &#123; constructorFunction = t.functionDeclaration(id,method.params,method.body,false,false); functions.push(constructorFunction); &#125; else &#123; let memberObj=t.memberExpression(t.memberExpression(id,t.identifier('prototype')),method.key); let memberFunction = t.functionExpression(id,method.params,method.body,false,false); let assignment = t.assignmentExpression('=',memberObj,memberFunction); functions.push(assignment); &#125; &#125;); if (functions.length ==1) &#123; path.replaceWith(functions[0]); &#125; else &#123; path.replaceWithMultiple(functions); &#125; &#125; &#125;&#125;const result = babel.transform(source,&#123; plugins:[ ClassPlugin ]&#125;);console.log(result.code); webpack babel插件12var babel = require("@babel/core");let &#123; transform &#125; = require("@babel/core"); 实现按需加载1import &#123; flatten,concat &#125; from "lodash" 转换为12import flatten from "lodash/flatten";import concat from "lodash/flatten"; webpack配置1cnpm i webpack webpack-cli -D 12345678910111213141516171819202122const path=require('path');module.exports=&#123; mode:'development', entry: './src/index.js', output: &#123; path: path.resolve('dist'), filename:'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.js$/, use: &#123; loader: 'babel-loader', options: &#123; plugins:[['import',&#123;library:'lodash'&#125;]] &#125; &#125; &#125; ] &#125;&#125; 编译顺序为首先plugins从左往右,然后presets从右往左 babel插件babel-plugin-import.js放置在node_modules目录下123456789101112131415161718192021222324let babel = require('@babel/core');let types = require('babel-types');const visitor = &#123; ImportDeclaration:&#123; enter(path,state=&#123;opts&#125;)&#123; const specifiers = path.node.specifiers; const source = path.node.source; if(state.opts.library == source.value &amp;&amp; !types.isImportDefaultSpecifier(specifiers[0]))&#123; const declarations = specifiers.map((specifier,index)=&gt;&#123; return types.ImportDeclaration( [types.importDefaultSpecifier(specifier.local)], types.stringLiteral(`$&#123;source.value&#125;/$&#123;specifier.local.name&#125;`) ) &#125;); path.replaceWithMultiple(declarations); &#125; &#125; &#125;&#125;module.exports = function(babel)&#123; return &#123; visitor &#125;&#125; 参考 AST抽象语法树 Babel 插件手册 babel-types 不同的parser解析js代码后得到的AST 在线可视化的看到AST babel从入门到入门的知识归纳 Babel 内部原理分析 babel-plugin-react-scope-binding transform-runtime Babel 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译,启用插件 babel-plugin-transform-runtime 后，Babel 就会使用 babel-runtime 下的工具函数 ast-spec babel-handbook]]></content>
      <tags>
        <tag>AST</tag>
        <tag>抽象语法树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-tapable]]></title>
    <url>%2F2019%2F01%2F14%2Fwebpack-tapable%2F</url>
    <content type="text"><![CDATA[webpack的插件机制webpack实现插件机制的大体方式是: 创建 - webpack在其内部对象上创建各种钩子； 注册 - 插件将自己的方法注册到对应钩子上，交给webpack； 调用 - webpack编译过程中，会适时地触发相应钩子，因此也就触发了插件的方法 tapableWebpack本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是Tapable，webpack中最核心的负责编译的Compiler和负责创建bundle的Compilation都是Tapable的实例 tapable用法1234567891011const &#123; SyncHook, SyncBailHook, SyncWaterfallHook, SyncLoopHook, AsyncParallelHook, AsyncParallelBailHook, AsyncSeriesHook, AsyncSeriesBailHook, AsyncSeriesWaterfallHook &#125; = require("tapable"); -2019114145412.png) 看起来起来功能和 EventEmit 类似，先注册事件，然后触发事件。不过 Tapable 的功能要比 EventEmit 强大。从官方介绍中，可以看到 Tapable 提供了很多类型的 Hook，分为同步和异步两个大类(异步中又区分异步并行和异步串行)，而根据事件执行的终止条件的不同，由衍生出 Bail/Waterfall/Loop 类型。 BasicHook: 执行每一个，不关心函数的返回值，有 SyncHook、AsyncParallelHook、AsyncSeriesHook。 BailHook: 顺序执行 Hook，遇到第一个结果 result !== undefined 则返回，不再继续执行。有：SyncBailHook、AsyncSeriseBailHook, AsyncParallelBailHook。 WaterfallHook: 类似于 reduce，如果前一个 Hook 函数的结果 result !== undefined，则 result 会作为后一个 Hook 函数的第一个参数。既然是顺序执行，那么就只有 Sync 和 AsyncSeries 类中提供这个Hook：SyncWaterfallHook，AsyncSeriesWaterfallHook LoopHook: 不停的循环执行 Hook，直到所有函数结果 result === undefined。同样的，由于对串行性有依赖，所以只有 SyncLoopHook 和 AsyncSeriseLoopHook （PS：暂时没看到具体使用 Case） SyncHook 串行同步执行,不关心返回值123456789101112131415let &#123;SyncHook&#125;=require('tapable');// 创建一个同步 Hook，指定参数let queue = new SyncHook(['name']);// 注册queue.tap('1',function(name)&#123; console.log(name,1);&#125;);queue.tap('2',function(name)&#123; console.log(name,2);&#125;);queue.tap('3',function(name)&#123; console.log(name,3);&#125;);// 调用queue.call('zfpx'); 实现1234567891011class SyncHook&#123; constructor()&#123; this.tasks=[] &#125; tap(name,task)&#123; this.tasks.push(task) &#125; call(...args)&#123; this.tasks.forEach(val=&gt;val(...args)) &#125;&#125; SyncBailHook 串行同步执行，有一个返回值不为null则跳过剩下的逻辑 break是跳出当前循环就是最近的一次循环，继续执行外循环， continue是指结束本次循环，这次循环后边的不执行了，继续最内层循环的循环 break是跳到了外层循环， return则终止该方法，后边的都不执行了。 12345678910111213let &#123;SyncBailHook&#125;=require('tapable');let queue = new SyncBailHook(['name']);queue.tap('1',function(name)&#123; console.log(name,1); return 'Wrong';&#125;);queue.tap('2',function(name)&#123; console.log(name,2);&#125;);queue.tap('3',function(name)&#123; console.log(name,3);&#125;);queue.call('zfpx'); 实现123456789101112131415161718class SyncBailHook&#123; constructor()&#123; this.tasks=[] &#125; tap(name,task)&#123; this.tasks.push(task) &#125; call(...args)&#123; // for(var val of this.tasks)&#123; // let ret= val(...args) // if(ret) break; // &#125; let i=0,ret=null; do&#123; ret=this.tasks[i++](...args) &#125;while(!ret) &#125;&#125; SyncWaterfallHook 串行同步执行,瀑布流,类似于reduce，将前一个结果当值 result !== undefined复制给下一个参数1234567891011121314let &#123;SyncWaterfallHook&#125;=require('tapable');let queue = new SyncWaterfallHook(['name']);queue.tap('1',function(name,age)&#123; console.log(name,age,1); return 1;&#125;);queue.tap('2',function(data)&#123; console.log(data,2); return 2;&#125;);queue.tap('3',function(data)&#123; console.log(data,3);&#125;);queue.call('zfpx',9); 实现123456789101112131415161718192021class SyncBailHook&#123; constructor()&#123; this.tasks=[] &#125; tap(name,task)&#123; this.tasks.push(task) &#125; call(...args)&#123; const [first,...tasks]=this.tasks let firstarg=args tasks.reduce((prev,next)=&gt;&#123; if(prev)&#123; firstarg=prev return next(prev) &#125;else&#123; return next(...firstarg) &#125; &#125;,first(...args)) &#125;&#125; SyncLoopHook 监听函数返回true表示继续循环，返回undefine表示结束循环123456789101112let &#123;SyncLoopHook&#125;=require('tapable');let queue = new SyncLoopHook(['name']);let count = 0;queue.tap('1',function(name)&#123; console.log(count++); if(count==3)&#123; return; &#125;else&#123; return true; &#125;&#125;);queue.call('zfpx'); 实现12345678910111213141516class SyncLoopHook&#123; constructor()&#123; this.tasks=[] &#125; tap(name,task)&#123; this.tasks.push(task) &#125; call(...args)&#123; this.tasks.forEach((val,index)=&gt;&#123; let ind=0,ret=true; do&#123; ret=this.tasks[ind++](...args) &#125;while(ret &amp;&amp; ind&lt;=index) &#125;) &#125;&#125; AsyncParallelHook 异步并行执行钩子 tap12345678910111213141516let &#123;AsyncParallelHook&#125;=require('tapable');let queue = new AsyncParallelHook(['name']);console.time('cost');queue.tap('1',function(name)&#123; console.log(1);&#125;);queue.tap('2',function(name)&#123; console.log(2);&#125;);queue.tap('3',function(name)&#123; console.log(3);&#125;);queue.callAsync('zfpx',err=&gt;&#123; console.log(err); console.timeEnd('cost');&#125;); 实现12345678910111213class AsyncParallelHook&#123; constructor()&#123; this.tasks=[] &#125; tap(name,task)&#123; this.tasks.push(task) &#125; callAsync(...args)&#123; let callback=args.pop(); this.tasks.forEach(task=&gt;task(...args)) callback(); &#125;&#125; tapAsync12345678910111213141516171819202122232425let &#123;AsyncParallelHook&#125;=require('tapable');let queue = new AsyncParallelHook(['name']);console.time('cost');queue.tapAsync('1',function(name,callback)&#123; setTimeout(function()&#123; console.log(1); callback(); &#125;,1000)&#125;);queue.tapAsync('2',function(name,callback)&#123; setTimeout(function()&#123; console.log(2); callback(); &#125;,2000)&#125;);queue.tapAsync('3',function(name,callback)&#123; setTimeout(function()&#123; console.log(3); callback(); &#125;,3000)&#125;);queue.callAsync('zfpx',err=&gt;&#123; console.log(err); console.timeEnd('cost');&#125;); 实现123456789101112131415161718class AsyncParallelHook&#123; constructor()&#123; this.tasks=[] &#125; tapAsync(name,task)&#123; this.tasks.push(task) &#125; callAsync(...args)&#123; let callback=args.pop(); let i=0,length = this.tasks.length; this.tasks.forEach(task=&gt;task(...args,done)) function done(err)&#123; if(++i==length)&#123; callback(err) &#125; &#125; &#125;&#125; tapPromise12345678910111213141516171819202122232425262728293031let &#123;AsyncParallelHook&#125;=require('tapable');let queue = new AsyncParallelHook(['name']);console.time('cost');queue.tapPromise('1',function(name)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; console.log(1); resolve(); &#125;,1000) &#125;);&#125;);queue.tapPromise('2',function(name)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; console.log(2); resolve(); &#125;,2000) &#125;);&#125;);queue.tapPromise('3',function(name)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; console.log(3); resolve(); &#125;,3000) &#125;);&#125;);queue.promise('zfpx').then(()=&gt;&#123; console.timeEnd('cost');&#125;) 实现12345678910111213141516171819202122232425class AsyncParallelHook&#123; constructor() &#123; this.tasks=[]; &#125; tapPromise(name,task) &#123; this.tasks.push(task); &#125; promise(...args) &#123; let promises = this.tasks.map(task =&gt; task(...args)); return new Promise(function(resolve,reject)&#123; let result=[] let count=0; for(let i=0;i&lt;promises.length;i++)&#123; promises[i].then(function(data)&#123; result[i]=data; if(++count===promise.length)&#123; resolve(result) &#125; &#125;,function (err) &#123; reject(err); &#125;) &#125; &#125;) &#125;&#125; AsyncParallelBailHook带保险的异步并行执行钩子 tap1234567891011121314151617181920212223242526272829303132333435//let &#123;AsyncParallelBailHook&#125; = require('tapable');class AsyncParallelBailHook&#123; constructor() &#123; this.tasks=[]; &#125; tap(name,task) &#123; this.tasks.push(task); &#125; callAsync() &#123; let args=Array.from(arguments); let callback=args.pop(); for (let i=0;i&lt;this.tasks.length;i++)&#123; let ret=this.tasks[i](...args); if (ret) &#123; return callback(ret); &#125; &#125; &#125;&#125;let queue=new AsyncParallelBailHook(['name']);console.time('cost');queue.tap('1',function(name)&#123; console.log(1); return "Wrong";&#125;);queue.tap('2',function(name)&#123; console.log(2);&#125;);queue.tap('3',function(name)&#123; console.log(3);&#125;);queue.callAsync('zfpx',err=&gt;&#123; console.log(err); console.timeEnd('cost');&#125;); tapAsync12345678910111213141516171819202122232425262728293031323334353637383940414243444546//let &#123;AsyncParallelBailHook&#125; = require('tapable');class AsyncParallelBailHook&#123; constructor() &#123; this.tasks=[]; &#125; tapAsync(name,task) &#123; this.tasks.push(task); &#125; callAsync() &#123; let args=Array.from(arguments); let finalCallback=args.pop(); let count=0,total=this.tasks.length; function done(err) &#123; if (err) &#123; return finalCallback(err); &#125; else &#123; if (++count == total) &#123; return finalCallback(); &#125; &#125; &#125; for (let i=0;i&lt;total;i++)&#123; let task=this.tasks[i]; task(...args,done); &#125; &#125;&#125;let queue=new AsyncParallelBailHook(['name']);console.time('cost');queue.tapAsync('1',function(name,callback)&#123; console.log(1); callback('Wrong');&#125;);queue.tapAsync('2',function(name,callback)&#123; console.log(2); callback();&#125;);queue.tapAsync('3',function(name,callback)&#123; console.log(3); callback();&#125;);queue.callAsync('zfpx',err=&gt;&#123; console.log(err); console.timeEnd('cost');&#125;); tapPromise12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//let &#123;AsyncParallelBailHook&#125; = require('tapable');class AsyncParallelBailHook&#123; constructor() &#123; this.tasks=[]; &#125; tapPromise(name,task) &#123; this.tasks.push(task); &#125; promise() &#123; let args=Array.from(arguments); let promises = this.tasks.map(task =&gt; task(...arguments)); return Promise.all(promises); &#125;&#125;let queue = new AsyncParallelBailHook(['name']);console.time('cost');queue.tapPromise('1',function(name)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; console.log(1); resolve(); &#125;,1000) &#125;);&#125;);queue.tapPromise('2',function(name)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; console.log(2); reject(); &#125;,2000) &#125;);&#125;);queue.tapPromise('3',function(name)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; console.log(3); resolve(); &#125;,3000) &#125;);&#125;);queue.promise('zfpx').then(()=&gt;&#123; console.timeEnd('cost');&#125;,err =&gt; &#123; console.error(err); console.timeEnd('cost');&#125;) AsyncSeriesHook 异步串行钩子 tap1234567891011121314151617let &#123;AsyncSeriesHook&#125; = require('tapable');let queue = new AsyncSeriesHook(['name']);console.time('cost');queue.tap('1',function(name)&#123; console.log(1);&#125;);queue.tap('2',function(name)&#123; console.log(2);&#125;);queue.tap('3',function(name)&#123; console.log(3);&#125;);queue.callAsync('zfpx',err=&gt;&#123; console.log(err); console.timeEnd('cost');&#125;); 实现1234567891011121314class AsyncSeriesHook&#123; constructor() &#123; this.tasks=[]; &#125; tap(name,task) &#123; this.tasks.push(task); &#125; callAsync(...args) &#123; for (let i=0;i&lt;total;i++)&#123; let task=this.tasks[i]; task(...args); &#125; &#125;&#125; tapAsync123456789101112131415161718192021222324252627282930313233343536373839404142434445class AsyncSeriesBailHook&#123; constructor() &#123; this.tasks=[]; &#125; tapAsync(name,task) &#123; this.tasks.push(task); &#125; callAsync() &#123; let args = Array.from(arguments); let finalCallback = args.pop(); let index = 0, length = this.tasks.length; let next = () =&gt; &#123; let task = this.tasks[index++]; if (task) &#123; task(...args, next); &#125; else &#123; finalCallback(); &#125; &#125; next(); &#125;&#125;let queue = new AsyncSeriesHook(['name']);console.time('cost');queue.tapAsync('1',function(name,callback)&#123; setTimeout(function()&#123; console.log(1); &#125;,1000)&#125;);queue.tapAsync('2',function(name,callback)&#123; setTimeout(function()&#123; console.log(2); callback(); &#125;,2000)&#125;);queue.tapAsync('3',function(name,callback)&#123; setTimeout(function()&#123; console.log(3); callback(); &#125;,3000)&#125;);queue.callAsync('zfpx',err=&gt;&#123; console.log(err); console.timeEnd('cost');&#125;); tapPromise123456789101112131415161718192021222324252627282930313233343536373839404142434445class AsyncSeriesHook&#123; constructor() &#123; this.tasks=[]; &#125; tapPromise(name,task) &#123; this.tasks.push(task); &#125; promise() &#123; //first是第一个函数， tasks是剩下的函数 let [first, ...tasks] = this.tasks; return tasks.reduce((a, b) =&gt; &#123; return a.then(() =&gt; b()); &#125;, first(...args)); &#125;&#125;let queue=new AsyncSeriesHook(['name']);console.time('cost');queue.tapPromise('1',function(name)&#123; return new Promise(function(resolve)&#123; setTimeout(function()&#123; console.log(1); resolve(); &#125;,1000) &#125;);&#125;);queue.tapPromise('2',function(name,callback)&#123; return new Promise(function(resolve)&#123; setTimeout(function()&#123; console.log(2); resolve(); &#125;,2000) &#125;);&#125;);queue.tapPromise('3',function(name,callback)&#123; return new Promise(function(resolve)&#123; setTimeout(function()&#123; console.log(3); resolve(); &#125;,3000) &#125;);&#125;);queue.promise('zfpx').then(data=&gt;&#123; console.log(data); console.timeEnd('cost');&#125;); AsyncSeriesBailHooktap1234567891011121314151617let &#123;AsyncSeriesBailHook&#125; = require('tapable');let queue = new AsyncSeriesBailHook(['name']);console.time('cost');queue.tap('1',function(name)&#123; console.log(1); return "Wrong";&#125;);queue.tap('2',function(name)&#123; console.log(2);&#125;);queue.tap('3',function(name)&#123; console.log(3);&#125;);queue.callAsync('zfpx',err=&gt;&#123; console.log(err); console.timeEnd('cost');&#125;); tabAsync1234567891011121314151617181920212223242526272829303132333435363738394041424344//let &#123;AsyncSeriesBailHook&#125;=require('tapable');class AsyncSeriesBailHook&#123; constructor() &#123; this.tasks=[]; &#125; tapAsync(name,task) &#123; this.tasks.push(task); &#125; callAsync() &#123; let args=Array.from(arguments); let callback=args.pop(); let i=0,size = this.tasks.length; let next=(err) =&gt; &#123; if (err) return callback(err); let task=this.tasks[i++]; task?task(...args,next):callback(); &#125; next(); &#125;&#125;let queue = new AsyncSeriesBailHook(['name']);console.time('cost');queue.tapAsync('1',function(name,callback)&#123; setTimeout(function()&#123; console.log(1); callback('wrong'); &#125;,1000)&#125;);queue.tapAsync('2',function(name,callback)&#123; setTimeout(function()&#123; console.log(2); callback(); &#125;,2000)&#125;);queue.tapAsync('3',function(name,callback)&#123; setTimeout(function()&#123; console.log(3); callback(); &#125;,3000)&#125;);queue.callAsync('zfpx',err=&gt;&#123; console.log(err); console.timeEnd('cost');&#125;); tapPromise1234567891011121314151617181920212223242526272829303132333435let &#123;AsyncSeriesBailHook&#125; = require('tapable');let queue = new AsyncSeriesBailHook(['name']);console.time('cost');queue.tapPromise('1',function(name)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; console.log(1); //resolve(); reject(); &#125;,1000) &#125;);&#125;);queue.tapPromise('2',function(name,callback)&#123; return new Promise(function(resolve)&#123; setTimeout(function()&#123; console.log(2); resolve(); &#125;,2000) &#125;);&#125;);queue.tapPromise('3',function(name,callback)&#123; return new Promise(function(resolve)&#123; setTimeout(function()&#123; console.log(3); resolve(); &#125;,3000) &#125;);&#125;);queue.promise('zfpx').then(err=&gt;&#123; console.log(err); console.timeEnd('cost');&#125;,err=&gt;&#123; console.log(err); console.timeEnd('cost');&#125;); AsyncSeriesWaterfallHooktap123456789101112131415let &#123;AsyncSeriesWaterfallHook&#125; = require('tapable');let queue = new AsyncSeriesWaterfallHook(['name']);console.time('cost');queue.tap('1',function(name,callback)&#123; console.log(1);&#125;);queue.tap('2',function(data)&#123; console.log(2,data);&#125;);queue.tap('3',function(data)&#123; console.log(3,data);&#125;);queue.callAsync('zfpx',err=&gt;&#123; console.log(err); console.timeEnd tapAsync1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//let &#123;AsyncSeriesBailHook&#125;=require('tapable');class AsyncSeriesWaterfallHook&#123; constructor() &#123; this.tasks=[]; &#125; tapAsync(name,task) &#123; this.tasks.push(task); &#125; callAsync() &#123; let args=Array.from(arguments); let callback=args.pop(); let i=0,size = this.tasks.length; let next=(err,data) =&gt; &#123; if (err) return callback(err); let task=this.tasks[i++]; if (task) &#123; if (i==0) &#123; task(...args,next); &#125; else &#123; task(data,next); &#125; &#125; else &#123; callback(err,data); &#125; &#125; next(); &#125;&#125;let queue = new AsyncSeriesWaterfallHook(['name']);console.time('cost');queue.tapAsync('1',function(name,callback)&#123; setTimeout(function()&#123; console.log(1); callback(null,1); &#125;,1000)&#125;);queue.tapAsync('2',function(data,callback)&#123; setTimeout(function()&#123; console.log(2); callback(null,2); &#125;,2000)&#125;);queue.tapAsync('3',function(data,callback)&#123; setTimeout(function()&#123; console.log(3); callback(null,3); &#125;,3000)&#125;);queue.callAsync('zfpx',(err,data)=&gt;&#123; console.log(err,data); console.timeEnd('cost');&#125;); tapPromise123456789101112131415161718192021222324252627282930313233343536373839404142434445let &#123;AsyncSeriesWaterfallHook&#125; = require('tapable');class AsyncSeriesWaterfallHook &#123; constructor() &#123; this.tasks = []; &#125; tapPromise(name, task) &#123; this.tasks.push(task); &#125; promise(...args) &#123; //first是第一个函数， tasks是剩下的函数 let [first, ...tasks] = this.tasks; return tasks.reduce((a, b) =&gt; &#123; return a.then((data) =&gt; b(data)); &#125;, first(...args)); &#125;&#125;let queue = new AsyncSeriesWaterfallHook(['name']);console.time('cost');queue.tapPromise('1', function (name) &#123; return new Promise(function (resolve) &#123; setTimeout(function () &#123; console.log(name, 1); resolve(1); &#125;, 1000); &#125;);&#125;);queue.tapPromise('2', function (data) &#123; return new Promise(function (resolve) &#123; setTimeout(function () &#123; console.log(data, 2); resolve(2); &#125;, 2000); &#125;);&#125;);queue.tapPromise('3', function (data) &#123; return new Promise(function (resolve) &#123; setTimeout(function () &#123; console.log(data, 3); resolve(3); &#125;, 3000); &#125;);&#125;);queue.promise('zfpx').then(err =&gt; &#123; console.timeEnd('cost');&#125;); tapable1234567891011const &#123;Tapable,SyncHook&#125; = require("tapable");const t = new Tapable();t.hooks = &#123; myHook: new SyncHook()&#125;;let called = 0;t.plugin("my-hook", () =&gt; called++);t.hooks.myHook.call();t.plugin("my-hook", () =&gt; called += 10);t.hooks.myHook.call();console.log(called); 参考 webpack-internal-plugin-relation webpack系列之二Tapable]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>tapable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-bundle-源码]]></title>
    <url>%2F2019%2F01%2F11%2Fwebpack-bundle-%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[webpack打包基础源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116 (function(modules) &#123; // webpack 启动函数 // 模块的缓存 var installedModules = &#123;&#125;; // webpack自己实现的在浏览器里能够执行的require方法 function __webpack_require__(moduleId) &#123; // 看看此模块是否在缓存中 if(installedModules[moduleId]) &#123; // 如果缓存有的话，则取它缓存的模块的对象的exports属性并返回 return installedModules[moduleId].exports; &#125; // 创建一个新的模块，并且放置到缓存 var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125;; // 执行模块函数,传入参数 // 1 module.exports=this 2.module 模块对象 3.module.exports 模块的导出对象 4.require方法 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // 把模块标识 为已加载 loaded=true module.l = true; // 返回模块的导出对象 return module.exports; &#125; // 把modules挂载到require的m属性 __webpack_require__.m = modules; // 把模块的缓存挂载到require的c属性上 __webpack_require__.c = installedModules; // 定义(define)一个getter方法 1导出对象 2名称 3 getter __webpack_require__.d = function(exports, name, getter) &#123; // 判断对象有没有某个属性 exports.hasOwnProperty(name) if(!__webpack_require__.o(exports, name)) &#123; //给exports对象定义name属性，值是可枚举的，get Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;); // exports[name] &#125; &#125;; /** * 对象的Symbol.toStringTag属性，指向一个方法 * 在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型 * 也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串 * (&#123;[Symbol.toStringTag]: 'Foo'&#125;.toString()) "[object Foo]" */ // 在导出对象上定义__esModule属性 //如果此exports对象__esModule属性为true的话，表示这是一个es6的模块 __webpack_require__.r = function(exports) &#123; if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) &#123; // 如果是支持es6的Symbol属性的话，那么定义属性 exports[Symbol.toStringTag] ='Module' Object.defineProperty(exports, Symbol.toStringTag, &#123; value: 'Module' &#125;); // exports.toString = "[object Module]" &#125; // exports['__esModule'] = true; Object.defineProperty(exports, '__esModule', &#123; value: true &#125;); &#125;; // create a fake namespace object // mode &amp; 1: value is a module id, require it // mode &amp; 2: merge all properties of value into the ns // mode &amp; 4: return value when already ns object // mode &amp; 8|1: behave like require __webpack_require__.t = function(value, mode) &#123; if(mode &amp; 1) value = __webpack_require__(value); if(mode &amp; 8) return value; if((mode &amp; 4) &amp;&amp; typeof value === 'object' &amp;&amp; value &amp;&amp; value.__esModule) return value; var ns = Object.create(null); __webpack_require__.r(ns); Object.defineProperty(ns, 'default', &#123; enumerable: true, value: value &#125;); if(mode &amp; 2 &amp;&amp; typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) &#123; return value[key]; &#125;.bind(null, key)); return ns; &#125;; // 获取默认导出函数为了兼容性 参数就是module对象 __webpack_require__.n = function(module) &#123; //hello //先拿到一个getter,如果是es模块，返回模块的default,否则返回自身 var getter = module &amp;&amp; module.__esModule ? function getDefault() &#123; return module['default']; &#125; : function getModuleExports() &#123; return module; &#125;; //var getter =function() &#123; return 'hello'; &#125;; //给getter上定义一个a属性，值为getter //该模块的a属性 = 模块本身 __webpack_require__.d(getter, 'a', getter); // get a()&#123;return 'a'&#125; obj['a'] // getter['a'] = getter; //(function() &#123; return 'hello'; &#125;)['a'] = (function() &#123; return 'hello'; &#125;) return getter; &#125;; // // Object.prototype.hasOwnProperty.call //判断对象有没有某个属性 __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;; //webpack的公开路径 webpack publicPath __webpack_require__.p = ""; // 加载入口模块并且返回导出对象 s就是入口标识符 return __webpack_require__(__webpack_require__.s = "./src/index.js"); &#125;) //modules是一个对象，有属性和值，属性就是此模块的ID，其实就是相对于根目录的相对路径 (&#123; "./src/index.js": (function(module, exports) &#123;eval("console.log('1')"); &#125;) &#125;); webpack打包懒加载源码./src/index.js123document.querySelector("#root").addEventListener("click",()=&gt;&#123; import("./a.js").then(res=&gt;res)&#125;) bundle.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264 (function (modules) &#123; //webpack的启动函数 // 安装一个JSONP的回调为了加载chunk代码块 function webpackJsonpCallback(data) &#123;//data=[[0],additionalModules] var chunkIds = data[0];//第一个元素是chunkId的数组 var moreModules = data[1];//这个chunk里包含的额外更多的模块 // 把这次取出来的更多的模块添加到modules对象中 // 然后把所有的chunkIds标识为已加载，并且执行回调函数 var moduleId, chunkId, i = 0, resolves = []; for (; i &lt; chunkIds.length; i++) &#123;//循环本次取出来的chunkIds chunkId = chunkIds[i];//先取出一个chunkId if (installedChunks[chunkId]) &#123;//如果说有值的话 //把这个installedChunks[chunkId]的0元素，promise resovle方法添加resolves数组中去 resolves.push(installedChunks[chunkId][0]); &#125; installedChunks[chunkId] = 0;//加载完成 &#125; //循环迭代新模块并且 for (moduleId in moreModules) &#123; //把新的模块对象的上的属性全部合并或者说拷贝到老的modules对象上 if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123; modules[moduleId] = moreModules[moduleId]; &#125; &#125; //如果parentJsonpFunction有值的话，调用它,其实就是jsonArray.push方法 // 如果没值说明先加载异步模块,window["webpackJsonp"]已经添加了该数组 if (parentJsonpFunction) parentJsonpFunction(data); //依次调用resolve方法，让每个promise都成功 while (resolves.length) &#123; //缓存的异步模块直接提示成功 resolve() resolves.shift()(); &#125; &#125;; // 模块的缓存 var installedModules = &#123;&#125;; // 这是一个对象，用来存放加载过的和加载中的代码 //chunk=undefined 表示未加载 // chunk=null 表示预加载或者预获取 //chunk=promise 的话表示加载中 //chunk=0 表示已加载或者说加载完成 var installedChunks = &#123; "main": 0 &#125;; // 用来生成脚本路径的函数 function jsonpScriptSrc(chunkId) &#123; return __webpack_require__.p + "" + chunkId + ".bundle.js" &#125; // require方法 function __webpack_require__(moduleId) &#123; // 检查模块是否在缓存 if (installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // 创建一个新模块并且放到缓存中 var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125;; // 执行模块函数，给module.exports赋值 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // 把模块设置为已加载 module.l = true; // 返回模块的导出对象 return module.exports; &#125; // 这个文件只包含入口chunk //这个代码块加载函数是为了加载额外的模块// chunkId=0 __webpack_require__.e = function requireEnsure(chunkId) &#123; var promises = [];//创建一个空的promise数组 // 先取出此chunkID对应的值 ,第一次的肯定是没有值 var installedChunkData = installedChunks[chunkId]; if (installedChunkData !== 0) &#123; // 0 means "already installed". // 如果返回值是一个promise表示正在加载 if (installedChunkData) &#123; promises.push(installedChunkData[2]); &#125; else &#123; // 在chunk缓存中创建一个promise var promise = new Promise(function (resolve, reject) &#123; // 将chunkData的数据赋值为一个数组 1.promise.resolve 2.promise.reject installedChunkData = installedChunks[chunkId] = [resolve, reject]; &#125;); // 把installedChunkData[2]赋值为整个promise并且添加到promise数组中去 promises.push(installedChunkData[2] = promise); // 开始代码块的加载 var script = document.createElement('script'); //创建一个script脚本 var onScriptComplete; //当脚本完成后 script.charset = 'utf-8';//设置脚本的编码 script.timeout = 120;//设置脚本的超时时间 if (__webpack_require__.nc) &#123; //用来安全处理的 nonce script.setAttribute("nonce", __webpack_require__.nc); &#125; // 拼出一个URL路径度且赋给script.src script.src = jsonpScriptSrc(chunkId); // 定义加载后的回调函数 onScriptComplete = function (event) &#123; // 防止IE下面的内存泄露 script.onerror = script.onload = null; // 清除定时器.如果是提前执行此函数，则需要先清除定时器 clearTimeout(timeout); // 取得已安装的代码块中的chunk var chunk = installedChunks[chunkId]; if (chunk !== 0) &#123;//如果不等0表示加载失败 if (chunk) &#123; var errorType = event &amp;&amp; (event.type === 'load' ? 'missing' : event.type); var realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src; var error = new Error('Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')'); error.type = errorType; error.request = realSrc; chunk[1](error);//直接调用chunk[1],把error作为参数传进去，调用promise的reject方法，让promise失败 &#125; //把对应的值置为undefine installedChunks[chunkId] = undefined; &#125; &#125;; //开启了一个定时器，如果说到了120秒之后请求还没有回来，我们就认为超时了，直接执行回调 var timeout = setTimeout(function () &#123; onScriptComplete(&#123; type: 'timeout', target: script &#125;); &#125;, 120000); script.onerror = script.onload = onScriptComplete; //把JSONP脚本添加到head标签 document.head.appendChild(script); &#125; &#125; return Promise.all(promises); //返回一个promise &#125;; // expose the modules object (__webpack_modules__) __webpack_require__.m = modules; // expose the module cache __webpack_require__.c = installedModules; // define getter function for harmony exports __webpack_require__.d = function (exports, name, getter) &#123; if (!__webpack_require__.o(exports, name)) &#123; Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;); &#125; &#125;; // define __esModule on exports __webpack_require__.r = function (exports) &#123; if (typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) &#123; Object.defineProperty(exports, Symbol.toStringTag, &#123; value: 'Module' &#125;); &#125; Object.defineProperty(exports, '__esModule', &#123; value: true &#125;); &#125;; // create a fake namespace object 创建一个模拟的命名空间 // mode &amp; 1: value is a module id, require it 模块是一个模块标识符 // mode &amp; 2: merge all properties of value into the ns 把所有的属性合并到ns上 // mode &amp; 4: return value when already ns object 当ns对象OK后返回value // mode &amp; 8|1: behave like require 和require表现一样 __webpack_require__.t = function (value, mode) &#123; //如果说mode是1的话，则用require去加载这个模块 if (mode &amp; 1) value = __webpack_require__(value); //如果mode是8的话，则直接返回 if (mode &amp; 8) return value; //如果是mode是4的话 直接返回value if ((mode &amp; 4) &amp;&amp; typeof value === 'object' &amp;&amp; value &amp;&amp; value.__esModule) return value; //创建一个空的对象 var ns = Object.create(null); //r就是在对象上定义__esModule= true __webpack_require__.r(ns);//ns是一个es模块 es.__esModule= true //ns的default属性为value Object.defineProperty(ns, 'default', &#123; enumerable: true, value: value &#125;); // ns['default'] = value; //如果mode值是2的话，把value上的所有属性全部拷贝到ns上 if (mode &amp; 2 &amp;&amp; typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) &#123; return value[key]; &#125;.bind(null, key)); return ns;//ns = &#123;__esModule:true,default:'video'&#125; &#125;; // getDefaultExport function for compatibility with non-harmony modules __webpack_require__.n = function (module) &#123; var getter = module &amp;&amp; module.__esModule ? function getDefault() &#123; return module['default']; &#125; : function getModuleExports() &#123; return module; &#125;; __webpack_require__.d(getter, 'a', getter); return getter; &#125;; // Object.prototype.hasOwnProperty.call __webpack_require__.o = function (object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;; // __webpack_public_path__ __webpack_require__.p = ""; // on error function for async loading __webpack_require__.oe = function (err) &#123; console.error(err); throw err; &#125;; // 刚开始的时候webpackJsonp是undefined,那么就给他一个空数组 var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || []; // 给数组的push方法绑定数组本身,如果以后有人再调用oldJsonpFunction,就相当于调用jsonpArray.push var oldJsonpFunction = jsonpArray.push.bind(jsonpArray); //让新数组的push方法指向另外一个函数webpackJsonpCallback jsonpArray.push = webpackJsonpCallback; //拷贝出来一个新的数组 jsonpArray = jsonpArray.slice(); //如果异步函数先加载完成执行的话， window["webpackJsonp"]为一个数组,寻韩执行这个函数 for (var i = 0; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]); // window["webpackJsonp"]的push方法赋值给parentJsonpFunction var parentJsonpFunction = oldJsonpFunction; // 加载入口模块并且返回导出对象 s就是入口标识符 return __webpack_require__(__webpack_require__.s = "./src/index.js"); &#125;) (&#123; "./src/index.js": (function (module, exports, __webpack_require__) &#123; eval(`document.querySelector("#root").addEventListener("click",()=&gt;&#123; __webpack_require__.e(0).then(__webpack_require__.t.bind(null,"./src/a.js", 7)).then(res=&gt;res) &#125;)`); &#125;) &#125;); 0.bundle1234567891011(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],&#123;"./src/a.js": (function(module, exports) &#123;eval("console.log('1')"); &#125;)&#125;]);]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>webpack源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack优化]]></title>
    <url>%2F2019%2F01%2F11%2Fwebpack%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[libraryTarget 和 library当用 Webpack 去构建一个可以被其他模块导入使用的库时需要用到它们 output.libraryTarget 配置以何种方式导出库 output.library 配置导出库的名称 output.libraryTarget 是字符串的枚举类型，支持以下配置 var (默认)编写的库将通过var被赋值给通过library指定名称的变量 index.js12345module.exports = &#123; add(a,b) &#123; return a+b; &#125;&#125; bundle.js1var calculator=(function (modules) &#123;&#125;(&#123;&#125;) index.html12345&lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;script&gt; let ret = calculator.add(1,2); console.log(ret);&lt;/script&gt; commonjs编写的库将通过 CommonJS 规范导出。1234// 导出方式exports["calculator"] = (function (modules) &#123;&#125;(&#123;&#125;)// 使用方式require('npm-name')['calculator'].add(1,2); //npm-name是指模块发布到 Npm 代码仓库时的名称 commonjs2编写的库将通过 CommonJS 规范导出。1234// 导出方式module.exports = (function (modules) &#123;&#125;(&#123;&#125;)// 使用方式require('npm-name').add(); //在 output.libraryTarget 为 commonjs2 时，配置 output.library 将没有意义 this编写的库将通过 this 被赋值给通过 library 指定的名称，输出和使用的代码如下：1234// 导出方式this["calculator"]= (function (modules) &#123;&#125;(&#123;&#125;)// 使用方式this.calculator.add(); window编写的库将通过 window 被赋值给通过 library 指定的名称，即把库挂载到 window 上，输出和使用的代码如下：1234// 导出方式window["calculator"]= (function (modules) &#123;&#125;(&#123;&#125;)// 使用方式window.calculator.add(); global编写的库将通过 global 被赋值给通过 library 指定的名称，即把库挂载到 global 上，输出和使用的代码如下：1234// 导出方式global["calculator"]= (function (modules) &#123;&#125;(&#123;&#125;)// 使用方式global.calculator.add(); 动态链接库DLL即把基础模块的代码打包进入动态链接库里，比如常用的react，vue等，当需要导入的模块在动态连接库里的时候，模块不能再次被打包，而是去动态连接库里获取 .dll为后缀的文件称为动态链接库，在一个动态链接库中可以包含给其他模块调用的函数和数据 把基础模块独立出来打包到单独的动态连接库里 当需要导入的模块在动态连接库里的时候，模块不能再次被打包，而是去动态连接库里获取 dll-plugin 定义Dll DllPlugin插件： 用于打包出一个个动态连接库 DllReferencePlugin: 在配置文件中引入DllPlugin插件打包好的动态连接库 创建一个webpack.dll.config.js文件打包常用类库到dll中12345678910111213141516171819202122const path=require('path');const DllPlugin=require('webpack/lib/DllPlugin');module.exports=&#123; entry: &#123; react:['react','react-dom'] &#125;,// 把 React 相关模块的放到一个单独的动态链接库 output: &#123; path: path.resolve(__dirname,'dist'),// 输出的文件都放到 dist 目录下 filename: '[name].dll.js',//输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称 library: '_dll_[name]',//存放动态链接库的全局变量名称,例如对应 react 来说就是 _dll_react &#125;, plugins: [ new DllPlugin(&#123; // 动态链接库的全局变量名称，需要和 output.library 中保持一致 // 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值 // 例如 react.manifest.json 中就有 "name": "_dll_react" name: '_dll_[name]', // 描述动态链接库的 manifest.json 文件输出时的文件名称 path: path.join(__dirname, 'dist', '[name].manifest.json') &#125;) ]&#125; 1webpack --config webpack.dll.config.js --mode development 在往配置文件 webpack.config.js中加入以下代码123456const DllReferencePlugin = require('webpack/lib/DllReferencePlugin')plugins: [ new DllReferencePlugin(&#123; manifest:require('./dist/react.manifest.json') &#125;)] 1webpack --config webpack.config.js --mode development 这样会从dll中获取React，而且不用再次打包React了。可以在HTML中这样使用12&lt;script src="react.dll.js"&gt;&lt;/script&gt;&lt;script src="bundle.js"&gt;&lt;/script&gt; 多进程之HappyPack 构建需要解析和处理文件,文件读写和计算密集型的操作太多后速度会很慢 Node.js 之上的 Webpack 是单线程模型 happypack 就能让Webpack把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。 1npm i happypack@next -D 123456789101112131415161718192021222324252627282930313233343536const HappyPack = require('happypack'); rules: [ &#123; test: /\.js$/, // 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例 use: ['happypack/loader?id=babel'], exclude: path.resolve(__dirname, 'node_modules'), &#125;, &#123; test: /\.css$/, // 把对 .css 文件的处理转交给 id 为 css 的 HappyPack 实例 use: ['happypack/loader?id=css'] &#125;]new Happypack(&#123; //ID是标识符的意思，ID用来代理当前的happypack是用来处理一类特定的文件的 id: 'js', use: [&#123; loader: 'babel-loader', //options=query都是向插件传递参数的 options: &#123; presets: [["@babel/preset-env", &#123; modules: false &#125;], "@babel/preset-react"], plugins: [ ["@babel/plugin-proposal-decorators", &#123; "legacy": true &#125;], ["@babel/plugin-proposal-class-properties", &#123; "loose": true &#125;], ] &#125; &#125;] &#125;),new Happypack(&#123; //ID是标识符的意思，ID用来代理当前的happypack是用来处理一类特定的文件的 id: 'css', use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader'], threads: 4,//你要开启多少个子进程去处理这一类型的文件 verbose: true//是否要输出详细的日志 verbose&#125;) CDNCDN 又叫内容分发网络，通过把资源部署到世界各地，用户在访问时按照就近原则从离用户最近的服务器获取资源，从而加速资源的获取速度 HTML文件不缓存，放在自己的服务器上，关闭自己服务器的缓存，静态资源的URL变成指向CDN服务器的地址 静态的JavaScript、CSS、图片等文件开启CDN和缓存，并且文件名带上HASH值 为了并行加载不阻塞，把不同的静态资源分配到不同的CDN服务器上 使用缓存由于 CDN 服务一般都会给资源开启很长时间的缓存，例如用户从 CDN 上获取到了 index.html 这个文件后， 即使之后的发布操作把 index.html 文件给重新覆盖了，但是用户在很长一段时间内还是运行的之前的版本，这会新的导致发布不能立即生效 解决办法 针对 HTML 文件：不开启缓存，把 HTML 放到自己的服务器上，而不是 CDN 服务上，同时关闭自己服务器上的缓存。自己的服务器只提供 HTML 文件和数据接口。 针对静态的 JavaScript、CSS、图片等文件：开启 CDN 和缓存，上传到 CDN 服务上去，同时给每个文件名带上由文件内容算出的 Hash 值 带上 Hash 值的原因是文件名会随着文件内容而变化，只要文件发生变化其对应的 URL 就会变化，它就会被重新下载，无论缓存时间有多长。 启用CDN之后 相对路径，都变成了绝对的指向 CDN 服务的 URL 地址 域名限制 同一时刻针对同一个域名的资源并行请求是有限制 可以把这些静态资源分散到不同的 CDN 服务上去 多个域名后会增加域名解析时间 可以通过在 HTML head 标签中 加入&lt;link rel=&quot;dns-prefetch&quot; href=&quot;&quot;&gt;去预解析域名，以降低域名解析带来的延迟 接入CDN要给网站接入 CDN，需要把网页的静态资源上传到 CDN 服务上去，在服务这些静态资源的时候需要通过CDN 服务提供的 URL 地址去访问12345output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name]_[hash:8].js', publicPath: 'http://img.zhufengpeixun.cn' &#125;, Tree Shakingtree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup。你可以将应用程序想象成一棵树。绿色表示实际用到的源码和 library，是树上活的树叶。灰色表示无用的代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。但是webpack的Tree Shaking依赖静态的ES6模块化语法即通过import和export导入导出的代码，而且需要引入一个能够删除未引用代码(dead code)的压缩工具(minifier)（例如 UglifyJSPlugin）或者在运行命令的时候用webpack --display-used-exports --optimize-minimize --mode production 不要编译ES6模块 要让 Tree Shaking 正常工作的前提是交给Webpack 的 JavaScript 代码必须是采用 ES6 模块化语法的 对于 module.export Webpack 无法分析出哪些代码可以剔除 &quot;modules&quot;: false 的含义是关闭 Babel 的模块转换功能，保留原本的 ES6 模块化语法。 123456use:[&#123; loader: 'babel-loader', options: &#123; presets:[['@babel/preset-env',&#123;modules: false &#125;],'@babel/preset-react'] &#125; &#125;] 显示未使用的导出实例1npx webpack --display-used-exports 剔除用不上的代码Webpack只是分析出了哪些函数用上了哪些没用上，要剔除用不上的代码还得经过UglifyJS去处理1webpack --display-used-exports --optimize-minimize 启用压缩123456789101112optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true,//启动缓存 parallel: true,//启动并行压缩 //如果为true的话，可以获得sourcemap sourceMap: true // set to true if you want JS source maps &#125;), //压缩css资源的 new OptimizeCSSAssetsPlugin(&#123;&#125;) ]&#125; 深度分析webpack-deep-scope-analysis-plugin12345678910111213import _ from 'lodash-es';//加法function isArray(value) &#123; return _.isArray(value);&#125;//减法function add(a, b) &#123; return a + b + _.isArray([]);&#125;export &#123; isArray, add&#125; 12345678const WebpackDeepScopeAnalysisPlugin = require('webpack-deep-scope-plugin').default;module.export = &#123; plugins: [ ..., new WebpackDeepScopeAnalysisPlugin(), ],&#125; 提取公共代码为什么需要提取公共代码？大网站有多个页面，每个页面由于采用相同技术栈和样式代码，会包含很多公共代码，如果都包含进来会有问题 相同的资源被重复的加载，浪费用户的流量和服务器的成本； 每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。 如果能把公共代码抽离成单独文件进行加载能进行优化，可以减少网络传输流量，降低服务器成本 如何提取 基础类库，方便长期缓存 页面之间的公用代码 各个页面单独生成文件 webpack版本用的都是commonchunkplugin,webpack4开始使用common-chunk-and-vendor-chunk 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152entry: &#123; pageA: './src/pageA', pageB: './src/pageB', pageC: './src/pageC' &#125;, output: &#123; path: path.resolve(__dirname,'dist'), filename: '[name].js' &#125;, optimization: &#123; splitChunks: &#123; cacheGroups: &#123; commons: &#123; chunks: "initial", minChunks: 2,//最小重复的次数 minSize: 0//最小提取字节数 &#125;, vendor: &#123; test: /node_modules/, chunks: "initial", name: "vendor", &#125; &#125; &#125; &#125; plugins:[ new HtmlWebpackPlugin(&#123; template: './src/index.html', filename: 'pageA.html', chunks: ['pageA'], minify: &#123; removeAttributeQuotes: true &#125; &#125;), new HtmlWebpackPlugin(&#123; template: './src/index.html', filename: 'pageB.html', chunks: ['pageB'], minify: &#123; removeAttributeQuotes: true &#125; &#125;), new HtmlWebpackPlugin(&#123; template: './src/index.html', filename: 'pageC.html', chunks: ['pageC'], minify: &#123; removeAttributeQuotes: true &#125; &#125;) ] 开启 Scope HoistingScope Hoisting 可以让 Webpack 打包出来的代码文件更小、运行的更快， 它又译作 “作用域提升”，是在 Webpack3 中新推出的功能。 代码体积更小，因为函数申明语句会产生大量代码 代码在运行时因为创建的函数作用域更少了，内存开销也随之变小 1234567891011const ModuleConcatenationPlugin = require('webpack/lib/optimize/ModuleConcatenationPlugin');module.exports = &#123; resolve: &#123; // 针对 Npm 中的第三方模块优先采用 jsnext:main 中指向的 ES6 模块化语法的文件 mainFields: ['jsnext:main', 'browser', 'main'] &#125;, plugins: [ // 开启 Scope Hoisting new ModuleConcatenationPlugin(), ],&#125;; hello.js1export default 'Hello'; index.js12import str from './hello.js';console.log(str); 输出的结果main.js123456789101112131415161718var n = name = "zfpx";console.log(n)``` 函数由两个变成了一个，`hello.js` 中定义的内容被直接注入到了 `main.js` 中## 动态导入和懒加载用户当前需要用什么功能就只加载这个功能对应的代码，也就是所谓的按需加载 在给单页应用做按需加载优化时，一般采用以下原则：- 对网站功能进行划分，每一类一个`chunk`- 对于首次打开页面需要的功能直接加载，尽快展示给用户- 某些依赖大量代码的功能点可以按需加载- 被分割出去的代码需要一个按需加载的时机handler.js```jsmodule.exports=function () &#123; alert('你点我啦!');&#125; index.js12345document.querySelector('#clickBtn').addEventListener('mouseover',() =&gt; &#123; import('./handler').then(clickMe =&gt; &#123; window.clickMe=clickMe.default; &#125;);&#125;); html1&lt;div id="clickBtn" onclick="clickMe()"&gt;弹框&lt;/div&gt; react-router4 路由懒加载index.js12345678910111213import React from 'react';import ReactDOM from 'react-dom';import &#123;HashRouter as Router,Route&#125; from 'react-router-dom';import Bundle from './Bundle';let LazyAbout=(props) =&gt; (&lt;Bundle &#123;...props&#125; load=&#123;()=&gt;import('./About')&#125;/&gt;)let Home=() =&gt; &lt;div&gt;Home&lt;/div&gt;ReactDOM.render(&lt;Router&gt; &lt;div&gt; &lt;Route path="/" component=&#123;Home&#125; /&gt; &lt;Route path="/about" component=&#123;LazyAbout&#125;/&gt; &lt;/div&gt;&lt;/Router&gt;,document.getElementById('root')); Bundle1234567891011import React from 'react';export default class Bundle extends React.Component&#123; state=&#123;Mod: null&#125; componentWillMount() &#123; this.props.load().then(mod=&gt;this.setState(&#123;Mod: mod.default? mod.default:mod&#125;)); &#125; render() &#123; let Mod=this.state.Mod; return Mod&amp;&amp;&lt;Mod &#123;...this.props&#125;/&gt;; &#125;&#125; About12import React from 'react';export default props =&gt; &lt;div&gt;About&lt;/div 参考 webpack demo]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>webpack优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-1]]></title>
    <url>%2F2019%2F01%2F08%2Fwebpack-1%2F</url>
    <content type="text"><![CDATA[什么是webpackWebpack是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。Webpack 专注于构建模块化项目。 一切文件：JavaScript、CSS、SCSS、图片、模板，在 Webpack 眼中都是一个个模块，这样的好处是能清晰的描述出各个模块之间的依赖关系，以方便 Webpack 对模块进行组合和打包。 经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。 自动化构建构建就是把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。 模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 webpack核心概念 Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。 Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。 Loader：模块转换器，用于把模块原内容按照需求转换成新内容。 Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。 Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。 webpack执行流程Webpack 启动后会从Entry里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的Loader去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。 配置webpack1npm install webpack webpack-cli -D 基本配置文件 配置文件webpack.config.js entry：配置入口文件的地址 output：配置出口文件的地址 module：配置模块,主要用来配置不同文件的加载器 plugins：配置插件 devServer：配置开发服务器 1234567891011const path=require('path');module.exports=&#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname,'dist'), //绝对路径 filename:'[name].[hash:8].js' &#125;, module: &#123;&#125;, plugins: [], devServer: &#123;&#125;&#125; 1. 配置开发服务器1npm i webpack-dev-server –D contentBase: 配置开发服务运行时的文件根目录 host：开发服务器监听的主机地址 compress: 开发服务器是否启动gzip等压缩 port：开发服务器监听的端口 1234567devServer: &#123; contentBase: path.join(__dirname, "dist"), //静态文件根目录 port: 9090, // 端口 host: 'localhost', overlay: true, compress: true // 服务器返回浏览器的时候是否启动gzip压缩&#125; 配置文件package.json 1234"scripts": &#123; "build": "webpack --mode development", "dev": "webpack-dev-server --open --mode development "&#125; 什么是Loader通过使用不同的Loader，Webpack可以要把不同的文件都转成JS文件,比如CSS、ES6/7、JSX等 test：匹配处理文件的扩展名的正则表达式 use：loader名称，就是你要使用模块的名称 include/exclude:手动指定必须处理的文件夹或屏蔽不需要处理的文件夹 query：为loaders提供额外的设置选项 loader有3种写法1.1 loader加载CSS文件，CSS文件有可能在node_modules里，比如bootstrap和antd12345678module: &#123; rules: [ &#123; test: /\.css/, loader:['style-loader','css-loader'] &#125; ] &#125; 1.2 use12345678module: &#123; rules: [ &#123; test: /\.css/, use:['style-loader','css-loader'] &#125; ] &#125;, 1.3 useloader12345678910111213141516171819// css-loader用来处理css中url的路径// style-loader可以把css文件变成style标签插入head中// 多个loader是有顺序要求的，从右往左写，因为转换的时候是从右往左转换的 module: &#123; rules: [ &#123; test: /\.css/, include: path.resolve(__dirname,'src'),//限制范围，提高打包速度 exclude: /node_modules/ exclude: /node_modules/, use: [&#123; loader: 'style-loader', options: &#123; insertAt:'top' //插入head的最前面 &#125; &#125;,'css-loader'] &#125; ] &#125; 支持加载css文件 css-loader style-loader 支持图片1npm i file-loader url-loader -D file-loader 解决CSS等文件中的引入图片路径问题 url-loader 当图片小于limit的时候会把图片BASE64编码，大于limit参数的时候还是使用file-loader 进行拷贝 js中引入图片1234let logo=require('./images/logo.png');let img=new Image();img.src=logo;document.body.appendChild(img) 123456789&#123; test:/\.(jpg|png|bmp|gif|svg|ttf|woff|woff2|eot)/, use:[ &#123; loader:'url-loader', options:&#123;limit:4096&#125; &#125; ]&#125; 在CSS中引入图片123456.logo&#123; width:355px; height:133px; background-image: url(./images/logo.png); background-size: cover;&#125; HTML1&lt;div class="logo"&gt;&lt;/div&gt; 分离CSS因为CSS的下载和JS可以并行,当一个HTML文件很大的时候，我们可以把CSS单独提取出来加载 mini-css-extract-plugin filename 打包入口文件 chunkFilename 用来打包import(&#39;module&#39;)方法中引入的模块 1npm install --save-dev mini-css-extract-plugin 配置webpack.config.js12345678910111213141516plugins: [ //参数类似于webpackOptions.output new MiniCssExtractPlugin(&#123; filename: '[name].css', chunkFilename:'[id].css' &#125;),]&#123; test: /\.css/, include: path.resolve(__dirname,'src'), exclude: /node_modules/, use: [&#123; loader: MiniCssExtractPlugin.loader &#125;,'css-loader']&#125; 压缩JS和CSS1npm i uglifyjs-webpack-plugin optimize-css-assets-webpack-plugin -D 1234567891011121314151617const UglifyJsPlugin = require("uglifyjs-webpack-plugin");const OptimizeCSSAssetsPlugin = require("optimize-css-assets-webpack-plugin");module.exports = &#123; mode: 'development', optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true,//启动缓存 parallel: true,//启动并行压缩 //如果为true的话，可以获得sourcemap sourceMap: true // set to true if you want JS source maps &#125;), //压缩css资源的 new OptimizeCSSAssetsPlugin(&#123;&#125;) ] &#125;,&#125; css和image存放单独目录 outputPath 输出路径 publicPath指定的是构建后在html里的路径 12345678910111213141516171819202122232425output: &#123; path: path.resolve(__dirname,'dist'), filename: 'bundle.js', publicPath:'/' &#125;,&#123; test:/\.(jpg|jpeg|png|bmp|gif|svg|ttf|woff|woff2|eot)/, use:[ &#123; loader:'url-loader', options:&#123; limit: 4096, outputPath: 'images', publicPath:'/images' &#125; &#125; ]&#125;plugins: [ new MiniCssExtractPlugin(&#123; filename: 'css/[name].css', chunkFilename:'css/[id].css' &#125;),] 在HTML中使用图片1npm i html-withimg-loader -D index.html1&lt;img src="./images/logo.png"/&gt; webpack.config.js1234&#123; test: /\.(html|htm)$/, use: 'html-withimg-loader'&#125; 编译less 和 sass安装less和sass12npm i less less-loader -Dnpm i node-sass sass-loader -D 编写样式less1234@color:orange;.less-container&#123; color:@color;&#125; sass1234$color:green;.sass-container&#123; color:green;&#125; webpack.config.js12345678910111213141516&#123; test: /\.less/, include: path.resolve(__dirname,'src'), exclude: /node_modules/, use: [&#123; loader: MiniCssExtractPlugin.loader, &#125;,'css-loader','less-loader'] &#125;, &#123; test: /\.scss/, include: path.resolve(__dirname,'src'), exclude: /node_modules/, use: [&#123; loader: MiniCssExtractPlugin.loader, &#125;,'css-loader','sass-loader'] &#125;, 处理CSS3属性前缀为了浏览器的兼容性，有时候我们必须加入-webkit,-ms,-o,-moz这些前缀 Trident内核：主要代表为IE浏览器, 前缀为-ms Gecko内核：主要代表为Firefox, 前缀为-moz Presto内核：主要代表为Opera, 前缀为-o Webkit内核：产要代表为Chrome和Safari, 前缀为-webkit 安装postcss-loader1npm i postcss-loader autoprefixer -D postcss.config.js1234567891011121314module.exports = &#123; "plugins": &#123; // to edit target browsers: use "browserslist" field in package.json "autoprefixer": &#123; "browsers": [ "ie &gt;= 9", "ff &gt;= 30", "chrome &gt;= 34", "safari &gt;= 7", "opera &gt;= 23" ] &#125; &#125;&#125; webpack.config.js123456&#123; test:/\.css$/, use:[MiniCssExtractPlugin.loader,'css-loader','postcss-loader'], include:path.join(__dirname,'./src'), exclude:/node_modules/&#125; 转义ES6/ES7/JSX Babel其实是一个编译JavaScript的平台,可以把ES6/ES7,React的JSX转义为ES5 babel-plugin-proposal-decorators 安装依赖包12npm i babel-loader @babel/core @babel/preset-env @babel/preset-react -Dnpm i @babel/plugin-proposal-decorators @babel/plugin-proposal-class-properties -D webpack.config.js1234567891011121314&#123; test: /\.jsx?$/, use: &#123; loader: 'babel-loader', options:&#123; "plugins": [ ["@babel/plugin-proposal-decorators", &#123; "legacy": true &#125;], ["@babel/plugin-proposal-class-properties", &#123; "loose" : true &#125;] ] &#125; &#125;, include: path.join(__dirname,'src'), exclude:/node_modules/&#125; babel runtime babel 在每个文件都插入了辅助代码，使代码体积过大 babel 对一些公共方法使用了非常小的辅助代码，比如 _extend 默认情况下会被添加到每一个需要它的文件中。你可以引入 @babel/runtime 作为一个独立模块，来避免重复引入 babel-plugin-transform-runtime 安装依赖包12npm install --save-dev @babel/plugin-transform-runtimenpm install --save @babel/runtime .babelrc1234567891011121314&#123; "presets": ["@babel/preset-env"], "plugins": [ [ "@babel/plugin-transform-runtime", &#123; "corejs": false, "helpers": true, "regenerator": true, "useESModules": true &#125; ] ]&#125; webpack打包的时候，会自动优化重复引入公共方法的问题 ESLint校验代码格式规范 eslint eslint-loader configuring babel-eslint Rules ESlint 语法检测配置说明 安装依赖包1npm install eslint eslint-loader babel-eslint --D .eslintrc.js12345678910111213141516171819module.exports = &#123; root: true, //指定解析器选项 parserOptions: &#123; sourceType: 'module' &#125;, //指定脚本的运行环境 env: &#123; browser: true, &#125;, // 启用的规则及其各自的错误级别 rules: &#123; "indent": ["error", 4],//缩进风格 "quotes": ["error", "double"],//引号类型 "semi": ["error", "always"],//关闭语句强制分号结尾 "no-console": "error",//禁止使用console "arrow-parens": 0 //箭头函数用小括号括起来 &#125;&#125; webpack.config.js1234567891011module: &#123; //配置加载规则 rules: [ &#123; test: /\.js$/, loader: 'eslint-loader', enforce: "pre", //在所有loader执行之前执行 include: [path.resolve(__dirname, 'src')], // 指定检查的目录 options: &#123; fix: true &#125; // 这里的配置项参数将会被传递到 eslint 的 CLIEngine &#125;,&#125; 对图片进行压缩和优化image-webpack-loader可以帮助我们对图片进行压缩和优化1npm install image-webpack-loader --save-dev 12345678910111213141516171819202122232425262728&#123; test: /\.(png|svg|jpg|gif|jpeg|ico)$/, use: [ 'file-loader', &#123; loader: 'image-webpack-loader', options: &#123; mozjpeg: &#123; progressive: true, quality: 65 &#125;, optipng: &#123; enabled: false, &#125;, pngquant: &#123; quality: '65-90', speed: 4 &#125;, gifsicle: &#123; interlaced: false, &#125;, webp: &#123; quality: 75 &#125; &#125; &#125;, ] &#125; 插件 在 webpack 的构建流程中，plugin 用于处理更多其他的一些构建任务 模块代码转换的工作由 loader 来处理 除此之外的其他任何工作都可以交由 plugin 来完成 自动产出html我们希望自动能产出HTML文件，并在里面引入产出后的资源1npm i html-webpack-plugin -D minify:是对html文件进行压缩， removeAttrubuteQuotes:是去掉属性的双引号 hash:引入产出资源的时候加上查询参数，值为哈希避免缓存 template:模版路径 123456789plugins: [ new HtmlWebpackPlugin(&#123; minify: &#123; removeAttributeQuotes:true &#125;, hash: true, template: './src/index.html', filename:'index.html' &#125;)] 添加商标1new webpack.BannerPlugin('珠峰培训') 拷贝静态文件有时项目中没有引用的文件也需要打包到目标目录1npm i copy-webpack-plugin -D 1234new CopyWebpackPlugin([&#123; from: path.resolve(__dirname,'src/assets'),//静态资源目录源地址 to:path.resolve(__dirname,'dist/assets') //目标地址，相对于output的path目录&#125;]) 打包前先清空输出目录1npm i clean-webpack-plugin -D 1new CleanWebpackPlugin([path.resolve(__dirname,'dist')]) DefinePluginDefinePlugin创建一些在编译时可以配置的全局常量12345678new webpack.DefinePlugin(&#123; PRODUCTION: JSON.stringify(true), VERSION: "1", EXPRESSION: "12", COPYRIGHT: &#123; AUTHOR: JSON.stringify("珠峰培训") &#125;&#125;) 1234console.log(PRODUCTION);console.log(VERSION);console.log(EXPRESSION);console.log(COPYRIGHT); 如果配置的值是字符串，那么整个字符串会被当成代码片段来执行，其结果作为最终变量的值，,类似eval执行的其值 如果配置的值不是字符串，也不是一个对象字面量，那么该值会被转为一个字符串，如 true，最后的结果是 ‘true’ 如果配置的是一个对象字面量，那么该对象的所有 key 会以同样的方式去定义 JSON.stringify(true) 的结果是 ‘true’ IgnorePluginIgnorePlugin用于忽略某些特定的模块，让 webpack 不把这些指定的模块打包进去12import moment from 'moment';console.log(moment); 1new webpack.IgnorePlugin(/^\.\/locale/,/moment$/) 第一个是匹配引入模块路径的正则表达式 第二个是匹配模块的对应上下文，即所在目录名 如何调试打包后的代码webpack通过配置可以自动给我们source maps文件,map文件是一种对应编译文件和源文件的方法 source-map: 在单独文件中生成，可以映射到列 cheap-module-source-map: 在单独文件中生成，可以映射到列 eval-source-map: 在同一个文件内生成source map，可以映射到列 cheap-module-eval-source-map: 在同一个文件内生成source map，不可以映射到列 1devtool:'eval-source-map' 打包第三方类库直接引入12import _ from 'lodash';alert(_.join(['a','b','c'],'@')); 插件引入 类似在每个模块下引用import _ from &#39;lodash 函数会自动添加到当前模块的上下文，无需显示声明 执行上下文，这是一个局部变量 如果你有一个第三方的插件，依赖全局对象下的属性 jqueryui 他会依赖window.jquery,所以不行123new webpack.ProvidePlugin(&#123; _:'lodash'&#125;) expose-loader不需要任何其他的插件配合，只要将下面的代码添加到所有的loader之前1require("expose-loader?libraryName!./file.js"); 1234&#123; test: require.resolve("jquery"), loader: "expose-loader?jQuery"&#125; 1require("expose-loader?$!jquery"); externals如果我们想引用一个库，但是又不想让webpack打包，并且又不影响我们在程序中以CMD、AMD或者window/global全局等方式进行使用，那就可以通过配置externals 12const jQuery = require("jquery");import jQuery from 'jquery'; 1234externals: &#123; // key 模块名 ,value就是真正运行时从window的那个属性上取值 jquery: 'jQuery'//如果要在浏览器中运行，那么不用添加什么前缀，默认设置就是global&#125; cross-envprocess.env属性返回一个包含用户环境信息的对象 配置环境变量Windows配置 临时配置(命令行) 12345678#node中常用的到的环境变量是NODE_ENV，首先查看是否存在 set NODE_ENV #如果不存在则添加环境变量 set NODE_ENV=production #环境变量追加值 set 变量名=%变量名%;变量内容 set path=%path%;C:\web;C:\Tools #某些时候需要删除环境变量 set NODE_ENV= 永久配置 1右键(此电脑) -&gt; 属性(R) -&gt; 高级系统设置 -&gt; 环境变量(N)... Linux配置 临时(命令行) 12345678910#node中常用的到的环境变量是NODE_ENV，首先查看是否存在echo $NODE_ENV#如果不存在则添加环境变量export NODE_ENV=production#环境变量追加值export path=$path:/home/download:/usr/local/#某些时候需要删除环境变量unset NODE_ENV#某些时候需要显示所有的环境变量env 永久(配置文件) 12345678910111213# 所有用户都生效vim /etc/profile# 当前用户生效vim ~/.bash_profile# 在文件末尾添加如下格式的环境变量export path=$path:/home/download:/usr/local/export NODE_ENV = product# 修改/etc/profile文件后source /etc/profile# 修改~/.bash_profile文件后source ~/.bash_profile 因为windows不支持NODE_ENV=development的设置方式。 可以通过cross-env实现1cross-env NODE_ENV=development webpack --mode=development 服务器代理如果你有单独的后端开发服务器 API，并且希望在同域名下发送 API 请求 ，那么代理某些 URL 会很有用。 不修改路径请求到 /api/users 现在会被代理到请求 http://localhost:3000/api/users。1234// api开头的接口代理到3000端口proxy: &#123; "/api": 'http://localhost:3000'&#125; 修改路径12345678// api开头的接口代理到3000端口// api/users===&gt;usersproxy: &#123; "/api": &#123; target: 'http://localhost:3000', pathRewrite:&#123;"^/api":""&#125; &#125; &#125; before afterbefore 在 webpack-dev-server 静态资源中间件处理之前，可以用于拦截部分请求返回特定内容，或者实现简单的数据 mock12345before(app)&#123; app.get('/api/users', function(req, res) &#123; res.json([&#123;id:1,name:'zfpx1'&#125;]) &#125;)&#125; webpack-dev-middlewarewebpack-dev-middleware就是在 Express 中提供 webpack-dev-server 静态服务能力的一个中间件 1npm install webpack-dev-middleware --save-dev 123456789const express = require('express');const app = express();const webpack = require('webpack');const webpackDevMiddleware = require('webpack-dev-middleware');const webpackOptions = require('./webpack.config');webpackOptions.mode = 'development';const compiler = webpack(webpackOptions);app.use(webpackDevMiddleware(compiler, &#123;&#125;));app.listen(3000); webpack-dev-server 的好处是相对简单，直接安装依赖后执行命令即可 而使用webpack-dev-middleware的好处是可以在既有的Express 代码基础上快速添加webpack-dev-server 的功能，同时利用 Express 来根据需要添加更多的功能，如 mock 服务、代理 API 请求等 resolve解析extensions指定extension之后可以不用在require或是import的时候加文件扩展名,会依次尝试添加扩展名进行匹配123resolve: &#123; extensions: [".js",".jsx",".json",".css"]&#125;, alias 配置别名可以加快webpack查找模块的速度 每当引入bootstrap模块的时候，它会直接引入bootstrap,而不需要从node_modules文件夹中按模块的查找规则查找 123456const bootstrap = path.resolve(__dirname,'node_modules/_bootstrap@3.3.7@bootstrap/dist/css/bootstrap.css');resolve: &#123; alias:&#123; "bootstrap":bootstrap &#125;&#125;, modules 对于直接声明依赖名的模块（如 react ），webpack 会类似 Node.js 一样进行路径搜索，搜索node_modules目录 这个目录就是使用resolve.modules字段进行配置的 默认配置 123resolve: &#123;modules: ['node_modules'],&#125; 如果可以确定项目内所有的第三方依赖模块都是在项目根目录下的 node_modules 中的话123resolve: &#123;modules: [path.resolve(__dirname, 'node_modules')],&#125; mainFields默认情况下package.json 文件则按照文件中 main 字段的文件名来查找文件123456resolve: &#123; // 配置 target === "web" 或者 target === "webworker" 时 mainFields 默认值是： mainFields: ['browser', 'module', 'main'], // target 的值为其他时，mainFields 默认值为： mainFields: ["module", "main"],&#125; mainFiles当目录下没有 package.json 文件时，我们说会默认使用目录下的 index.js 这个文件，其实这个也是可以配置的123resolve: &#123; mainFiles: ['index'], // 你可以添加其他默认使用的文件名&#125;, resolveLoaderresolve.resolveLoader用于配置解析 loader 时的 resolve 配置,默认的配置：1234567module.exports = &#123; resolveLoader: &#123; modules: [ 'node_modules' ], extensions: [ '.js', '.json' ], mainFields: [ 'loader', 'main' ] &#125;&#125;; noParse module.noParse 字段，可以用于配置哪些模块文件的内容不需要被loaders解析 不需要解析依赖（即无依赖） 的第三方大型类库等，可以通过这个字段来配置，以提高整体的构建速度 使用 noParse 进行忽略的模块文件中不能使用 import、require、define 等导入机制,因为这些模块加载并不会被解析，所以就会报错 12345678910module.exports = &#123;// ...module: &#123; noParse: /jquery|lodash/, // 正则表达式 // 或者使用函数 noParse(content) &#123; return /jquery|lodash/.test(content) &#125;,&#125;&#125; watch当代码发生修改后可以自动重新编译 webpack定时获取文件的更新时间，并跟上次保存的时间进行比对，不一致就表示发生了变化,poll就用来配置每秒问多少次 当检测文件不再发生变化，会先缓存起来，等待一段时间后之后再通知监听者，这个等待时间通过aggregateTimeout配置 webpack只会监听entry依赖的文件 我们需要尽可能减少需要监听的文件数量和检查频率，当然频率的降低会导致灵敏度下降123456watch: true,watchOptions: &#123; ignored: /node_modules/, //忽略不用监听变更的目录 poll:1000, //每秒询问的文件变更的次数 aggregateTimeout: 500, //防止重复保存频繁重新编译,500毫秒内重复保存不打包&#125; 区分环境变量 日常的前端开发工作中，一般都会有两套构建环境 一套开发时使用，构建结果用于本地开发调试，不进行代码压缩，打印 debug 信息，包含 sourcemap 文件 一套构建后的结果是直接应用于线上的，即代码都是压缩后，运行时不打印 debug 信息，静态文件不包括 sourcemap webpack 4.x 版本引入了 mode 的概念 当你指定使用 production mode 时，默认会启用各种性能优化的功能，包括构建结果优化以及 webpack 运行性能优化 而如果是 development mode 的话，则会开启 debug 工具，运行时打印详细的错误信息，以及更加快速的增量编译构建 环境差异 生产环境 可能需要分离 CSS 成单独的文件，以便多个页面共享同一个 CSS 文件 需要压缩HTML/CSS/JS 代码 需要压缩图片 开发环境 需要生成 sourcemap 文件 需要打印 debug 信息 需要 live reload 或者 hot reload 的功能… 获取mode参数1npm install --save-dev optimize-css-assets-webpack-plugin 1234567891011121314const UglifyJSPlugin = require('webpack/lib/optimize/UglifyJsPlugin');const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');module.exports=(env,argv) =&gt; (&#123; optimization: &#123; minimizer: argv.mode == 'production'?[ new UglifyJSplugin(&#123; cache: true,//启用缓存 parallel: true,// 使用多进程运行改进编译速度 sourceMap:true//生成sourceMap映射文件 &#125;), new OptimizeCssAssetsWebpackPlugin(&#123;&#125;) ]:[] &#125;&#125;) 封装log方法webpack时传递的 mode 参数，是可以在我们的应用代码运行时，通过 process.env.NODE_ENV 这个变量获取12345export default function log(...args) &#123; if (process.env.NODE_ENV == 'development') &#123; console.log.apply(console,args); &#125;&#125; 拆分配置可以把 webpack 的配置按照不同的环境拆分成多个文件，运行时直接根据环境变量加载对应的配置即可 webpack.base.js：基础部分，即多个文件中共享的配置 webpack.development.js：开发环境使用的配置 webpack.production.js：生产环境使用的配置 webpack.test.js：测试环境使用的配置… webpack-merge 12345678const &#123; smart &#125; = require('webpack-merge')const webpack = require('webpack')const base = require('./webpack.base.js')module.exports = smart(base, &#123; module: &#123; rules: [], &#125;&#125;) 多入口有时候我们的页面可以不止一个HTML页面，会有多个页面，所以就需要多入口123456789101112131415161718192021222324252627282930313233const path=require('path');const HtmlWebpackPlugin=require('html-webpack-plugin');module.exports=&#123; entry: &#123; index: './src/index.js', login: './src/login.js' &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].[hash].js', publicPath: '/' &#125;, plugins: [ new HtmlWebpackPlugin(&#123; minify: &#123; removeAttributeQuotes: true &#125;, hash: true, template: './src/index.html', chunks: ['index'], filename: 'index.html' &#125;), new HtmlWebpackPlugin(&#123; minify: &#123; removeAttributeQuotes: true &#125;, hash: true, chunks: ['login'], template: './src/login.html', filename: 'login.html' &#125;) ],&#125; 参考文档 webpack webpackdemo 理解webpack之process.env.NODE_ENV详解 webpack4之基础篇]]></content>
      <tags>
        <tag>webpack系列</tag>
        <tag>webpack实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2F2018%2F12%2F12%2F%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[跨域总结为什么会出现跨域问题出于浏览器的同源策略限制，浏览器会拒绝跨域请求。 严格的说，浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作。 通常浏览器允许进行跨域写操作（Cross-origin writes），如链接，重定向； 通常浏览器允许跨域资源嵌入（Cross-origin embedding），如 img、script 标签； 通常浏览器不允许跨域读操作（Cross-origin reads）。* cookie localStorage DOM元素也有同源策略 iframe ajax也不支持跨域 同源策略如果两个页面拥有相同的协议（protocol），端口（port）和主机（host），那么这两个页面就属于同一个源（origin）。 实现跨域的方法 jsonp只能发送GET请求,不支持post、put、delete。不安全,容易手xss攻击,不采用 利用script标签不受跨域限制而形成的一种方案。 123456789101112131415161718192021222324function jsonp(url,params,cb)&#123; const script=document.createElement("script") return new Promise((resolve,reject)=&gt;&#123; window[cb]=function(data)&#123; resolve(data) document.body.removeChild(script) &#125; params=&#123;...params,cb&#125; let str=Object.keys(params).map(item=&gt;&#123; return item=params[item] &#125;).join("&amp;") script.src=`$&#123;url&#125;?$&#123;str&#125;` document.body.appendChild(script) &#125;)&#125;jsonp(&#123;url:'http://localhost:3000/say',parms:&#123; wd:'我爱你' &#125;,cb:'show'&#125;).then((res)=&gt;&#123; console.log(res)&#125;) cors跨域资源共享标准新增了一组HTTP首部字段，允许服务器声明哪些源站有权限访问哪些资源。 两种请求 简单请求（simple request） 请求方法是以下三种方法之一： HEAD GET POST HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded multipart/form-data text/plain 非简单请求（not-so-simple request）凡是不同时满足上面两个条件，就属于非简单请求。 简单请求简单请求只需要CORS服务端在接受到携带Origin字段的跨域请求后，在response header中添加Access-Control-Allow-Origin等字段给浏览器做同源判断。 非简单请求请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json,或者人为设置一些请求头 进行非简单请求时候,浏览器会首先发出类型为OPTIONS的预检请求，请求地址相同, 服务器收到”预检“请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 如果浏览器否定了预检请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求 一旦服务器通过了”预检“请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。Access-Control-Allow-Origin字段是每次回应都必定包含的! server.js12345678910111213141516171819202122232425// 白名单let whitList=['http://localhost:3000']app.use(function(req,res,next)&#123; let origin=req.headers.origin; if(whitList.includes(origin))&#123; // 设置那个源可以访问我 res.setHeader('Access-Control-Allow-Origin',origin) //允许那个源访问我 res.setHeader('Access-Control-Allow-Headers','name,age') //允许携带那个头访问我 res.setHeader('Access-Control-Allow-Methods','PUT')//默认GET POST //允许那个方法访问我 res.setHeader('Access-Control-Max-Age',6)//options没6s发送一次 //预检的存活时间 res.setHeader('Access-Control-Allow-Credentials',true); //cookie //允许携带cookie res.setHeader('Access-Control-Expose-Headers','name,age') //后台给前台发送的头'name'是安全的，前端可以获取到 if(req.method==='OPTIONS')&#123; // 预检请求 res.end();//options请求不做任何处理 &#125; &#125; next()&#125;)app.put("/getData",function(req,res)&#123; console.log(req.headers) //请求发过来了,浏览器屏蔽了 res.setHeader('name','zh') res.end('我不爱你')&#125;)app.listen(3001) client.js123456789101112131415let xhr=new XMLHttpRequest(); // xhr.open("GET",'http://localhost:3001/getData?wd=1',true) //是否异步 document.cookie='name=zyp' //cookie不允许跨域 xhr.withCredentials=true ;//携带凭证 xhr.open("POST",'http://localhost:3001/getData',true) // xhr.setRequestHeader('name','zyp') xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded') xhr.setRequestHeader('age','1') xhr.onreadystatechange=function()&#123; if(xhr.readyState===4 &amp;&amp; xhr.status&gt;=200 &amp;&amp; xhr.status&lt;=300 || xhr.status==304)&#123; console.log(xhr.response) console.log(xhr.getResponseHeader('name')) &#125; &#125; xhr.send() iframe如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。 比如，父窗口运行下面的命令，如果iframe窗口不是同源，就会报错。12document.getElementById("myIFrame").contentWindow.document// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame. 当你的页面处于最顶层，也就是外层没有iframe包裹你，求这时window === window.parent的返回值。 document.domain如果两个窗口一级域名相同，只是二级域名不同，那么设置document.domain属性，就可以规避同源政策，拿到DOM。 A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。1document.domain = 'example.com'; 这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策。 服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com1Set-Cookie: key=value; domain=.example.com; path=/ 这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie PostMessagePostMessage是HTML5为了解决文档通信而引入了跨文档通信 API（Cross-document messaging）这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。 它可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递 1otherWindow.postMessage(message, targetOrigin, [transfer]); otherWindow:其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。 message:html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。 targetOrigin:接收消息的窗口的源（origin），即”协议 + 域名 + 端口“。也可以设为*，表示不限制域名，向所有窗口发送，URL会被忽略，所以可以不写，这个参数是为了安全考虑 transfer[可选]：是一串和message同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权 子窗口向父窗口发送消息的写法类似。1window.opener.postMessage('Nice to see you', 'http://aaa.com'); 父窗口和子窗口都可以通过message事件，监听对方的消息。123window.addEventListener('message', function(e) &#123; console.log(e.data);&#125;,false); message事件的事件对象event，提供以下三个属性 event.source：发送消息的窗口,子窗口可以通过它引用父窗口，然后发送消息 event.origin: 消息发向的网址,可以过滤不是发给本窗口的消息 event.data: 消息内容 读写其他窗口-&gt;window.open1234567891011121314151617//a.html window.onload = function () &#123; var popup = window.open('http://localhost:3001/b.html'); popup.onload = function () &#123; //必须要有onload // 假设当前页面没有改变location，这条语句会成功添加message到发送队列中去（targetOrigin设置对了） popup.postMessage("hello there!", "http://localhost:3001"); function receiveMessage(event) &#123; if (event.origin !== "http://localhost:3000") &#123; return; &#125; console.log(event.data); &#125; window.addEventListener("message", receiveMessage, false); &#125; &#125;; 12345678910111213141516171819202122//b.html document.onreadystatechange = function(e) &#123; console.log(document.readyState) if (document.readyState === 'complete') &#123; console.log('message') window.addEventListener('message', receiveMessage, false); &#125; &#125;; function receiveMessage(event) &#123; console.log('in-&gt;message') if (event.origin !== "http://localhost:3000") &#123; return; &#125; console.log('message', event.data); console.log('origin', event.source); document.write(event.data); // 假设你已经验证了所受到信息的origin (任何时候你都应该这样做), 一个很方便的方式就是把enent.source // 作为回信的对象，并且把event.origin作为targetOrigin event.source.postMessage("hi there yourself! the secret response " + "is: rheeeeet!", event.origin); &#125; 读写其他窗口-&gt;iframe1234567891011&lt;!-- a.html --&gt;&lt;iframe src="http://localhost:3001/b.html" frameborder="0" id="frame" onload="load()"&gt;&lt;/iframe&gt; &lt;script&gt; function load()&#123; let frame=document.getElementById("frame") frame.contentWindow.postMessage('我爱你','http://localhost:3001') window.onmessage=function(e)&#123; console.log(e.data) &#125; &#125; &lt;/script&gt; 12345&lt;!-- b.html --&gt;window.onmessage=function(e)&#123; console.log(e.data) e.source.postMessage('我不爱你',e.origin)&#125; window.name浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。 优点这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。 操作 a和b是同域 http://localhost:3000 c是独立的 http://localhost:3001 a获取c的数据 a先引用c,c把值放到window.name上把a引用的地址改到b 123456789101112131415&lt;!-- a.html --&gt;&lt;iframe src="http://localhost:3001/c.html" frameborder="0" onload="load()" id="iframe"&gt;&lt;/iframe&gt; &lt;script&gt; let first=true; function load()&#123; let iframe=document.getElementById("iframe") if(first)&#123; iframe.src='http://localhost:3000/b.html' first=false &#125;else&#123; console.log(iframe.contentWindow.name) &#125; &#125; &lt;/script&gt; 12&lt;!-- c.html --&gt;window.name='我爱你' hash片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新 a,b同源,c不同源 目的a想访问c a给c穿一个hash值,c收到hash值后,c把hash值传递给b, b将结果放到a的hash值中 1234567&lt;!-- a.html --&gt; &lt;iframe src="http://localhost:3001/c.html#iloveyou" frameborder="0"&gt;&lt;/iframe&gt; &lt;script&gt; window.onhashchange=function()&#123; console.log(location.hash) &#125; &lt;/script&gt; b.html1window.parent.parent.location.hash=location.hash c.html1234console.log(location.hash) let iframe=document.createElement("iframe") iframe.src='http://localhost:3000/b.html'+location.hash+'1' document.body.appendChild(iframe) websocketWebSocket对象提供了用于创建和管理 WebSocket 连接，以及可以通过该连接发送和接收数据的 API。它是基于TCP的全双工通信,即服务端和客户端可以双向进行通讯，并且允许跨域通讯。基本协议有ws://(非加密)和wss://(加密) socket.html123456789let socket = new WebSocket('ws://localhost:3000');// 给服务器发消息socket.onopen = function() &#123; socket.send('hello server')&#125;// 接收服务器回复的消息socket.onmessage = function(e) &#123; console.log(e.data)&#125; server.js1234567891011121314let express = require('express');let app = express();let WebSocket = require('ws');//npm i ws// 设置服务器域为3000端口let wss = new WebSocket.Server(&#123;port:3000&#125;);//连接wss.on('connection', function(ws)&#123; // 接收客户端传来的消息 ws.on('message', function(data)&#123; console.log(data); // 服务端回复消息 ws.send('hello client') &#125;)&#125;) NginxNginx (engine x) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。 案例：在nginx根目录下创建json/a.json，里面随便放些内容123456789101112# 代表输入/时默认去打开root目录下的html文件夹location / &#123; root html; index index.html index.htm;&#125;# 代表输入任意.json后去打开json文件夹# location 目的地 去哪里找# ~ 忽略大小写 .匹配所有 * 0-任意字符location ~.*\.json&#123; root json; add_header &quot;Access-Control-Allow-Origin&quot; &quot;*&quot;;&#125; http-proxy-middlewareNodeJS 中间件 http-proxy-middleware 实现跨域代理，原理大致与 nginx 相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 cookieDomainRewrite 参数修改响应头中 cookie 中的域名，实现当前域的 cookie 写入，方便接口登录认证 webpack.config.js 12345678910111213module.exports=&#123;devServer: &#123; historyApiFallback: true, proxy: [&#123; context: '/login', target: 'http://www.proxy2.com:8080', // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些 https 服务报错时用 cookieDomainRewrite: 'www.domain1.com' // 可以为 false，表示不修改 &#125;], noInfo: true &#125;&#125; node.js 1234567891011121314151617181920212223var express = require("express");var proxy = require("http-proxy-middleware");var app = express();app.use( "/", proxy(&#123; // 代理跨域目标接口 target: "http://www.proxy2.com:8080", changeOrigin: true, // 修改响应头信息，实现跨域并允许带 cookie onProxyRes: function(proxyRes, req, res) &#123; res.header("Access-Control-Allow-Origin", "http://www.proxy1.com"); res.header("Access-Control-Allow-Credentials", "true"); &#125;, // 修改响应信息中的 cookie 域名 cookieDomainRewrite: "www.proxy1.com" // 可以为 false，表示不修改 &#125;));app.listen(3000); server.js 1234567891011121314151617var http = require("http");var server = http.createServer();var qs = require("querystring");server.on("request", function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写 cookie res.writeHead(200, &#123; "Set-Cookie": "l=a123456;Path=/;Domain=www.proxy2.com;HttpOnly" // HttpOnly：脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen("8080"); 参考 window.open之postMessage传参数 跨域总结]]></content>
      <tags>
        <tag>跨域</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cypress]]></title>
    <url>%2F2018%2F12%2F06%2Fcypress%2F</url>
    <content type="text"><![CDATA[e2e 简介e2e 测试端对端测试的简称, e2e 即为end to end。 我不管你逻辑使用什么框架什么逻辑写的，我只想知道浏览器上我要的交互效果，ui展示效果是不是正确的，功能使用上是不是正确的，那么这就叫E2E测试。 e2e的测试对于业务的收益点在哪里呢我觉得这个要看项目类型，如果是生命周期比较短的展示型项目，写 e2e 的意义不是特别大，但如果是长期维护迭代的大型系统，e2e 测试不仅很有必要而且是必需。 目前E2E测试工具有哪些？现在有一些测试框架可供选择，CasperJS、Nightwatch 等等。CasperJS只能是无界面浏览器测试，不列入考虑。在 TestCafe 和 Cypress 中犹豫过，TestCafe 支持常见浏览器，支持 ES6/ES7 和 TS，安装也方便。 最终选择了Cypress，主要是觉得开箱即用，文档比较清晰美观，语法用起来比较舒服，最重要的一点是测试跑在 Chrome 的标签页里，和平时开发没什么区别。这种情况下其实很适合开发时模拟各种场景，比如新增一个接口，约定好了接口定义但是接口还没好，就可以利用 Cypress 来模拟请求开发了。一定程度上也可以实现 mock 的功能。同样，测试 fail 了也可以直接调试。 项目 Web Star puppeteer Chromium (~170Mb Mac, ~282Mb Linux, ~280Mb Win) 31906 nightmare Electron 15502 nightwatch WebDriver 8135 protractor selenium 7532 casperjs PhantomJS 7180 cypress Electron 5303 Zombie 不需要 4880 testcafe 不需要 4645 CodeceptJS webdriverio 1665 端到端测试一般都需要一个Web容器，来运行前端应用。例如Chromium, Electron, PhantomJS, WebDriver等等。 从体积角度考虑，这些Web容器体积一般都很大。 从速度的角度考虑：PhantomJS, WebDriver &lt; Electon, Chromium。 而且每个工具的侧重点也不同，建议按照需要去选择。 优秀的端到端测试工具应该有哪些特点 安装简易：我希望它非常容易安装，最好可以一行命令就可以安装完毕 依赖较少：我只想做个E2E测试，不想安装jdk, python之类的东西 速度很快：运行测试用例的速度要快 报错详细：详细的报错 API完备：鼠标键盘操作接口，DOM查询接口等 Debug方便：出错了可以很方便的调试，而不是去猜 为什么要用Cypress？Cypress基本上拥有了上面的特点之外，还有以下特点 时光穿梭: 测试运行时，Cypress会自动截图，你可以轻易的查看每个时间的截图 Debug友好: 不需要再去猜测为什么测试有失败了，Cypress提供Chrome DevTools, 所以Debug是非常方便的。 实时刷新: Cypress检测测试用例改变后，会自动刷新 自动等待: 不需要在使用wait类似的方法等待某个DOM出现，Cypress会自动帮你做这些 Spies, stubs, and clocks: 验证和控制函数、服务器响应或计时器的行为。从单元测试中得到的相同功能正好在你的指尖上。 网络流量控制: 在不涉及服务器的情况下轻松控制，存根和测试边缘案例。无论你喜欢，你都可以存储网络流量。 一致的结果: 我们的架构不使用Selenium或WebDriver。向快速，一致和可靠的无剥落测试问好。 截图和视频: 查看失败时自动截取的截图，或无条件运行时整个测试套件的视频。 Cypresscypress 是目前 e2e 很火的一个测试组件，内部绑定了 macha、chai、chai-jquery 之类的断言,为了让代码代码更有说服力，减少提交测试错误，进行e2e测试显然是非常有必要的。 安装1$ npm i -D cypress 然后为了方便起见，咱们在package.json中写入下面脚本,配置GUI和非GUI(terminal)两种方式来运行cypress:123456&#123; "scripts": &#123; "e2e-gui": "cypress open", "e2e": "cypress run" &#125;&#125; 配置好后 先运行yarn run e2e或者 npm run e2e[-gui](中括号意思是可选)来初始化cypress，生成默认配置和目录。 fixtures 文件夹存放自定义 json 文件， integration 文件夹编写测试， plugins 和support 是非必须使用的文件夹，需要自定义指令的时候会用到。 详细目录 cypress.json(与package.json同级目录): cypress提供比较灵活的配置，可以根据自己需要定制行为，以下列一下我对一个项目的配置 123456789&#123; "baseUrl": "http://localhost:8080", // 基础链接，之后在是使用 cy.visit 的时候，只需要访问具体路由例如: cy.visit('/Hello')（webpack-dev-server) "integrationFolder": "src", // 自定义"src"为测试文件根目录，默认是"cypress/integration" "testFiles": "**/*.cypress.spec.js", // 自定义测试文件的匹配正则，默认是"**/*.*",即所有文件 "videoRecording": false, // 关闭录屏功能, 如果开启录屏功能，记得将"cypress/screenshots"目录加入".gitignore",防止不小心将录屏加到git中 "viewportHeight": 800, // 设置测试环境的页面视图的高度 "viewportWidth": 1600, // 设置测试环境的页面视图的宽度 "pageLoadTimeout": 3000,//页面家安在超过 3000ms 即为超时。&#125; cypress/plugins/index.js: cypress运行环境配置，可以用来配置webpack等。以下是配置webpack别名范例。默认这里不需要配置。 123456789101112131415161718192021// 参考官方例子地址 https://github.com/cypress-io/cypress-example-recipes/blob/master/examples/preprocessors__typescript-webpack/cypress/plugins/index.jsconst wp = require("@cypress/webpack-preprocessor");const path = require('path');function resolve(dir) &#123; return path.join(__dirname, "../..", dir);&#125;module.exports = on =&gt; &#123; const options = &#123; webpackOptions: &#123; resolve: &#123; alias: &#123; "@": resolve("src"), cypress: resolve("cypress") &#125; &#125; &#125; &#125;; on("file:preprocessor", wp(options));&#125;; 根据喜好选择某种风格编写测试Cypress 对 chai、Expect.js 风格的都支持，还拓展了一些断言， cy.visit这是 cypress 里面一个很重要的方法，可以访问一个链接,列入 example.js 文件如下:12345beforeEach(function() &#123; // Visiting our app before each test removes any state build up from // previous tests. Visiting acts as if we closed a tab and opened a fresh one cy.visit('https://example.cypress.io/commands/querying')&#125;) 这里就是在前置钩子函数里面访问了https://...../querying这个链接。如果代码需要浏览器调试，比如用户交互点击，用户输入之类的。第一步就是访问：cy.visit cy.get还是从 example_spec.js 问中说起：12345678910111213it('cy.get() - query DOM elements', function() &#123; // https://on.cypress.io/get // Get DOM elements by id cy.get('#query-btn').should('contain', 'Button') // Get DOM elements by class cy.get('.query-btn').should('contain', 'Button') cy.get('#querying .well&gt;button:first').should('contain', 'Button') // ↲ // Use CSS selectors just like jQuery&#125;) 这里定义了一个测试单元，在这个里面做了啥呢？第一步获取 id 为 query-btn 这个按钮。接下来 should 操作，奉上一张表自行查看: 从官网截图的表格，详细jquery-chai 文档表格 所以可以将 cy.get()当$一样来用即可，不过这里返回的不过 jquery 对象罢了，这里返回的事通过 cypress 包装过的对象可以在控制台看到这样的东西,见下图: 是一个用于 cypress 所有方法的对象。然后可以操作他的 api 了。 cy.get相似 cy.contains 通过文本获取元素 cy.closet 见 jqery cy.next/cy.nextAll 可以和 cy.contains 联合使用获取该节点的下一个节点 cy.prev/cy.prevAll 同上 cy.children/cy.parents/cy.parent 获取子节点/ 所有的父节点 / 父节点 cy.first/cy.last cy.url 获取当前页面 url cy.title 获取当前页面标题 … API 重名名cy.get还有一个玩法就是 cy.get(‘@app’)这种，意思说之前你已经cy.get(&#39;.app&#39;).as(&#39;app&#39;),不需要再次获取了，直接使用别名就好了 cypress 交互逻辑cy.type这不是一个可以直接使用的方法，要配合cy.get使用的,作用是给空间进行输入。例如: 测试输入例如 text, textarea 1cy.get('input').type('hello world') 测试tabIndex 1234 &lt;div class="el" tabIndex="1"&gt; This is TabIndex div. &lt;/div&gt;cy.get('.el').type('laldkadaljdkljasf') // 这个里面是随机字符串 测试 input 为日期的 1cy.get('input[type=date]').type('2008-8-9') 键盘绑定 12cy.get('input').type('&#123;shift&#125;&#123;alt&#125;Q')cy.get('input').type('&#123;alt&#125;这里是按了一下alt后输入的内容') 对于选择例如 radio, checkbox 12345cy .get('input[type=radio]') .as('radio') .click()cy.get('@radio').should('be.checked') 定时cy.wait下面是等待 1s1cy.wait(1000) cy.clock 和 cy.tick页面代码1234var seconds = 0setInterval(() =&gt; &#123; $('#seconds-elapsed').text(++seconds + ' seconds')&#125;, 1000) 测试代码123456cy.clock()cy.visit('/index.html')cy.tick(1000)cy.get('#seconds-elapsed').should('have.text', '1 seconds')cy.tick(1000)cy.get('#seconds-elapsed').should('have.text', '2 seconds') 迷惑的可以参考:地址 常用apiHooks1234567891011121314describe('Hooks', function() &#123; before(function() &#123; // runs once before all tests in the block &#125;) after(function() &#123; // runs once after all tests in the block &#125;) beforeEach(function() &#123; // runs before each test in the block &#125;) afterEach(function() &#123; // runs after each test in the block &#125;)&#125;) cy.viewport()可以方便的修改视窗，就像使用 Chrome 模拟不同设备窗口一样。比如设置了 cy.viewport(&#39;iphone-6&#39;) 就会以 iphone6 的大小跑测试。 Environment Variables类似于全局变量，在根目录下的 cypress.json 中123456&#123; "env": &#123; "foo": "bar", "some": "value" &#125;&#125; 便可以在测试文件中通过 Cypress.env(&#39;foo&#39;) 来访问。 注意 后端修改接口时，可能需要修改测试中的接口返回，否则可能会不匹配实际情况。 Cypress 对多浏览器测试支持并不友好，不能做到像 browserstack 那样测试各个浏览器兼容性。这方面可以看一下 这篇文章。接下来我们也可能使用阿里云移动测试来测试兼容性。 Cypress 对 fetch 的兼容不好，处理方法详见 issue95。 关于测试覆盖率目前cypress没有内置测试覆盖率统计功能，github上有专门的issue在跟踪这个，后续应该会有。issue上也有几个临时方案，目前我倾向使用chrome自带的来查看。在GUI打开的测试的浏览器中打开devtools,切到Sources, 按下cmd+shift+p(windows用户按ctrl+shift+p)，输入coverage，选择重新刷新并统计代码执行覆盖率。 网络请求mock例子 cy.route的路径匹配是严格的，所以要注意是否需要加通配符。如 cy.route(&#39;/api/search&#39;, [])不会拦截/api/search?keyword=abc，只会拦截/api/search。 cy.route的method要注意，默认是GET，cy.route(&#39;/api/posts&#39;) 和 cy.route(&#39;POST&#39;, &#39;/api/posts&#39;) 是不一样的。 1234567891011121314151617describe('要啥给啥', () =&gt; &#123; beforeEach(() =&gt; &#123; cy.server(); // 一定要在 cy.route 前调用 cy .fixture('/posts/list.json') // 我们在 cypress/fixtures 内创建mock用的数据 .as('postsData'); // 给 mock 数据取别名，以后 cy.route 使用 cy .route('/api/posts', '@postsData') .as('getPostsRoute'); // 给请求取别名，以供 cy.wait 使用 &#125;) it('进入列表页，拦截列表请求接口', () =&gt; &#123; cy.wait('@getPostsRoute'); // 等待被拦截的接口请求完成 cy.get('.post').should('have.length', 10); // 要有10条数据被渲染到页面上 &#125;);&#125;) 实际场景例子: 结合上面所有姿势，我们现在测试搜索页面的搜索、操作结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869describe('test search page', () =&gt; &#123; // 几个 route 路径变量 const searchRoutePath = '/api/items/activities?query=*'; const deleteActivityRoutePath = '/api/activities/*/items/batch?num_iids[]=*'; const undoActivityRoutePath = '/api/activities/*/items/undo'; function search(keyword) &#123; // 将搜索行为和等待搜索返回封装起来 cy .fixture('items/activities.json') // 处理mock数据，只返回符合搜索结构的数据 .then(data =&gt; data.filter(item =&gt; item.title.indexOf(keyword) !== -1)) .as('searchResult'); cy.server(); cy.route(searchRoutePath, '@searchResult').as('searchRoute'); const input = cy.get('input'); input.clear(); // 清空输入框内文本 input.type(`$&#123;keyword&#125;&#123;enter&#125;`); cy.wait('@searchRoute'); &#125; before(() =&gt; &#123; // 进行所有测试前，先访问搜索页 cy.visit('/activities/search'); &#125;); it('should show no data tip when search result is empty', () =&gt; &#123; const text = 'not exist'; search(text); cy.contains(`没有找到关于 $&#123;text&#125; 的结果`); &#125;); it('should remove activity from list when clean successful', () =&gt; &#123; search('成功'); cy .route('delete', deleteActivityRoutePath, &#123; success: 0, fail: 0, waiting: 0, &#125;) .as('deleteActivityResponse'); // within是让cy执行的context保持在'.activities-search'这个dom节点内 // 默认cy的执行是以上一个cy命令结果作为context // 如 "cy.get('a'); cy.get('span')"，cy会在上一个命令找到的'a'标签中查找'span' cy.get('.activities-search').within(() =&gt; &#123; const items = cy.get('.result-item'); items.should('have.length', 1); const applyList = items.get('.apply-list'); applyList.should('not.be.visible'); // 每个数据项内详细内容区域是隐藏的 const toggleBtn = items.get('.item-apply-count'); toggleBtn.click(); // 点击显示详细内容区 applyList.should('be.visible'); applyList.children().should('have.length', 1); // 详细内容区内数据只有1条 const cleanBtn = cy.contains('退出'); cleanBtn.click(); // 点击详细内容区里的“退出”按钮 cy.wait('@deleteActivityResponse'); // 等待“退出”请求返回 cy.get('.apply-list').should('be', null); // 退出成功后，详细内容区数据减1，即空 &#125;); &#125;);&#125;); cy.request 请求数据，类似ajax network-requests assertions recipes code completion 总结Cypress写测试的基本思路 确定是否需要拦截请求，用 cy.route 修改请求，按照设计好的测试用例设定 response。 用 cy.visit 访问需要测试的页面。 根据实际情况，一般校验元素可见性、是否是禁用状态、数量、文案是否正确等等。 运行测试，在控制面板查看测试结果。 参考 前端E2E测试框架 cypress了解一下 撩测试MM神器cypress使用入门 端到端测试哪家强？不容错过的Cypress cypress进行e2e测试之理论 E2E 测试之 Cypress cypress 官网]]></content>
      <tags>
        <tag>test</tag>
        <tag>e2e</tag>
        <tag>cypress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[enzyme]]></title>
    <url>%2F2018%2F12%2F04%2Fenzyme%2F</url>
    <content type="text"><![CDATA[react的单元测试之EnzymeReact官方已经提供了一个测试工具库：react-dom/test-utils只是用起来不够方便，于是有了一些第三方的封装库，比如Airbnb公司的Enzyme 测试项目的配置1npm install --save-dev enzyme 而enzyme还需要根据React的版本安装适配器，适配器对应表如下：|Enzyme Adapter Package| React semver compatibility||—-|—-||enzyme-adapter-react-16| ^16.0.0||enzyme-adapter-react-15| ^15.5.0||enzyme-adapter-react-15.4| 15.0.0-0 - 15.4.x||enzyme-adapter-react-14 |^0.14.0||enzyme-adapter-react-13 |^0.13.0| 那么因为我们安装的React版本为^16.2.0所以需要安装：1npm install --save-dev enzyme-adapter-react-16 Enzyme与Jest配合使用现在开始用Enzyme为example.jsx编写测试代码：1234567891011121314151617import &#123;assert&#125; from 'chai'import React from 'react'import Enzyme from 'enzyme'import Adapter from 'enzyme-adapter-react-16'import Example from '../src/example'const &#123;shallow&#125;=EnzymeEnzyme.configure(&#123; adapter: new Adapter() &#125;)describe('Enzyme的浅渲染测试套件', function () &#123; it('Example组件中按钮的名字为text的值', function () &#123; const name='按钮名' let app = shallow(&lt;Example text=&#123;name&#125; /&gt;) assert.equal(app.find('button').text(),name) &#125;)&#125;) 如上面代码所示，在使用Enzyme 前需要先适配React对应的版本1nzyme.configure(&#123; adapter: new Adapter() &#125;) 要使用Jest运行安装文件以 适配Enzyme Adapte，请在配置文件中将setupTestFrameworkScriptFile设置为字符串和设置文件的路径。12345&#123; "jest": &#123; "setupTestFrameworkScriptFile": "&lt;rootDir&gt;src/setupTests.js" &#125;&#125; JEST15以后你可以通过安装babel和相关的babel插件就可以了可以参考 Enzyme 的使用之浅渲染shallowShallow Rendering（浅渲染）指的是，将一个组件渲染成虚拟DOM对象，但是只渲染第一层，不渲染所有子组件，所以处理速度非常快。它不需要DOM环境，因为根本没有加载进DOM。 shallow的函数输入组件，返回组件的浅渲染结果，而返回的结果可以用类似jquery的形式获取组件的信息。12345678import &#123;shallow&#125; from 'enzyme';describe('Enzyme Shallow', function () &#123; it('App\'s title should be Todos', function () &#123; let app = shallow(&lt;App/&gt;); expect(app.find('h1').text()).to.equal('Todos'); &#125;);&#125;; 上面代码中，shallow方法返回App的浅渲染，然后app.find方法找出h1元素，text方法取出该元素的文本。 关于find方法，有一个注意点，就是它只支持简单选择器，稍微复杂的一点的CSS选择器都不支持。1234567component.find('.my-class'); // by class namecomponent.find('#my-id'); // by idcomponent.find('td'); // by tagcomponent.find('div.custom-class'); // by compound selectorcomponent.find(TableRow); // by constructorcomponent.find('TableRow'); // by display name Enzyme 的使用之mountmount方法用于将React组件加载为真实DOM节点。 然而真实DOM需要一个浏览器环境，为了解决这个问题，我们可以用到jsdom. 也就是说我们可以用jsdom模拟一个浏览器环境去加载真实的DOM节点。 首先安装jsdom：1npm install --save-dev jsdom 12345678910import &#123;mount&#125; from 'enzyme';describe('Enzyme Mount', function () &#123; it('Delete Todo', function () &#123; let app = mount(&lt;App/&gt;); let todoLength = app.find('li').length; app.find('button.delete').at(0).simulate('click'); expect(app.find('li').length).to.equal(todoLength - 1); &#125;);&#125;); Enzyme 的使用之render而Enzyme还提供了一个不需要jsdom模拟环境解决子组件测试的方法：render。 意思就是说render方法将React组件渲染成静态的HTML字符串，然后分析这段HTML代码的结构，返回一个对象。它跟shallow方法非常像，主要的不同是采用了第三方HTML解析库Cheerio，它返回的是一个Cheerio实例对象。123456789import &#123;render&#125; from 'enzyme';describe('Enzyme Render', function () &#123; it('Todo item should not have todo-done class', function () &#123; let app = render(&lt;App/&gt;); expect(app.find('.todo-done').length).to.equal(0); &#125;);&#125;); 在上面代码中，你可以看到，render方法与shallow方法的API基本是一致的。 Enzyme的设计就是，让不同的底层处理引擎，都具有同样的API（比如find方法）。 shallow ,render和mount的效率对比 shallow果然最快，这是肯定的，但是因为shallow的局限性，我们可能更想知道render和mount的效率。 事实证明，render的效率是mount的两倍。 mount存在的价值是什么，render就可以测试子组件，render还不需要jsdom和额外的配置。 当然是有价值的，shallow和mount因为都是dom对象的缘故，所以都是可以模拟交互的，比如12const nav = mount(&lt;Nav /&gt;) nav.find('a').simulate('click') 而render是不能的。 小结简而言之，Enzyme主要包括三个测试： 一个是浅渲染的shallow，这个生成虚DOM对象，所以渲染最快，然而它并不能测试子组件的相关代码。 另一个是DOM渲染mount，它会生成完整的DOM节点，所以可以测试子组件。但是要依赖一个用jsdom模拟的浏览器环境。 最后一个是HTML文本渲染render，它会将react组件渲染为html文本，然后在内部通过Cheerio自动生成一个Cheerio对象。 渲染方法 是否可以测试子组件 是否可以模拟交互 性能（测试500次） shallow 否 是 116ms mount 是 是 421ms render 是 否 984ms api下面是Enzyme的一部分API，你可以从中了解它的大概用法。 .get(index)：返回指定位置的子组件的DOM节点 .at(index)：返回指定位置的子组件 .first()：返回第一个子组件 .last()：返回最后一个子组件 .type()：返回当前组件的类型 .text()：返回当前组件的文本内容 .html()：返回当前组件的HTML代码形式 .props()：返回根组件的所有属性 .prop(key)：返回根组件的指定属性 .state([key])：返回根组件的状态 .setState(nextState)：设置根组件的状态 .setProps(nextProps)：设置根组件的属性 参考 react的单元测试之Enzyme Enzyme React 测试入门教程 React应用下的单元测试 jest + enzyme]]></content>
      <tags>
        <tag>enzyme</tag>
        <tag>jest</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jest]]></title>
    <url>%2F2018%2F12%2F04%2FJest%2F</url>
    <content type="text"><![CDATA[Jestjest是由Facebook发布的开源的、基于Jasmine的JavaScript单元测试框架，可以测试 javascipt 和 react。 集成了的Mocha和chai，jsdom，sinon等功能。 为什么选择Jest？ Jest 可以利用其特有的快照测试功能，通过比对 UI 代码生成的快照文件，实现对 React 等常见框架的自动测试。此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度 安装配置简单，非常容易上手，几乎是零配置的，通过npm 命令安装就可以直接运行了 Jest 内置了测试覆盖率工具istanbul，可以通过命令开启或者在 package.json 文件进行更详细的配置。运行 istanbul 除了会再终端展示测试覆盖率情况，还会在项目下生产一个 coverage 目录，内附一个测试覆盖率的报告，让我们可以清晰看到分支的代码的测试情况。 集成了断言库，不需要再引入第三方的断言库，并且非常完美的支持React组件化测试。 安装12cnpm i jest --save-dev cnpm i jest -g 运行命令jest后会自动运行项目下所有.test.js和.spec.js这种格式的文件。 涉及到运用ES或react的，要与babel相结合，加上.babelrc文件即可，老玩法了。 jest的配置默认只需要在package.json中配置即可，当然也可以用独立的配置文件。 我们这里直接将jest的运行范围限定在test文件夹下，而不是全部，所以在package.json中加入如下配置：123"jest": &#123; "testRegex": "/test/.*.test.jsx?$"&#125; 运行12jest npm jest npm test 配置配置位置 package.json jest.config.js 命令行配置项 testMatch glob规则,识别哪些文件中测试文件 testRegex 文件正则 testEnvironment 测试环境 rootDir 根目录 moduleFileExtensions 模块文件扩展名1234567891011121314151617181920212223242526272829303132module.exports = &#123; //设置识别哪些文件是测试文件（glob形式），与testRegex互斥，不能同时写 testMatch: ['**/__tests__/**/*.js?(x)', '**/?(*.)(spec|test).js?(x)'], //设置识别哪些文件是测试文件（正则形式），与testMatch互斥，不能同时写 testRegex: '(/__tests__).*|(\\.|/)(test|spec))\\.jsx?$', //测试环境，默认值是：jsdom，可修改为node testEnvironment: 'jsdom', //默认值：当前目录，一般是package.json所在的目录。 rootDir: '', //测试文件的类型 moduleFileExtensions: ['js', 'json', 'jsx', 'node'], // 运行测试前可执行的脚本（比如注册enzyme的兼容） setupFiles: ['&lt;rootDir&gt;/jest.setup.js'], // 运行环境下的URl testURL: 'http://localhost/', //转换时需忽略的文件 testPathIgnorePatterns: ['&lt;rootDir&gt;/.next/', '&lt;rootDir&gt;/node_modules/'], // 如果moduleNameMapper不能满足您的需求，那么可以使用Jest的transform配置选项来指定如何转换资产 transform: &#123; '^.+\\.(js|jsx|mjs)$': '&lt;rootDir&gt;/node_modules/babel-jest', '^.+\\.css$': '&lt;rootDir&gt;/__test__/css-transform.js', &#125;, // 是否收集测试时的覆盖率信息（默认是false,同package配置的--coverage参数） collectCoverage: true, // 哪些文件需要收集覆盖率信息 collectCoverageFrom: ['&lt;rootDir&gt;/src/**/*.&#123;js,jsx,mjs&#125;'], // 输出覆盖信息文件的目录 coverageDirectory: '&lt;rootDir&gt;/test/coverage', // 统计覆盖信息时需要忽略的文件 coveragePathIgnorePatterns: ['/node_modules/', '&lt;rootDir&gt;/src/index.jsx'], moduleNameMapper: &#123; // 需要mock处理掉的文件，比如样式文件 &#125;,&#125; 关于transfrom的配置可以参考 jest.setup.js12345/* eslint-disable import/no-extraneous-dependencies */import &#123; configure &#125; from 'enzyme';import Adapter from 'enzyme-adapter-react-16';configure(&#123; adapter: new Adapter() &#125;); 基本用法和之前介绍的mocha和chai的功能很像，甚至可以兼容部分mocha和chai的语法。可以这么写123456789101112131415161718192021222324import React from 'react'import &#123; shallow &#125; from 'enzyme'import CommentItem from './commentItem'describe('测试评论列表项组件', () =&gt; &#123; // 这是mocha的玩法，jest可以直接兼容 it('测试评论内容小于等于200时不出现展开收起按钮', () =&gt; &#123; const propsData = &#123; date: '2018-03-04 10:10:11', name: '匿名人', content: '测试标题测试标题测试标题测试标题测试标题测试标题测试标题测试标题测试标题测试标题测试标题测试标题' &#125; const item = shallow(&lt;CommentItem &#123;...propsData&#125; /&gt;) //看到这里的断言了吗，实际上和chai的expect是很像的 expect(item.find('.btn-expand').length).toBe(0); &#125;) // 这是jest的玩法，推荐用这种 test('两数相加结果为两个数字的和', () =&gt; &#123; expect(3).toBe(3); &#125;);&#125; jest的mock两种方式的Mock Function，一种是利用Jest提供的Mock Function创建，另外一种是手动创建来覆写本身的依赖实现 Mocks可以擦除函数的实际实现来测试代码之间的链接 Mocks可以捕获对函数的调用( 以及在这些调用中传递的参数) manual_mocks用可mock依赖的模块，放置在相应mocks目录下 使用mock function可以查看函数的调用次数，以及参数 官网的例子-&gt;测试函数 forEach 的内部实现12345function forEach(items, callback) &#123; for (let index = 0; index &lt; items.length; index++) &#123; callback(items[index]); &#125;&#125; 为了测试此函数，我们可以使用一个 mock 函数，然后检查 mock 函数的状态来确保回调函数如期调用。1234567891011const mockCallback = jest.fn();forEach([0, 1], mockCallback);// 此模拟函数被调用了两次expect(mockCallback.mock.calls.length).toBe(2);// 第一次调用函数时的第一个参数是 0expect(mockCallback.mock.calls[0][0]).toBe(0);// 第二次调用函数时的第一个参数是 1expect(mockCallback.mock.calls[1][0]).toBe(1); 几乎所有的Mock Function都带有.mock的属性，它保存了此函数被调用的信息。 .mock属性还追踪每次调用时 this的值，所以也让检视this 的值成为可能：12345678const myMock = jest.fn();const a = new myMock();const b = &#123;&#125;;const bound = myMock.bind(b);bound();console.log(myMock.mock.instances); 在测试中，需要对函数如何被调用，或者实例化做断言时，这些 mock 成员变量很有帮助意义︰1234567891011121314// 这个函数只调用一次expect(someMockFunction.mock.calls.length).toBe(1);// 这个函数被第一次调用时的第一个 arg 是 'first arg'expect(someMockFunction.mock.calls[0][0]).toBe('first arg');// 这个函数被第一次调用时的第二个 arg 是 'second arg'expect(someMockFunction.mock.calls[0][1]).toBe('second arg');// 这个函数被实例化两次expect(someMockFunction.mock.instances.length).toBe(2);// 这个函数被第一次实例化返回的对象中，有一个 name 属性，且被设置为了 'test’ expect(someMockFunction.mock.instances[0].name).toEqual('test'); Mock返回值12345678910const myMock = jest.fn();console.log(myMock());// &gt; undefinedmyMock .mockReturnValueOnce(10) .mockReturnValueOnce('x') .mockReturnValue(true);console.log(myMock(), myMock(), myMock(), myMock());//10 'x' true true Mock内部实现使用jest.fn或者mockImplementationOnce 可以完全替换需要mock的函数。如下面的例子：123const myMock=jest.fn(cb=&gt;cb(null,true))myMock((err,val)=&gt;console.log(val)) //truemyMock((err,val)=&gt;console.log(val)) //true 当需要mock的函数是从其他模块创建的就可以使用mockImplementation12345678910// foo.jsmodule.exports=&#123; // some code&#125;// test.jsjest.mock("../foo")const foo=require("../foo");foo.mockImplementation(()=&gt;42)foo();//42 Mock名字可以使用mockName 来给mock函数命名，如果没有命名，输出的日志默认就会打印jest.fn()，加上名字更有利于调试12const mymockFn=jest.fn()mymockFn.mockReturnValue("default").mockName("add") 模块的mock 使用jest.mock自动mock 1jest.mock("./className") jest.mock()直接在单元测试里面mock 模块 1234// 例如我们很多产品代码里面会使用fs文件读取文件, 在单元测试中, 我们并不需要真去调用fs读取文件, 就可以考虑把fs模块mock掉, 如下代码： jest.mock('fs',()=&gt;&#123; readFileSync:jest.fn()&#125;) 在需要mock的模块目录临近建立目录mocks 对于用户目录下面的模块 1234// 例如我们需要mock目录models下面的user模块，那么我们就需要在models下面新建mocks目录（这里要区分大小写），然后新建文件user.js。// 注意：用这种方式， 需要在单元测试文件中需添加下面的代码才能使此mock生效。 jest.mock("./mockName") 对于node_modules下面的模块 如果我们需要mock的模块是一个Node的模块（如lodash），那么 mocks应该是挨着node_modules目录（除非你手动配置的 roots指向非本项目的root目录），这种就会自动mock了，也就是不需要在单元测试用例里再调用jest.mock(‘module_name’)。 如果需要mock的模块是scoped模块，那么我们创建的mock的名字需要一致，例如， mock模块名字为 @scope/project-name，那么就需要创建mocks/@scope/project-name.js。 注意：如果我们需要mock node的核心模块（如fs或者path），那么还是需要显示的调用jest.mock(‘path’) ， 因为核心的node模块默然是不被mock的。 mock文件和css module的问题如果js文件中引用了css或者本地其他文件，那么就可能测试失败。为了解决这个问题，同时也为了提高测试效率，：12345"jest": &#123; "moduleNameMapper": &#123; "\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$": "&lt;rootDir&gt;/test/config/fileMock.js", "\\.(css|less)$": "identity-obj-proxy" &#125; 而fileMock.js文件内容为：1module.exports = 'test-file-stub'; 然后安装identity-obj-proxy即可：1npm install --save-dev identity-obj-proxy jest与webpack这里不多讲了，可以参考 jest与别名在webpack中经常会用到别名，而jest测试时，如果文件中引用了别名会出现找不到文件的问题。毕竟jest测试时没有经过webpack处理对于以下玩法12345resolve: &#123; alias: &#123; common: path.resolve(__dirname, 'plugins/common/') &#125; &#125; 可以通过123456"jest": &#123; "testRegex": "./src/test/.*.test.js$", "moduleNameMapper": &#123; "^common(.*)$": "&lt;rootDir&gt;/plugins/common$1", &#125;&#125; jest与eslint检测如果看了上面的代码会发现我没有引用任何类似于1import * from 'jest' 的代码，而那个expect是没有定义的。这段代码直接运行jest命令没有任何问题，但是eslint会检测出错，对于这种情况，我们可以再eslint配置文件.eslintrc中加入以下代码：123"env": &#123; "jest": true &#125;, jest的断言jest有自己的断言玩法。 相等断言 toBe(value)： 比较数字、字符串 toEqual(value)： 比较对象、数组 toBeNull() toBeUndefined() 包含断言 toHaveProperty(keyPath, value)： 是否有对应的属性 toContain(item)： 是否包含对应的值，括号里写上数组、字符串 toMatch(regexpOrString)： 括号里写上正则 逻辑断言,在JavaScript中，有六个falsy值：false，0，’’，null， undefined，和NaN。其他一切都是Truthy。 toBeTruthy() toBeFalsy() oBeGreaterThan(number)： 大于 toBeLessThan(number)： 小于 not 取反12345678function compileAndroidCode() &#123; throw new ConfigError('you are using the wrong JDK');&#125;test('compiling android goes as expected', () =&gt; &#123; expect(compileAndroidCode).toThrow(); expect(compileAndroidCode).toThrow(ConfigError);//判断抛出异常&#125;） DOM测试 Jest 集成了jsdom Jest能操作DOM是因为内置了JSDOM JSDOM是在node中模拟了DOM环境 12345678function remove(node) &#123; node.parentNode.removeChild(node);&#125;function on(node, type, handler) &#123; node.addEventListener(type, handler);&#125;exports.remove = remove;exports.on = on; 123456789101112131415161718192021222324let &#123; remove, on &#125; = require('../src/dom');describe('dom', () =&gt; &#123; test('remove', () =&gt; &#123; document.body.innerHTML = '&lt;div id="container"&gt;&lt;span id="hello"&gt;hello&lt;/span&gt;&lt;/div&gt;'; let container = document.getElementById('container'); expect(container.nodeName.toLocaleLowerCase()).toBe('div'); let hello = document.getElementById('hello'); expect(hello.nodeName.toLocaleLowerCase()).toBe('span'); remove(hello); let hello2 = document.getElementById('hello'); expect(hello2).toBeNull(); &#125;) test('on', () =&gt; &#123; document.body.innerHTML = '&lt;div id="container"&gt;&lt;button id="clickMe"&gt;click&lt;/button&gt;&lt;/div&gt;'; let clickMe = document.getElementById('clickMe'); on(clickMe, 'click', () =&gt; &#123; clickMe.innerHTML = 'clicked'; &#125;); clickMe.click(); expect(clickMe.innerHTML).toBe('clicked'); &#125;)&#125;); 代码覆盖率 line coverage 行覆盖率 function coverage 函数覆盖率 branch coverage 分支覆盖率 statement coverage 语句覆盖率1npx jest --coverage 测试的生命周期Jest 测试提供了一些测试的生命周期 API，可以辅助我们在每个 case 的开始和结束做一些处理。 这样，在进行一些和数据相关的测试时，可以在测试前准备一些数据，在测试后，清理测试数据。 4 个主要的生命周期函数： 默认情况下，before 和 after 的块可以应用到文件中的每个测试。 此外可以通过 describe 块来将测试分组。 当 before 和after 的块在describe 块内部时，则其只适用于该 describe 块内的测试。 afterAll(fn, timeout): 当前文件中的所有测试执行完成后执行 fn, 如果 fn 是 promise，jest 会等待 timeout 毫秒，默认 5000 afterEach(fn, timeout): 每个 test 执行完后执行 fn，timeout 含义同上 beforeAll(fn, timeout): 同 afterAll，不同之处在于在所有测试开始前执行 beforeEach(fn, timeout): 同 afterEach，不同之处在于在每个测试开始前执行 123456789101112131415161718192021222324beforeAll(() =&gt; console.log('1 - beforeAll'));afterAll(() =&gt; console.log('1 - afterAll'));beforeEach(() =&gt; console.log('1 - beforeEach'));afterEach(() =&gt; console.log('1 - afterEach'));test('', () =&gt; console.log('1 - test'));describe('Scoped / Nested block', () =&gt; &#123; beforeAll(() =&gt; console.log('2 - beforeAll')); afterAll(() =&gt; console.log('2 - afterAll')); beforeEach(() =&gt; console.log('2 - beforeEach')); afterEach(() =&gt; console.log('2 - afterEach')); test('', () =&gt; console.log('2 - test'));&#125;);// 1 - beforeAll// 1 - beforeEach// 1 - test// 1 - afterEach// 2 - beforeAll// 1 - beforeEach// 2 - beforeEach// 2 - test// 2 - afterEach// 1 - afterEach// 2 - afterAll// 1 - afterAll 1234567891011121314151617181920212223BeforeAll(() =&gt; &#123; console.log('before all tests to excute !')&#125;)BeforeEach(() =&gt; &#123; console.log('before each test !')&#125;)AfterAll(() =&gt; &#123; console.log('after all tests to excute !')&#125;)AfterEach(() =&gt; &#123; console.log('after each test !')&#125;)Test('test lifecycle 01', () =&gt; &#123; expect(1 + 2).toBe(3)&#125;)Test('test lifecycle 03', () =&gt; &#123; expect(2 + 2).toBe(4)&#125;) 快照所谓snapshot，即快照也。通常涉及UI的自动化测试，思路是把某一时刻的标准状态拍个快照，在测试回归的时候进行pixel to pixel的对比。但Jest对React组件的快照则不同，其实是把一个组件给序列化成纯文本， 纯文本的比较，这个真是简单又高效呀。对于一个React组件而言， 传入相同的props，我们是期望得到相同的输出， 这样子一来，通过构造不同的props, 我们即有了不同的测试用例。 理想状态中，组件若是无内部状态变化，测试用例覆盖率应该可以达到100%了。当然，仅仅是理想。 提高代码测试覆盖率 12345678910111213141516171819202122232425262728293031323334353637383940// Link.react.jsimport React from 'react';const STATUS = &#123; HOVERED: 'hovered', NORMAL: 'normal',&#125;;export default class Link extends React.Component &#123; constructor(props) &#123; super(props); this._onMouseEnter = this._onMouseEnter.bind(this); this._onMouseLeave = this._onMouseLeave.bind(this); this.state = &#123; class: STATUS.NORMAL, &#125;; &#125; _onMouseEnter() &#123; this.setState(&#123;class: STATUS.HOVERED&#125;); &#125; _onMouseLeave() &#123; this.setState(&#123;class: STATUS.NORMAL&#125;); &#125; render() &#123; return ( &lt;a className=&#123;this.state.class&#125; href=&#123;this.props.page || '#'&#125; onMouseEnter=&#123;this._onMouseEnter&#125; onMouseLeave=&#123;this._onMouseLeave&#125;&gt; &#123;this.props.children&#125; &lt;/a&gt; ); &#125; 1234567891011// Link.react-test.jsimport React from 'react';import Link from '../Link.react';import renderer from 'react-test-renderer';it('renders correctly', () =&gt; &#123; const tree = renderer.create( &lt;Link page="http://www.facebook.com"&gt;Facebook&lt;/Link&gt; ).toJSON(); expect(tree).toMatchSnapshot();&#125;); 第一次跑的时候，就会生成一个快照文件，在__snapshots__目录下:12345678910exports[`renders correctly 1`] = `&lt;a className="normal" href="http://www.facebook.com" onMouseEnter=&#123;[Function]&#125; onMouseLeave=&#123;[Function]&#125;&gt; Facebook&lt;/a&gt;`; 在之后的toMatchSnapshot()调用就会与之比较，如有不同，则是用例失败，会打印出具体差异： 附录globgulp内部使用了node-glob模块来实现其文件匹配功能。我们可以使用下面这些特殊的字符来匹配我们想要的文件： glob规则 匹配符 说明 星 匹配文件路径中的0个或多个字符，但不会匹配路径分隔符 ** 匹配路径中的0个或多个目录及其子目录 […] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个 !(pattern pattern pattern) 匹配任何与括号中给定的任一模式都不匹配的 ?(pattern pattern pattern) 匹配括号中给定的任一模式0次或1次，类似于js正则中的? +(pattern pattern pattern) 匹配括号中给定的任一模式至少1次，类似于js正则中的+ (pattern pattern pattern) 匹配括号中给定的任一模式0次或多次，类似于js正则中的 * @(pattern pattern pattern) 匹配括号中给定的任一模式1次，类似于js正则中的 glob示例 glob 匹配 * 能匹配 a.js,x.y,abc,abc/,但不能匹配a/b.js . a.js,style.css,a.b,x.y //*.js 能匹配 a/b/c.js,x/y/z.js,不能匹配a/b.js,a/b/c/d.js ** 能匹配 abc,a/b.js,a/b/c.js,x/y/z,x/y/z/a.b,能用来匹配所有的目录和文件 a/**/z 能匹配 a/z,a/b/z,a/b/c/z,a/d/g/h/j/k/z a/**b/z 能匹配 a/b/z,a/sb/z,但不能匹配a/x/sb/z,因为只有单**单独出现才能匹配多级目录 ?.js 能匹配 a.js,b.js,c.js a?? 能匹配 a.b,abc,但不能匹配ab/,因为它不会匹配路径分隔符 [xyz].js 只能匹配 x.js,y.js,z.js,不会匹配xy.js,xyz.js等,整个中括号只代表一个字符 [^xyz].js 能匹配 a.js,b.js,c.js等,不能匹配x.js,y.js,z.js 参考： 前端测试框架Jest系列教程 react的单元测试之jest jest jest 自动化测试 前端单元测试-jest 在VS Code中调试Jest单元测试 Jest基本使用方法以及mock技巧介绍 初尝 Jest 单元测试 React 16 Jest快照测试 使用 JEST 進行前端單元測試]]></content>
      <tags>
        <tag>单元测试</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mocha与chai]]></title>
    <url>%2F2018%2F12%2F03%2FMocha%E4%B8%8Echai%2F</url>
    <content type="text"><![CDATA[Mocha 的简介Mocha是流行的JavaScript测试框架之一，通过它添加和运行测试，从而保证代码质量 Mocha 的安装与配置项目中也安装Mocha1npm install --save-dev mocha 在package.json中加入下面脚本123"scripts": &#123; "test": "mocha"&#125; 测试模块 测试脚本里面应该包括一个或多个describe块，每个describe块应该包括一个或多个it块。 describe块称为”测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（”加法函数的测试”），第二个参数是一个实际执行的函数。 it块称为”测试用例”（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（”1 加 1 应该等于 2”），第二个参数是一个实际执行的函数。 chai Mocha本身不带断言库，所以必须先引入断言库。mocha经常和chai这个断言库一起配合使用 chai支持expect语法和should语法的BDD接近自然语言的写法和常规的asset语法12var &#123;expect&#125; = require('chai');expect(add(1, 1)).to.be.equal(2); 相关api参考 mocha 参数 Mocha默认运行test子目录里面的测试脚本(后缀名为.test.js（表示测试）或者.spec.js)。所以，一般都会把测试脚本放在test目录里面,但是test子目录下面的测试脚本不执行。 1mocha --recursive --help或-h参数，用来查看Mocha的所有命令行参数 1mocha --help --reporter参数用来指定测试报告的格式，默认是spec格式。使用mochawesome模块，可以生成漂亮的HTML格式的报告 1mocha --reporter mochawesome --watch参数用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha 1mocha --watch Mocha允许在test目录下面，放置配置文件mocha.opts,把命令行参数写在里面 123--reporter tap--recursive--growl –require参数指定测试脚本的转码器 1mocha --require @babel/register 注意，Babel默认不会对Iterator、Generator、Promise、Map、Set等全局对象，以及一些全局对象的方法（比如Object.assign）转码。如果你想要对这些对象转码，就要安装babel-polyfill。然后，在你的脚本头部加上一行。1import 'babel-polyfill' Mocha默认会高亮显示超过75毫秒的测试用例，可以用-s或–slow调整这个参数。 1$ mocha -t 5000 -s 1000 timeout.test.js Mocha默认每个测试用例最多执行2000毫秒，如果到时没有得到结果，就报错.需要用-t或–timeout参数，改变默认的超时设置 1$ mocha -t 5000 timeout.test.js 测试用例的钩子Mocha在describe块之中，提供测试用例的四个钩子：before()、after()、beforeEach()和afterEach()。它们会在指定时间执行。1234567891011121314151617181920describe('hooks', function() &#123; before(function() &#123; // 在本区块的所有测试用例之前执行 &#125;); after(function() &#123; // 在本区块的所有测试用例之后执行 &#125;); beforeEach(function() &#123; // 在本区块的每个测试用例之前执行 &#125;); afterEach(function() &#123; // 在本区块的每个测试用例之后执行 &#125;); // test cases&#125;); 参考 单元测试框架mocha 断言库chai 代理HTTP请求supertest]]></content>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test-1]]></title>
    <url>%2F2018%2F12%2F03%2Ftest-1%2F</url>
    <content type="text"><![CDATA[测试 单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作 端到端测试(e2e)是组件之间的配合(功能测试) -（整体,完整，所有功能的测试） 测试用例: 输入-&gt; 期待输出的过程 测试过程手工测试1234567891011//qs.jsfunction parse(str)&#123; let arr = str.split('&amp;'); let obj = &#123;&#125;; arr.forEach((item) =&gt; &#123; let [key, val] = item.split('='); obj[key] = val; &#125;); return obj;&#125;exports.parse=parse 123//qs.test.jsconsole.log(parse('name=zyp').name==='zyp')console.log(parse('name=zyp&amp;age=9').name==='zyp') 缺点： 污染源代码里混杂了很多测试代码 零散杂乱无章，不能分组和分类 没有持久化,没有存储 手动跑测试比较麻烦 assert断言 断言是表达设计人员对于系统应达到状态的一种预期 各种语言都内置了断言的接口 断言是单元测试的核心 12345678// const assert=require("assert")const assert=(expression,message)=&gt;&#123; if(!expression)&#123; throw new Error(message) &#125;&#125;assert(parse('name=zyp').name==='zyp','姓名必须是zyp')assert(parse('name=zyp&amp;age=9').age===9,'年龄必须是9') 问题 解决方案 污染 源代码里混杂了很多测试代码 从源代码中抽离出去 零散 杂乱无章，不能分组和分类 整体规划 和设计 没有持久化 没有存储 把测试文件单独存放 手动跑测试比较麻烦 自动运行并显示结果 测试框架正因为这些问题，测试框架应运而生 通过测试框架，我们可以分离测试代码和源代码 测试框架可以自动运行所有的用例并输出结果 测试框架可能提高编写测试代码的效率 开发模式瀑布模式 分析需求 调试开发 测试发布TDD(测试驱动开发) 在TDD理念中，先有测试代码再有功能逻辑代码 包括测试用例和断言 分为模块测试和单元测试 有其使用场景，不能滥用 (当用户需求模糊的时候不能用) 在实际开发中一般会使用测试框架 大概的流程是先针对每个功能点抽象出接口代码，然后编写单元测试代码，接下来实现接口，运行单元测试代码，循环此过程，直到整个单元测试都通过。 分析需求 任务、模块分解 编写测试用例,尽量穷尽和考虑所有边界 快速构建代码跑通测试用例 重构代码 功能测试、发布 BDD(行为驱动开发) 在TDD中，我们并不能完全保证根据设计所编写的测试就是用户所期望的功能。 BDD将这一部分简单和自然化，用自然语言来描述，让开发、测试、BA以及客户都能在这个基础上达成一致。 它鼓励软件项目中的开发这，QA和非技术人员之间的协作。常用测试框架 qunit jQuery mocha 支持Node&amp;Browser express.js jasmine 支持Node&amp;Browser Vue.js karma A Test-Runner 在不同的浏览器中跑测试用例 Angular jest React 零配置 内置代码覆盖率 内置Mocks TDD与BDD]]></content>
      <tags>
        <tag>单元测试</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-MVVM实现]]></title>
    <url>%2F2018%2F09%2F20%2Fvue-MVVM%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[MVVM概括 MVVM双向数据绑定,MVVM的数据影响视图,视图影响数据 angular 脏值检测,而vue却是数据劫持+发布订阅模式 由于vue是通过Object.difineProperty实现的,所以不见同低版本 Object.difineProperty(属性描述对象) 通过var obj={p:&#39;a&#39;},创建对象,默认情况如下: 12345678var obj=&#123;p:'a'&#125;Object.getOwnPropertyDescriptor(obj,'p')// &#123;// configurable:true, //属性是否可删除// enumerable:true, //属性是否可枚举// value:"a",//值// writable:true//属性是否可写// &#125; 通过Object.defineProperty(obj,&quot;p&quot;,{}),默认情况如下： 123456789var obj=&#123;&#125;Object.defineProperty(obj,"p",&#123;&#125;)Object.getOwnPropertyDescriptor(obj,"p")// &#123;// value: undefined,// writable: false,// enumerable: false, // configurable: false// &#125; 当set,get添加时,value和writable不能共存，会报错 Object.defineProperty的一个bug 123456789101112131415var person = &#123; a:1 &#125; // 注:里面的this指向ogj(person) Object.defineProperty(person,'a',&#123; get()&#123; return this.a &#125;, set(val)&#123; this.a = val &#125; &#125;) //我们想当然的这么写. person.a //Uncaught RangeError: Maximum call stack size exceeded // 什么,溢出了?这是为什么? // 哦~原来是这么写的话会造成循环引用,狂call不止 // 我们看下流程: // person.a → get.call(person) → this.a → person.a → get.call(person) → this.a......。 数据劫持(模拟vue) 将vue-data中的数据劫持到Object.defineProperty123456var vue=new Vue(&#123; el:'#app', data:&#123; a:1 &#125;&#125;) 1234567891011121314151617181920212223242526272829303132333435363738394041//mvvmclass Vue&#123; constructor(options)&#123; //将所有属性挂载到$options上 this.$options=options //将data数据挂载到this._data上 let data=this._data=options.data; Vue.observe(data) &#125; static observe(data)&#123; //数据劫持函数 工厂模式 if(typeof data !== 'object')&#123; return; &#125; return new Observe(data) &#125;&#125;class Observe&#123; constructor(data)&#123; //循环遍历data，将每一个属性都挂载到Object.defineProperty上 for(let key in data)&#123; let val=data[key] Vue.observe(val) Object.defineProperty(data,key,&#123; enumerable:true, configurable:true, get()&#123; return val; &#125;, set(newval)&#123; if(val===newval)&#123; return; &#125; val=newval Vue.observe(newval) &#125; &#125;) &#125; &#125;&#125; 数据代理我们现在可以通过vue._data.a来更改数据了,但是我们更需要通过vue.a来更改数据，所以就需要代理一下123456789101112131415static proxy(vm,data)&#123; //数据代理 for(let k in data)&#123; Object.defineProperty(vm,k,&#123; enumerable:true, configurable:true, set(newval)&#123; vm._data[k]=newval &#125;, get()&#123; return vm._data[k] &#125; &#125;) &#125; &#125; 模版编译123456789101112131415161718192021222324252627282930313233static compile(vm)&#123; let el=vm.$el=document.querySelector(vm.$options.el) //将dom操作移入内存中 let Fragment =document.createDocumentFragment() let child=null; while(child=el.firstChild)&#123; Fragment.appendChild(child) &#125; //替换 Vue.replace(vm,Fragment) //插入文档中 el.appendChild(Fragment) &#125; //模板替换 static replace(vm,nodes)&#123; let reg=/\&#123;\&#123;(.*)\&#125;\&#125;/ Array.from(nodes.childNodes).forEach((node)=&gt;&#123; let content=node.textContent //正则匹配并且时文本节点 let res=vm; if(reg.test(content) &amp;&amp; node.nodeType===3)&#123; let resArr=RegExp.$1.split(".") resArr.forEach(val=&gt;&#123; res=res[val] &#125;) console.log(res) node.textContent=content.replace(reg,res) &#125; if(node.childNodes)&#123; Vue.replace(vm,node) &#125; &#125;) &#125; 发布订阅模式我们已经可以通过模板编译，将数据渲染在页面上了,但是还有一个问题就是，当数据更改时，可以实时的渲染在页面上，这就需要发布订阅模式了,所以先写一个发布订阅的例子 发布订阅,先有订阅，然后在发布。将数据用一个数组存储起来，当发布的时候，遍历整个数组1234567891011class AddSub&#123; constructor()&#123; this.subs=[] &#125; on(fn)&#123; this.subs.push(fn) &#125; emit()&#123; this.subs.forEach(item=&gt;item.update()) &#125;&#125; 规定监听函数上一个update方法，便于业务处理12345678class Watcher&#123; constructor(fn)&#123; this.fn=fn &#125; update() &#123; this.fn() &#125;&#125; 测试123456let w=new Watcher(function()&#123; console.log('1')&#125;)var add=new addSub()add.on(w)add.emit() 连接视图和数据我们已经了解了发布订阅模式，现在我们来连接视图和数据吧1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586static replace(vm,nodes)&#123; let reg=/\&#123;\&#123;(.*)\&#125;\&#125;/ Array.from(nodes.childNodes).forEach((node)=&gt;&#123; let content=node.textContent //正则匹配并且时文本节点 let res=vm; if(reg.test(content) &amp;&amp; node.nodeType===3)&#123; res=donum(RegExp.$1,res) + new Watcher(RegExp.$1,vm,function(res)&#123; + node.textContent=content.replace(reg,res) + &#125;) node.textContent=content.replace(reg,res) &#125; if(node.childNodes)&#123; Vue.replace(vm,node) &#125; &#125;) &#125; //执行模板数据function donum(reg,res)&#123; let resArr=reg.split(".") resArr.forEach(val=&gt;&#123; res=res[val] &#125;) console.log(res) return res&#125;class Observe&#123; constructor(data)&#123; //循环遍历data，将每一个属性都挂载到Object.defineProperty上 let addsub=new AddSub() for(let key in data)&#123; let val=data[key] Vue.observe(val) Object.defineProperty(data,key,&#123; enumerable:true, configurable:true, get()&#123; + AddSub.target &amp;&amp; addsub.on(AddSub.target) return val; &#125;, set(newval)&#123; if(val===newval)&#123; return; &#125; val=newval Vue.observe(newval) + addsub.emit() &#125; &#125;) &#125; &#125;&#125;class AddSub&#123; constructor()&#123; this.subs=[] &#125; on(fn)&#123; this.subs.push(fn) &#125; emit()&#123; this.subs.forEach(item=&gt;item.update()) &#125;&#125;//规定监听函数上一个updated方法，便于业务处理class Watcher&#123; constructor(reg,vm,fn)&#123; this.reg=reg; this.vm=vm this.fn=fn AddSub.target=this; donum(this.reg,this.vm) //强制执行get方法 AddSub.target=null; &#125; update() &#123; let res=donum(this.reg,this.vm) this.fn(res) &#125;&#125; 数据双向绑定123456789101112131415161718if(node.nodeType===1)&#123; //数据双向绑定 属性 Array.from(node.attributes).forEach(attr=&gt;&#123; let name=attr.name;// type="text" let exp=attr.value; //v-model="b" if(name.indexOf("v-")!==-1)&#123; node.value=vm[exp] new Watcher(exp,vm,function(newVal)&#123; node.value=newVal &#125;) node.addEventListener("input",(e)=&gt;&#123; vm[exp]=e.target.value &#125;) &#125; &#125;) computed的实现123456789101112131415static computed(vm)&#123;//具有缓存功能 let computed=vm.$options.computed Object.keys(computed).forEach(key=&gt;&#123; console.log(computed[key]) Object.defineProperty(vm,key,&#123; enumerable:true, configurable:true, get:typeof computed[key]==='function'?computed[key]:computed[key].get, set()&#123; &#125; &#125;) &#125;) &#125; 参考： Vue双向绑定的实现原理Object.defineproperty Vue的双向绑定原理及实现]]></content>
      <tags>
        <tag>vue</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端设计模式]]></title>
    <url>%2F2018%2F09%2F17%2F%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[面向对象什么是面向对象 类 12345678910111213//类 即 模板class Person&#123; constructor(name,age)&#123; this.name=name; this.age=age; &#125; eat()&#123; alert(`$&#123;this.name&#125; eat something`) &#125; speak()&#123; alert(`My name is $&#123;this.name&#125;,age$&#123;this.age&#125;`) &#125;&#125; 对象（实例） 123456789//创建实例let zhang=new People('zhang',20)zhang.eat()zhang.speak()//创建实例let wang=new People('wang',21)wang.eat()wang.speak() 继承 子类继承父类 父类是公共的，不仅仅服务于单个子类 继承可以将公共方法抽离出来，提高复用，减少冗余12345678910111213141516171819202122//父类class Person&#123; constructor(name,age)&#123; this.name=name; this.age=age; &#125; eat()&#123; alert(`$&#123;this.name&#125; eat something`) &#125; speak()&#123; alert(`My name is $&#123;this.name&#125;,age$&#123;this.age&#125;`) &#125;&#125;//子类class Student extends Person&#123; constructor(name,age,number)&#123; super(name,age) this.number=number &#125;&#125; 123//实例let xiaoming=new Student('xiaoming',10,'A1')xiaoming.eat() 封装 数据的权限和保密 减少耦合，不该外露的不外露 利用数据、接口的权限管理 3个属性 public 完全开放 protected 对子类开放 private 对自己开放 es6不支持，一般认为_开头的属性是private，可以用typescipt 来演示12345678910111213141516171819202122232425262728293031323334353637383940//父类class People&#123; name age protected weight //定义 protected 属性 受保护的属性，只能自己访问和子类访问 constructor(name,age)&#123; this.name=name; this.age=age this.weight=120 &#125; eat()&#123; alert(`$&#123;this.name&#125; eat something`) &#125; speak()&#123; alert(`MY name is $&#123;this.name&#125;,age $&#123;this.age&#125;`) &#125;&#125;//子类class Student extends People&#123; number private girlfriend //定义 private 属性 constructor(name,age,number)&#123; super(name,age) this.number=number this.girlfriend='xiaoli' &#125; study()&#123; alert(`$&#123;this.name&#125; study`) &#125; getWeight()&#123; alert(`$&#123;this.weight&#125;`) &#125;&#125;//实例let xiaoming=new Student('xiaoming',10,'A1')xiaoming.getWeight()//console.log(xiaoming.girlfriend) //注意，编译会报错，直接编译不通过 多态 同一接口不同实现 js应用极少 需要结合java等语言的接口、重写、重载等功能 保持子类的开放性和灵活性 面向接口编程 （js引用极少，了解即可）12345678910111213141516171819202122232425262728293031class People&#123; constructor(name)&#123; this.name=name &#125; saysomething()&#123; &#125;&#125; class A extends People&#123; constructor(name)&#123; super(name) &#125; saySomething()&#123; alert('I am A') &#125;&#125;class B extends People&#123; constructor(name)&#123; super(name) &#125; saySomething()&#123; alert('I am B') &#125;&#125;let a= new A('a')a.saySomething()let b=new B('b)b.saySomething() 为何使用面向对象 程序执行：顺序、判断、循环—结构化 面向对象– 结构化 对于计算机，结构化的才是最简单 编程应该 简单 &amp; 抽象 UML类图 Unified Modeling Language 统一建模语言 类图，UML包含很多种图，和本课相关的是类图 关系，主要讲解泛化和关联 演示 ，代码和类图结合 画图工具 MS Office visio https://www.processon.com类图 关系 泛化，表示继承 关联，表示引用 12345678910111213141516171819202122232425262728293031323334353637class People&#123; constructor(name,house)&#123; this.name=name this.house=house &#125; saysomething()&#123; &#125;&#125; class A extends People&#123; constructor(name,house)&#123; super(name,house) &#125; saySomething()&#123; alert('I am A') &#125;&#125;class B extends People&#123; constructor(name,house)&#123; super(name,house) &#125; saySomething()&#123; alert('I am B') &#125;&#125;class House&#123; constructor(name,house)&#123; &#125;&#125;let aHouse=new House('beijing')let a= new A('a',aHouse)a.saySomething()let b=new B('b)b.saySomething() 设计原则何为设计描述 即按照哪一种思路或者标准来实现功能 功能相同，可以有不同设计方案来实现 伴随着需求增加，设计的作用才能体现出来 《UNIX/LINUX设计哲学》设计准则 小即是美 让每个程序只做好一件事 快速建立原型 舍弃高效率而取可移植性 采用纯文本来存储数据 充分利用软件的杠杆效应(软件复用) 使用shell脚本来提高杠杆效应和可移植性 避免强制性的用户界面 让每个程序都称为过滤器 小准则：允许用户定制环境 小准则：尽量使用操作系统内核小而轻量化 小准则：使用小写字母并尽量简写 小准则：沉默是金 小准则：各部分之和大于整体 小准则：寻求90%的解决方案 演示：沉默是金+让每个程序成为过滤器12# 让每个程序成为过滤器ls | grep *.json | grep 'package' S O L I D 五大设计原则 S: 单一职责原则 O: 开放封闭原则 L: 李氏置换原则 I: 接口独立原则 D: 依赖倒置原则 单一职责原则 一个程序只做好一件事 如果功能过于复杂就拆分开，每个部分保持独立 开放封闭原则 对扩展开放，对修改封闭 增加需求时，扩展新代码，而非修改已有代码 这是软件设计的终极目标 李氏置换原则 子类能覆盖父类 父类能出现的地方子类就能出现 js使用较少（弱类型 &amp;&amp; 继承使用较少） 接口独立原则 保持接口的单一独立，避免出现“胖接口” JS中没有接口（typescript例外）,使用较少 类似与单一职责原则，这里更关注接口 依赖倒置原则 面向接口编程，依赖于抽象而不依赖于具体 使用方只关注接口而不关注具体类的实现 JS中使用较少(没有接口 &amp; 弱类型) 总结 SO 体现较多，详细介绍 LID体现较少，但是要了解其用意 12345678910111213141516171819202122232425262728// 单一职责 开放封闭原则// 加载图片function loadImg(src)&#123; let promise=new Promise(function(resolve,reject)&#123; let img=document.createElement('img') img.onlad=function()&#123; resolve(img) &#125; img.onerror=function(err)&#123; reject('图片加载失败') &#125; img.src=src &#125;) return promise&#125;let src='http://'let result=loadImg(src)result.then(function(img)&#123; console.log(img.width) //part1 return img&#125;).then(function(img)&#123; //part2 console.log(img.height)&#125;).catch(function(ex)&#123; console.log(ex)&#125;) 从设计到模式 设计和模式分开 从设计到模式 23种设计模式 创建型 工厂模式(工厂方法模式、抽象工厂模式、建造者模式) 单例模式 原型模式 结构型 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 行为型 策略模式 模板方法模式 观察者模式 迭代器模式 职责连模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 打车时，可以打专车或者快车。 任何车都有车牌号和名称 * 不同车价格不同，快车每公里1元，专车每公里2元 * 行程开始时，显示车辆信息 * 行程结束时，显示打车金额（假定行程就5公里） * 画出UML类图 * 用ES6语法写出该示例*/class Car&#123; constructor(number,name)&#123; this.number=number this.name=name &#125;&#125;class KCar extends Car&#123; constructor(number,name)&#123; super(number,name) this.price=1 &#125;&#125;class ZCar extends Car&#123; constructor(number,name)&#123; super(number,name) this.price=2 &#125;&#125;class Trip&#123; constructor(car)&#123; this.car=car &#125; start()&#123; console.log(this.car.name,this.car.number) &#125; end()&#123; console.log(this.car.price*5) &#125;&#125;let car=new KCar(100,'桑')let trip=new Trip(car)trip.start()trip.end() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/** * 某停车场，分3层，每层100车位 * 每个车位都能监控到车辆的驶入和离开 * 车辆进入前，显示每层的空余车位数量 * 车辆进入摄像头可识别车牌号和时间 * 车辆出来时，出口显示器显示车牌号和停车时长 * * 画出UML类图 * 1. 多少个类*/class Car&#123; constructor(num)&#123; this.num=num &#125;&#125;//摄像头class Camera&#123; shot(car)&#123; return &#123; num:car.num, inTime:Date.now() &#125; &#125;&#125;class Screen&#123; show(car,inTime)&#123; console.log(Date.now()-inTime) &#125;&#125;class Park&#123; constructor(floors)&#123; this.floors=floors || [] this.camera=new Camera() this.screen=new Screen() this.carList=&#123;&#125;//存储摄像头拍摄返回信息 &#125; in(car)&#123; //通过摄像头获取信息 const info=this.camera.shot(car) //停到某个停车位 const i=parseInt(Math.random()*100%100) const place=this.floors[0].places[i] place.in() info.place=place //记录信息 this.carList[car.num]=info &#125; out(car)&#123; //获取信息 const info=this.carList[car.num] //将停车为清空 const place=info.place place.out() // 显示时间 this.screen.show(car,info.inTime) //清空记录 delete this.carList[car.num] &#125; emptyPlaceNum()&#123; return this.floors.map((floor)=&gt;&#123; return `$&#123;floor.index&#125;层还有$&#123;floor.emptyPlaceNum()&#125;` &#125; ).join("\n") &#125;&#125;//层class Floor&#123; constructor(index,places)&#123; this.index=index this.places=places || [] &#125; emptyPlaceNum()&#123; let num=0; this.places.forEach(p=&gt;&#123; if(p.empty)&#123; num=num+1 &#125; &#125;) return num &#125;&#125;//车位class Place&#123; constructor()&#123; this.empty=true; &#125; in()&#123; this.empty=false &#125; out()&#123; this.empty=true; &#125;&#125;//测试// 初始化停车场const floors=[]for(var i=0;i&lt;3;i++)&#123; const places=[] for(var j=0;j&lt;100;j++ )&#123; places[j]=new Place() &#125; floors[i]=new Floor(i+1,places)&#125;const park=new Park(floors)// 初始化车辆const car1=new Car(100)const car2=new Car(200)const car3=new Car(300)console.log('第一辆车进入')console.log(park.emptyPlaceNum())park.in(car1)console.log('第二俩进入')console.log(park.emptyPlaceNum())park.in(car2)console.log('第一俩离开')park.out(car1)console.log('第二俩离开')park.out(car2) 工厂模式介绍 将new操作单独封装 遇到new时，就要考虑是否该使用工厂模式 示例 你去购买汉堡，直接点餐、取餐，不会自己亲手做 商店要封装做汉堡的工作，做好直接给买者 UML类图 1234567891011121314151617181920212223242526class Creator&#123; create(name)&#123; return new Product(name) &#125;&#125;class Product&#123; constructor(name)&#123; this.name=name &#125; init()&#123; console.log("int1") &#125; fun1()&#123; console.log("fun1") &#125; fun2()&#123; console.log("fun2") &#125;&#125;//测试let c1=new Creator()let p=c1.create('p1')p.init()p.fun1() 场景 jQuery-$(“div”) $(“div”)和new $(“div”) 有何区别？ 书写麻烦，jQuery 的链式操作将成为噩梦 一旦jQuery名字变化，将是灾难的 React.createElement 1234567class Vnode(tag,attrs,children)&#123; //...省略内部代码&#125;React.createElement=function(tag,attrs,children)&#123; // 可以做验证 return new Vnode(tag,attrs,children)&#125; vue异步组件 1234567Vue.component("async-example",function(resolve,reject)&#123; setTimeout(function()&#123; resolve(&#123; template:"&lt;div&gt;I am async!&lt;/div&gt;" &#125;) &#125;,1000)&#125;) 设计原则 构造函数和创建者分离 符合开放封闭原则 单例模式介绍 系统中被唯一使用 一个类只有一个实例 示例 登录框 购物车 12345678910111213141516171819202122class SingleObject&#123; login()&#123; console.log("login) &#125;&#125;//实例上没有getInstance方法SingleObject.getInstance=(function()&#123;let intance;return function()&#123; if(!intance)&#123; intance=new SingleObject() &#125; return instance&#125;&#125;)()//测试let obj1=SingleObject.getInstance()obj1.login()let obj2=SingleObject.getInstance()obj2.login()console.log('obj1===obj2',obj1===obj2) 场景 jQuery只有一个$ 123456//jQuery只有一个$if(window.jQuery!=null)&#123; return window.jQuery&#125;else&#123; //初始化&#125; 模拟登录框 123456789101112131415161718192021222324252627282930313233343536class LoginForm&#123; constructor()&#123; this.state='hide' &#125; show()&#123; if(this.state==='show')&#123; console.log("已经显示") return &#125; this.state='show' console.log('显示') &#125; hide()&#123; if(this.state==='hide')&#123; console.log("已经显示") return &#125; this.state='hide' console.log('隐藏') &#125;&#125;LoginForm.getInstance=(function()&#123; let instance return function()&#123; if(!intance)&#123; intance=new LoginForm() &#125; return instance &#125;&#125;)()//测试let login1=LoginForm.getInstance()login1.show()let login2=LoginForm.getInstance()login1.hide() 其他 购物车(和登录框类似) vuex和redux中的store 设计原则验证 符合单一职责原则，只实例化唯一的对象 没发具体开放封闭原则，但是绝对不违反开放封闭原则 适配器模式介绍 旧接口格式和使用者不兼容 中间加一个适配转换接口 示例 UML类图 代码演示12345678910111213141516171819class Adaptee&#123; specificRequest()&#123; return '德国标准插头' &#125;&#125;class Target&#123; constructor()&#123; this.adaptee=new Adaptee() &#125; requrest()&#123; let info=this.adaptee.specificRequest() return `$&#123;info&#125;-转换器-中国标准插头` &#125;&#125;//测试let target=new Target()let res=target.request() 场景 封装旧接口 123456789101112131415161718//自己封装的ajax,使用方式如下ajax(&#123; url:'/getDate', type:"post", data:&#123; id:"123" &#125;&#125;).done(function()&#123;&#125;)//但是因为历史原因，代码中全是：//$.ajax(&#123;...&#125;)//做一层适配器var $=&#123; ajax:function(options)&#123; return ajax(options) &#125;&#125; vue computed 1234567891011var vm=new Vue(&#123; el:"#exaple", data:&#123; message:"hello" &#125;, computed:&#123; reversedMessage()&#123; return this.message.split("").reverse().join("") &#125; &#125;&#125;) 设计原则验证 将旧接口和使用者进行分离 符合开放封闭原则 装饰器模式介绍 为对象添加新功能 不改变其原有的结构和功能 示例手机壳 UML类图 123456789101112131415161718192021222324class Cicle&#123; draw()&#123; console.log("画一个圆形") &#125;&#125;class Decorator()&#123; constructor(cicle)&#123; this.cicle=cicle &#125; draw()&#123; this.cicle.draw() this.setRedBorder(this.cicle) &#125; setRedBorder(cicle)&#123; console.log('设着红色边框') &#125;&#125;//测试let cicle=new Cicle()cicle.draw()let dec=new Decorator()dec.draw() 场景 es7装饰器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//装饰类 @testDecclass Demo&#123; &#125;function testDec(target)&#123; target.isDec=true&#125;console.log(Demo.isDec)//装饰类 加参数@testDec(true)class Demo&#123;&#125;function testDec (isDec)&#123; return function(target)&#123; target.isDec=isDec &#125;&#125;console.log(Demo.isDec)//装饰类-mixin示例function mixins(...list)&#123; return function(target)&#123; Object.assign(target.prototype,...list) &#125;&#125;const Foo=&#123; foo()&#123; alert('foo') &#125;&#125;@mixins(Foo)class MyClass&#123;&#125;let obj=new MyClass();obj.foo()//'foo'//装饰方法class Person&#123; constructor()&#123; this.first='A' this.last='B' &#125; //装饰方法 @readonly name()&#123;return `$&#123;this.first&#125; $&#123;this.last&#125;`&#125;&#125;var p= new Person()console.log(p.name())//p.name=function()&#123;&#125; //这里会报错，因为name是只读的function readonly(target,name,descriptor)&#123; //默认是 //&#123; // value :specifiedFunction, // enumerable:false, // configurable:true, // writable:true // &#125; descriptor.writable=false; return descriptor&#125; core-decorators 第三方开源lib 提供常用的装饰器 设计原则验证 将现有对象和装饰器进行分离，两者独立存在 符合开放封闭原则 代理模式介绍 使用者无权访问目标对象 中间加代理，通过代理做授权和控制 示例 科学上网 明星经纪人 UML 12345678910111213141516171819202122232425class ReadImg&#123; constructor(fileName)&#123; this.fileName=fileName this.loadFromDisk()//初始化即从硬盘加载，模拟 &#125; display()&#123; console.log("display") &#125; loadFromDisk()&#123; console.log('loading') &#125;&#125;class ProxyImg&#123; constructor(filename)&#123; this.realImg=new ReadImg(filename) &#125; display()&#123; this.realImg.display() &#125;&#125;//测试let proxyImg=new ProxyImg('1.png')proxyImg.display 场景 网页事件代理 1234567var div1=document.getElementById("div1")div1.addEventListener("click",function(e)&#123; var target=e.target if(target.nodeName==='A')&#123; alert(target.innerHTML) &#125;&#125;) jQuery $.proxy 123456789101112131415161718$("#div1").click(function()&#123; $(this).addClass("red")&#125;)$("#div1").click(function()&#123; setTimeout(function()&#123; //this不符合要求 $(this).addClass("red") &#125;,1000)&#125;)//可以使用$.proxy解决$("#div1").click(function()&#123; setTimeout($.proxy(function()&#123; //this不符合要求 $(this).addClass("red") &#125;,this),1000)&#125;) ES6 Proxy 123456789101112131415161718192021222324252627282930313233//明星let star=&#123; name:'zhangxxxx', age:25, phone:'130000000'&#125;// 经纪人let agent=new Proxy(star,&#123; get:function(target,key)&#123; if(key==='phone')&#123; //经纪人电话 return '122344231213' &#125; if(key==='price')&#123; //明星不报价，经纪人报价 return 12000 &#125; return target[key] &#125;, set(target,key,val)&#123; if(key==='customPrice')&#123; if(val&lt;10000)&#123; //最低10万 throw new Error('价格低') &#125;else&#123; target[key]=value return true &#125; &#125; &#125;&#125;)console.log(agent.name) 设计原则验证 代理类和目标类分离，隔离开目标类和使用者 符合开放封闭原则 代理模式 vs 适配器模式 适配器模式：提供一个不同的接口(如不同版本的插头) 代理模式：提供一模一样的接口 代理模式 Vs 装饰器模式 装饰器模式：扩展功能，原有功能不变且可直接使用 代理模式： 显示原有功能，但是经过限制或者阉割之后的 外观模式介绍 为子系统中的一组接口提供了一个高层接口 使用者使用这个高层接口 示例 去医院看病，接待员去挂号，门诊，划价、取药![前端设计模式_外观模式2018919165551](http://b.zhangyapeng.club/前端设计模式外观模式_2018919165551.png) UML类图 1234567891011function binfEvent(ele,type,selector,fn)&#123; if(fn==null)&#123; fn=selector selector=null &#125; //****&#125;//调用bindEvent(elem,'click','#div1',fn)bindEvent(elem,'click',fn) 设计原则验证 不符合单一职责原则和开放封闭原则，因此谨慎使用，不可滥用 观察者模式 发布 &amp; 订阅 一对多 示例 点咖啡，点好之后坐等被叫 UML类图 12345678910111213141516171819202122232425262728293031323334353637383940//主题保存状态，状态变化之后触发所有观察者对象class Subject&#123; constructor()&#123; this.state=0; this.observers=[] &#125; getState()&#123; return this.state &#125; setState(state)&#123; this.state=state &#125; notifyAllObservers()&#123; this.observers.forEach(observer=&gt;&#123; observer.update() &#125;) &#125; attach(observer)&#123; this.observers.push(observer) &#125;&#125;//观察者class Observer&#123; constructor(name,subject)&#123; this.name=name; this.subject=subject this.subject.attach(this) &#125; update()&#123; console.log(this.name) &#125;&#125;//测试let s=new Subject()let o1=new Observer('o1',s)let o2=new Observer('o2',s)let o3=new Observer('o3',s)s.setState('1') 场景 网页事件绑定 123$("#btn").click(function()&#123; console.log('1')&#125;) Promise jQuery callback 12345var callbacks=$.Callbacks()callbacks.add(function(info)&#123; console.log(info)&#125;)callbacks.fire('gogo') nodejs 自定义事件 123456const EventEmitter=require("events").EventEmitterconst emitter1=new EventEmitter();emitter.on("some",()=&gt;&#123; //监听some事件&#125;)emitter.emit("some") nodejs中：处理http请求；多进程通讯 vue和React组件生命周期触发 vue watch 设计原则验证 主题和观察者分离，不是主动触发而是被动监听，两者解耦 符合开放封闭原则]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端性能优化 网络层面 构建层面 服务端层面 浏览器渲染层面 深入理解http请求的过程是前端性能优化的核心 资源的合并和压缩 减少http请求数量 减少请求资源的大小 压缩实现 html压缩 css压缩 js的压缩和混乱 合并 文件与文件之间有插入的上行请求，增加了N-1个网络延迟受 丢包问题影响更严重 经过代理服务器时可能会被断开 浏览器对于同域名下的静态资源加载数量为5个 文件合并存在的问题： 首屏渲染问题 缓存失效问题 解决办法： 公共库合并 不同页面的合并 见机行事，随机应变 图片相关的优化的核心概念文件大小、色彩丰富程度的权衡 JPG-有损压缩 png8-256色+支持透明 png24-2^24色+不支持透明 png32-2^24色+支持透明 每种图片格式都有自己的特点，针对不同的业务场景选择不同的图片格式很重要 不同格式图片常见的业务场景特点： jpg有损压缩，压缩率高，不支持透明 png支持透明，浏览器兼容好 webp压缩程度更好，在ios webview有兼容性问题 svg矢量图，代码内嵌，相对较小，图片样式相对简单的场景 场景： jpg —— 大部分不需要透明图片的业务场景 png —— 大部分需要透明图片的业务场景 webp —— 安卓全部 svg矢量图 —— 图片样式相对简单的业务场景 进行图片压缩 针对真实图片情况，舍弃一些相对无关紧要的色彩信息 css雪碧图 Image inline(base64) CSS雪碧图 把你的网站上用到的一些图片整合到一张单独的图片中 优点：减少你的网站的HTTP请求数量 缺点：整合图片比较大时，一次加载比较慢 Image inline 将图片的内容内嵌到html当中 减少你的网站的HTTP请求数量 使用矢量图 使用SVG进行矢量图的绘制 使用iconfont解决icon问题 在安卓下使用webpWebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。 使用webp\ 标签 \是HTML5中的一个新标签，类似它也可以指定多个格式的资源，由浏览器选择自己支持的格式进行加载。12345678&lt;picture class="picture"&gt;&lt;source type="image/webp" srcset="image.webp"&gt;&lt;img class="image" src="image.jpg"&gt;&lt;/picture&gt; 如果浏览器支持WebP格式，就会加载Image.webp，否则会加载Image.jpg。 即使浏览器不支持标签，图片仍然会正常显示，只是CSS可能无法正确选取到Picture元素。比如在IE8中，下面的CSS就不会起作用：1.picture img &#123; width: 100px; height: 100px;&#125; 但是可以这样来给图片写样式：1.image &#123; width: 100px; height: 100px;&#125; 即使浏览器使用的是WebP格式的图片，最终还是会应用img元素的样式。 不过只要使用了，使旧的浏览器支持这个标签，CSS选择器就可以正常使用了。这种方法是最简单的，但是不能作用于CSS中的图片（如背景） webp的格式:http://www.a.jpg_.webp 图片压缩:https://tinypng.com/css和js加载与执行一个网站在浏览器端是如何进行渲染的呢？html页面渲染的过程 特点 顺序执行、并发加载 是否阻塞 依赖关系 引入方式 顺序执行、并发加载 词法分析 并发加载 并发上限 css阻塞 css head中阻塞页面的渲染、link标签加载完才渲染 css阻塞js的执行 css不阻塞外部脚本的加载 js可能修改dom,有可能涉及到css修改，是基于前面执行的css来修改 js阻塞 直接引入的js阻塞页面的渲染 js不阻塞资源的加载 js顺序执行，阻塞后续js逻辑的执行 依赖关系 页面渲染依赖于css的加载 js的执行顺序的依赖关系 js逻辑对于dom节点的依赖关系 js引入方式 直接引入 defer async 异步动态引入js 加载和执行的一些优化点 css 样式表置顶 用 link 代替 import js 脚本置底 合理使用 js 的异步加载能力 懒加载 图片进入可视区域之后请求图片资源 对于电商等图片很多，页面很长的业务场景适用 减少无效资源的加载 并发加载的资源过多会阻塞js的加载，影响网站的正常使用 12345678&lt;img src="" data-origin="" /&gt;&lt;script&gt;var vierHeight=document.documentElement.clientHeight//可是区域的高度react=item.getBoundingClientReact() 是否在可视区&lt;/script&gt;&lt;!-- img要设置高度 --&gt; 预加载 图片等静态资源在使用之前的提前请求 资源使用到的时能缓存中加载，提升用户体验 页面展示的依赖关系维护 预加载方式 html标签 1&lt;img src="http://xxx/jpg" style="display:none" /&gt; 使用Image对象 12var image=new Image()image.src="http://xxx.jpg" 使用XMLHttpRequest对象请求 preload.js 重绘和回流css性能让javascript变慢 css:UI渲染单独的进程 js:javascript解析的进程 UI渲染与javascript解析是互斥的执行的 频繁触发重绘与回流，会导致UI频繁渲染，最终导致js变慢 回流 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow) 当页面布局和几何属性改变时就需要回流 重绘当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 注意： 回流必将引起重绘 而重绘不一定会引起回流 触发页面冲布局的属性 盒子模型相关属性会触发重布局 定位属性及浮动也会触发重布局 改变节点内部文字结构也会触发重布局 只触发重绘的属性 新建DOM的过程 获取DOM后分割为多个图层 对每个图层的节点计算样式结果（Recalculate style–样式重计算） 为每个节点生成图形和位置（Layout–回流和重布局） 将每个节点绘制填充到图层位图中（Paint Setup和Paint–重绘） 图层作为纹理上传至GPU 符合多个图层到页面上生成最终屏幕图像（Composite Layers–图层重组） 注意： 将频繁重绘回流的DOM元素单独作为一个独立图层，那么这个DOM元素的重绘和回流的影响只会在这个图层中。 因为合并图层的时候,也就是Composite Layers，会消耗大量的时间，所以尽量少建立图层，除非该图层影响页面性能大的时候。 如何将DOM元素变成新的独立图层？Chrome创建图层的条件 3D或透视变换（perspective transform）CSS属性 使用加速视频解码的&lt;video>节点 拥有3D（WebGL）上下文或加速的2D上下文的&lt;canvas>节点 混合插件（如Flash） 对自己的opacity做CSS动画或使用一个动画webkit变换的元素 拥有加速CSS过滤器的元素 元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里） 元素有一个z-index较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染） 代码实现12345/* 两个都可以*/*&#123; transfrom:translateZ(0); will-change:transform;&#125; 开启Layers 开启paint(渲染视图) 用例：gif可以使用创建图层，因为gif图会频繁的重绘,但是img标签本身不会创建图层，所以需要我们去创建 优化方案 避免使用触发重绘、回流的css属性 将重绘、回流的影响范围限制在单独的图层之内 图层不能被滥用 实战优化点 用translate替代top改变 用opacity替代visibility 不要一条一条地修改 DOM 的样式，预先定义好 class，然后修改 DOM 的 className 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次Reflow回流)，然后你修改100次，然后再把它显示出来 不要把 DOM 结点的属性值 (offsetHeight)放在一个循环里当成循环里的变量 不要使用table布局，可能很小的一个小改动会造成整个table的重新布局 动画实现的速度的选择 对于动画新建图层 启用GPU硬件加速 GPU加速(WebGL、3d) GPU是并行运算的,对于并行运算的纹理绘制，会非常快 因为数据在cpu上,如果GPU加速，要把数据从cpu传输到GPU上，如果数据过多，要慎重考虑 浏览器储存Cookie 因为HTTP请求无状态，所以需要cookie去维持客户端状态 cookie的生成方式 用于浏览器端和服务器端的交互 客户端自身数据的存储 http response header中的set-cookie js中可以通过document.cookie可以读写cookie 过期时间expire 仅仅作为浏览器存储（大小4KB左右，能力被localstorage替代） httponly不支持js的读写 cookie中在相关域名下面 —— cdn的流量损耗 cdn的域名和主站的域名要分开 LocalStorage HTML5设计出来专门用于浏览器存储的 大小为5M左右 仅在客户端使用，不和服务端进行通信 接口封装较好 浏览器本地缓存方案 SessionStorage 会话级别的浏览器存储 大小为5M左右 仅在客户端使用，不和服务端进行通信 接口封装较好 对于表单信息的维护 IndexedDB IndexedDB 是一种低级API，用于客户端存储大量结构化数据。该API使用索引来实现对该数据的高性能搜索。虽然Web Storage对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案。 为应用创建离线版本 PWAPWA (Progressive Web Apps) 是一种 Web App 新模型，并不是具体指某一种前沿的技术或者某一个单一的知识点，我们从英文缩写来看就能看出来，这是一个渐进式的 Web App，是通过一系列新的 Web 特性，配合优秀的 UI 交互设计，逐步的增强 Web App 的用户体验。 特点 可靠：在没有网络的环境中也能提供基本的页面访问，而不会出现“未连接到互联网”的页面。 快速：针对网页渲染及网络数据访问有较好优化。 融入（Engaging）：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性 检测PWA的支持度 lighthouse Service Worker Service Worker是一个脚本，浏览器独立于当前网页，将其在后台运行,为实现一些不依赖页面或者用户交互的特性打开了一扇大门。在未来这些特性将包括推送消息,背景后台同步， geofencing（地理围栏定位），但它将推出的第一个首要特性，就是拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。 特点 使用拦截和处理网络请求的能力，去实现一个离线应用 使用service Worker在后台运行同时能和页面通信的能力，去实现大规模后台数据的处理 应用 chrome://serviceworker-internals/ chrome://inspect/#service-workers 测试页面12345678910111213141516171819202122232425// 当前页(function () &#123; if (navigator.serviceWorker) &#123; var msgIpt = document.getElementById('ipt'), showArea = document.getElementById('show'), sendBtn = document.getElementById('sendBtn'); navigator.serviceWorker.register('service-worker3.js'); navigator.serviceWorker.addEventListener('message', function (event) &#123; showArea.innerHTML = showArea.innerHTML + ('&lt;li&gt;' + event.data.message + '&lt;/li&gt;'); &#125;); sendBtn.addEventListener('click', function () &#123; // 发送数据 navigator.serviceWorker.controller.postMessage(msgIpt.value); msgIpt.value = ''; &#125;); &#125;&#125;)(); 123456789101112131415161718192021222324252627282930313233//servers-workself.addEventListener('message', function(event) &#123; var promise = self.clients.matchAll() .then(function(clientList) &#123; var senderID = event.source ? event.source.id : 'unknown'; if (!event.source) &#123; console.log('event.source is null; we don\'t know the sender of the ' + 'message'); &#125; clientList.forEach(function(client) &#123; if (client.id === senderID) &#123; return; &#125; client.postMessage(&#123; client: senderID, message: event.data &#125;); &#125;); &#125;); if (event.waitUntil) &#123; event.waitUntil(promise); &#125;&#125;);self.addEventListener('activate', function(event) &#123; event.waitUntil(self.clients.claim());&#125;); 缓存 httpHeader response request max-age s-max-age private public no-cache no-store max-age cache-control最大过期时间,优先级更高http1.1 expireshttp1.0 过期时间 优先级低 返回200 s-maxage 优先级比max-age高 只能指定public设备的缓存，就是定义cdn的缓存时间 private缓存设备指代浏览器，只能当前用户访问的缓存设备 public缓存设备例如cdn缓存设备，可以支持多用户访问缓存信息 no-cahce 不会像max-age一样，不往服务器发请求，而直接读取本地缓存 会让浏览器发请求到服务器，让服务器判断当前缓存是否可用，和last-modified配合使用 no-store配置no-store就不使用任何缓存策略 Expires 缓存过期时间,用来指定资源到期的时间，是服务器端的具体时间点 告诉浏览器在过期时间前浏览器可以直接从浏览器缓存中读取数据，而无需再次请求 协商缓存（客户端和服务端协商的结果）（缓存304，没匹配上缓存200）Last-Modifed/IF-Modified-Since 基于客户端和服务器端协商的缓存机制 last-modified—-response header if-modified-since—-request header 需要与cache-control共同使用,max-age没有过期先走max-age ####### last-modified有什么缺点？ 某些服务端不能获取精确的修改时间 文件修改时间改了，但是文件内容却没有变 毫秒级别的修改不能区分 Etag/If-None-Match 文件内容的hash值 etag–response header if-none-match—request header 需要与cache-control共同使用 如果同时有etag和last-modified存在，在发送请求的时候会一次性的发送给服务器，没有优先级，服务器会比较这两个信息（在具体实现上，大多数做法针对这种情况只会比对etag）。服务器在输出上，如果输出了etag就没有必要再输出last-modified（实际上大多数情况会都输出）。 分级缓存策略浏览器输入 url 之后敲下回车，刷新 F5 与强制刷新(Ctrl + F5)，又有什么区别？实际上浏览器输入url之后敲下回车就是先看本地cache-control、expires的情况，刷新(F5)就是忽略先看本地cache-control、expires的情况，带上条件If-None-Match、If-Modified-Since，强制刷新(Ctrl + F5)就是不带条件的访问。 值得注意的是，如果是 浏览器输入url之后敲下回车 你在network里面看到的状态往往是200，但是大小是0。这是因为这个200是上次访问资源返回的状态码。 如果你是一位开发者，还是建议在 Chrome 里面开启Disable Cache. 查看缓存: http://qqbrowser://view-http-cache/ chrome://about/ 服务端性能优化 vue渲染面临的问题 首屏加载问题 下载vue.js 执行vue.js 生成html页面 以前没有前端框架时 用jsp/php在服务器端进行数据的填充 发送给客户端就是已经填充好数据的html 使用Juqery异步加载数据 使用React和Vue前端框架 vue性能进行提升方案 构建层模板编译 数据无关的prerender的方式 服务端渲染]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染]]></title>
    <url>%2F2018%2F09%2F05%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[Get Started有这样几个问题，我们来思考一下： 我们平常浏览的网页是否是应用 在操作系统中的应用是如何运行的 浏览器究竟是什么 webkit和浏览器的关系 浏览器是如何呈现页面的 经典问题：从浏览器的地址输入一个网址直到网页内容呈现完毕，发生了哪些事情 基本概念浏览器浏览器是用户访问互联网最重要的接口 本质上,浏览器是方便一般互联网用户通过界面解析和发送HTTP协议的软件 浏览器历史 1991年，第一个浏览器WorldWideWeb(后改为Nexus),功能简单，不支持图片 1993年，Mosaic浏览器出现，可以显示图片，为了区分浏览器是否显示图片，出现了UserAgent 1994年，Mozilla浏览器出现,也就是后面大名鼎鼎的网景浏览器Netscape,它的UserAgent为Mozilla/1.0 1995年，IE浏览器出现，为了抢夺市场，UserAgent为Mozilla/1.22 1998年，网景浏览器失利，成立Mozilla组织 2003年，网景公司解散，Mozilla基金会成立，这个组织推进了后来的Firefox Mozilla开发了Geoko,变成了Firefox，他的UserAgentMozilla/5.0 群雄并起，众多公司的浏览器的UserAgent上都带有Mozilla chrome和safari出现，占有了很大的份额 问题： 最初的浏览器做了哪些事情 创建一个TCP连接 发送一个文本协议(请求头) 解析页面的操作(不解析图片) User-Agent的起初意义 告诉服务器,当前浏览器的版本，系统 起初为了区分浏览器是否支持图片 查看用户代理 打开chrome浏览器的控制台 在控制台输入navigator.userAgent 会发现类似的字符串Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36 用户代理的作用 判断浏览器类型，采用兼容方案 判断是否为移动端 标识H5容器，方便调用H5容器特定接口 要注意userAgent伪装成本很低，不要过于依赖 内核对于操作系统来说，内核是操作系统的核心，是第一层基于硬件的软件扩充，提供最核心最基础的服务 应用程序通过内核进行系统调用来使用计算机的硬件，内核代码简介高效,并且基本没有bug,由于是最底层的服务，一点微小的错误也会造成整个系统的崩溃。好处当然也显而易见，基于一个稳定的内核，开发者可以构建适合不同场景的操作系统和应用软件 对于浏览器来说，同样存在浏览器内核，与操作系统内核相似，浏览器内核需要提供API给浏览器开发者使用，同时提供最核心的功能，如加载和渲染网页，调用操作系统所提供的服务 对于浏览器厂商来说，高效使用和开发浏览器内核是核心问题。对于web开发者来说，理解浏览器内核的基本机制，才能开发出高性能的web应用 浏览器内核知识浏览器内核定义我们可以初步认为浏览器中负责将表示页面的字符串转变成可视化的图像的模块就是浏览器内核 回到”从输入URL…”的问题我们将输入URL到远程内容返回之前的阶段略过，从Response开始：使用Node.js的TCP模块来获取，远程主机究竟给我们返回了什么：12345678910111213141516171819202122232425262728const net = require('net')const fs = require('fs')const path = require('path')const desPort = 80const desHost = '123.57.205.204'let allBuffer = nullconst client = net.createConnection(desPort, desHost, function () &#123; console.log('connected to server!') client.write(`GET / HTTP/1.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.9\r\nCache-Control: no-cache\r\nConnection: keep-alive\r\nCookie: __cfduid=dcc794c22f91c478f5c0e21bd2a4dc4a71535945679; __root_domain_v=.zhufengpeixun.cn; _qddaz=QD.54jl6y.ec9qho.jllqeote; pgv_pvi=4490024960; tencentSig=320538624; IESESSION=alive; pgv_si=s8736718848; Hm_lvt_418b1c90fa35dc210dd5d2284d9f9f29=1535945692,1535963228,1536047064,1536110767; Hm_lvt_5ca1e1efc366a109d783a085499d59d9=1535964808,1536111794; Hm_lpvt_5ca1e1efc366a109d783a085499d59d9=1536111794; Hm_lpvt_418b1c90fa35dc210dd5d2284d9f9f29=1536140224; _qdda=3-1.1; _qddab=3-vgg4fx.jloy87b0; _qddamta_2852156370=3-0\r\nHost: www.zhufengpeixun.cn\r\nPragma: no-cache\r\n Upgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36\r\n\r\n`)&#125;)client.on('data', function (data) &#123; if (!allBuffer) &#123; allBuffer = data &#125; else &#123; allBuffer = Buffer.concat([allBuffer, data]) &#125;&#125;)client.on('error', function (err) &#123; console.log(err)&#125;)client.on('end', function () &#123; const htmlContent = allBuffer.toString() const ws = fs.createWriteStream( path.join(__dirname, 'zhufeng.html') ) ws.write(htmlContent)&#125;) 几个问题: 以上这段代码的逻辑 返回的字符串该如何解析 想让返回的字符串呈现为图像，怎么做 远程主机响应HTTP协议请求报文格式： 起始行:[方法][空格][请求URL][空格][HTTP版本][换行符] 首部:[首部名称][;][可选空格][首部内容][换行符] 首部结束:[换行符] 实体 响应报文格式: 起始行：[HTTP版本][空格][状态码][空格][原因短语][换行符] 首部:[首部名称][;][可选空格][首部内容][换行符] 首部结束:[换行符] 实体 换行符:\r\n 响应组成响应内容解析如下：1234567891011HTTP/1.0 302 FoundLocation: https://www.baidu.com/error.htmlServer: bfeDate: Wed, 05 Sep 2018 10:10:32 GMTContent-Length: 0Content-Type: text/plain; charset=utf-8# 实体内容 当前为html&lt;!DOCTYPE html&gt;&lt;HTML&gt;....&lt;/HTML&gt; 网页内容的组成 doctype:提供浏览器html版本信息，html解析器用那个版本解析 head:html头部 meta:元数据信息 charset:此特性声明当前文档所使用的字符编码 http-equiv:客户端行为，如渲染模式，缓存等 name[keywords]:搜索引擎使用 name[description]:搜索引擎使用 name[viewport]:浏览器视口设置 link script:需要在body前完成加载或运行的脚本 body:html实体 script:需要在body解析时加载或运行的脚本 问题:X-UA-Compatible是什么X-UA-Compatible是针对IE8新加的一个设置，对于IE8之前的浏览器是不识别的，这个区别与content=&quot;IE=7&quot;在无论页面是否包含&lt;!DOCTYPE&gt;指令，都像是使用了 Windows Internet Explorer 7的标准模式。而content=&quot;IE=EmulateIE7&quot;模式遵循&lt;!DOCTYPE&gt;指令。对于多数网站来说，它是首选的兼容性模式。 为了避免制作出的页面在IE8下面出现错误，建议直接将IE8使用IE7进行渲染。也就是直接在页面的header的meta标签中加入如下代码：1&lt;meta http-equiv="X-UA-Compatible" content="IE=7" /&gt; 渲染需要做的工作 上图表示了渲染引擎的一般渲染过程，虚线表示该阶段所依赖的外部模块（不属于渲染引擎） 重要组件 html解释器:解释HTML文本解释器，html文本-&gt;DOM树 css解释器：遇到级联样式时,需要使用级联样式表解释器，为DOM对象计算出样式信息 Javascript引擎:遇到js代码时,需要使用Javascript解释器，并使得js代码有调用DOM接口和CSSOM接口的能力 布局:结合CSS,计算出每个DOM对象的大小位置信息 绘图:将经过布局计算的DOM节点绘制成图像 以上重要组件组成了渲染引擎： 思考几个问题： 通过响应的内容，我们可以看到内容中还存在许多外联资源，浏览器是如何处理的？ 著名的优化:”css放在头部，js放在尾部”,为什么？ 浏览器在渲染之前或者之后还需要做那些事情 移动端的浏览器和pc端的浏览器是否相同 浏览器内核架构回答上一节 不同的外联资源，webkit中有不同的资源加载器。当浏览器解析到URL地址时，调用特定的资源加载器，如果不是特殊资源，加载过程不会阻碍渲染过程 一般来说css资源不会阻碍渲染过程，但Javascript资源在的浏览器中，会阻碍渲染过程的进行。如果放置在头部，渲染过程会暂停,造成”白屏”.但现代浏览器的优化已经做的很好了，preload，所以当渲染被阻塞时，浏览器会开启新的线程继续渲染。 渲染之前需要加载资源，渲染之后在DOM或者css变化后，重新进行布局计算和重渲染操作 功能基本相同，但所运用的操作系统不同，渲染机制有差异 内核架构根据上面的问题回答我们会发现，webkit仅仅包含渲染功能是不够的，因为它需要获取网络资源，支持不同的浏览器，支持不用的操作系统，同样还要包含调试工具。 所以我们应该给出一张更全的webkit架构图:虚线框表示该部分模块在不同浏览器使用webkit的实现是不一样的，实线框是基本一致的。 Chromium架构基于webkit内核就可以构建浏览器应用，了解著名的chromium浏览器对我们的web开发也有很多启发 几个问题 除去webkit内核完成的功能，浏览器的工作有哪些？ 进程是什么？ IPC是什么？ 线程是什么？ 线程同步是什么？ 现代浏览器的工作？ 资源管理 多页面管理：也就是多个标签页的管理 插件和扩展：如flash,油猴，chrome扩展程序 账户和同步 安全机制 多系统支持 进程和线程 进程：对CPU,主存，IO设备的抽象，操作系统对一个正在进行的程序的抽象 线程：组成进程的执行单元 进程通信：进程间传输数据（交换信息） 线程同步 进程通讯的方式线程同步的方式 Chromium的多进程架构chromium的模块：主要进程介绍： Browser进程：主进程,负责浏览器页面，页面管理等 render进程：渲染进程 NPAPI插件进程 GPU进程：当GPU硬件加速打开时才会创建 多进程架构的目的所在： 职责分离，故障范围小 隔离性 性能 javascript中的进程和线程 单线程 浏览器渲染原理总共分两步： 加载：加载渲染所必须的html代码 渲染：将html代码绘制成图像结果 加载资源加载机制资源加载器分为三类： 特定资源加载器：针对每种资源类型的特定加载器，仅加载某一种资源。对应设计模式中 的单例模式 缓存资源加载器：与常规的缓存逻辑相同，特定加载器先通过缓存资源加载器来查找是否有缓存资源，如果在资源缓存池中存在缓存资源，则取出以便使用；若不存在，发送请求给网络模块 通用资源加载器：由于加载资源大多属于网络请求，而网络请求的逻辑是可以被特定资源加载器所共享的，所以通用资源加载器只能负责通过网路获得目标资源的数据，但不负责进一步解析 资源缓存 page Cache：页面缓存 Memory Cache：内存缓存 Disk Cache:磁盘缓存 流程网络栈 确定请求类型，协议 判断是否需要建立网络连接 建立HTTP事务 建立TCP socket连接 套接字连接 预先加载 DNS预取 dns-prefetch 资源的预取 TCP preconnect TCP 相关请参考之前的网络课程 如何提高加载速度 合并请求：nginx模块，sprite雪碧图 移动端TCP请求建立慢 缓存:from cache(memory,disk),localstorage，本地缓存策略，HTTP头(结合业务) tcp 网络连接优化：tcp调优，HTTP/2,keep-alive 硬件：加大带宽，使用cdn(对象存储) 资源大小：gzip,webp，image压缩，cookie体积 预加载： dns预取 、多个cdn域名Chrome在同域名下读资源只能读5个 、异步读取js 渲染HTML 解释器解释过程资源的变换 字节流 字符流 Tokens 节点 DOM数 流程： 词法分析 XSSAuditor 语法分析 生成DOM数 词法分析通过HTMLTokenizer来进行词法分析 词法分析的任务是对输入字节流进行逐字扫描，根据构词规则识别单词和符号，分词 词法分析器的主要接口是nextToken()函数，调用者只需要将字符串传入，就会得到一个词语 注意，在这里并不涉及标签类型信息，这是之后语法分析的工作 CSS解释器Javascript引擎执行流程： 源代码 抽象语法数 字节码 解释器 JIT 本地代码 渲染 renderObject RenderLayer 布局计算 绘图无关上下文]]></content>
      <tags>
        <tag>浏览器渲染</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode插件]]></title>
    <url>%2F2018%2F08%2F29%2Fvscode%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Setting Sync 可同步包含的所有扩展和完整的用户文件夹 设置文件 快捷键设置文件 Launch File Snippets Folder VSCode 扩展设置 工作空间 为什么需要Settings Sync一开始不知道怎么备份vscode的配置,傻乎乎的把要用的插件抄下来,还有用户settings拷贝出来.每次换了电脑或者重装系统什么的都要重新备份.虽然来回调整的概率很低,但是突然哪天需要同步设置什么的就很麻烦了~至少我是在初期经常鼓捣这个编辑器,而且办公在家和公司是不同的设备~所以觉得还是很有必要的~ 步骤如下 安装插件并重启VSCODE就不用说了(安装VSCODE Settings Sync后重新加载) 重启后按快捷键 alt+shift+u (这里假设你第一次用) 它会弹出一个窗口对应的是github上面的创建个人gist的页面,如果未登录请先登录github.(github创建gist来存储设置) 保存后会生成一个key(请牢记token id,后面将会用到) 切回到vscode,他会有个输入区,就是存放刚才生成的key(输入刚才生成的key) 然后理论上他就开始对你本机的配置进行一个扫描上传了,上传完成后,他会弹出控制台提示备份(上传)插件成功 上传完成后会生成一个ID，要记下来ID和token key不同 接下来我们到另一台电脑上了下载配置.同样的先安装Settings Sync插件,并重新加载. 然后按快捷键alt+shift+d,就应该会弹出一个输入框,请在这里输入之前保存下来的token key 和 (GIST ID),回车后将会自动下载之前上传的配置. 那么下载完成后,你这台电脑修改了相关配置再次上传就好了.是不是感觉方便多了~ 其他的说明,如果在输入gist id写错了,读取不到的情况下,大概需要重置设置,按F1,输入sync,这里有重置选项.试试看~ (重置sync的gist配置信息等) 如果忘记token可以到一下地址查看token Win下：C:\Users\Administrator\AppData\Roaming\Code\User Mac下：~/Library/Application Support/Code/User/syncLocalSettings.json Linux下：~/.config/Code/User/syncLocalSettings.json进入目录后，找到 syncLocalSettings.json这个文件，查找token，并替换后面复制的值，就可以顺利进行同步配置信息了。 如果忘记gist id,可以到设置查看id 注意：(ID和key都要记下来)(恢复)插件需要用到 很重要!!! 建议上传到网盘 或者 笔记软件上 如果token无效，要在github上重新生成，先在原平台修改并生成新的gist-id，再到新平台做上述操作。https://gist.github.com/用户名/token值或gist-id值 可以查看相关数据； 还有些其他的功能例如自动上传下载等等,不是很常用,大家可以自行看看官方文档,基本的使用方法就是这样了,我写的如果有问题或者哪里不明白的可以留言- -. 插件地址：https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync]]></content>
      <tags>
        <tag>vscode</tag>
        <tag>vscode插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP]]></title>
    <url>%2F2018%2F08%2F08%2FTCP%2F</url>
    <content type="text"><![CDATA[深入理TCP/IP模型 网络模型最初是由各个互联网公司自己制定的，由于当时不规范，严重阻碍了互联网的发展，为了解决这个问题，国际标准化组织(OSI)制定了OSI模型,定义了互联网通信的标准,是设计和描述计算机网络通信的基本框架。]]></content>
      <tags>
        <tag>tcp</tag>
        <tag>http</tag>
        <tag>网路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel]]></title>
    <url>%2F2018%2F07%2F25%2Fbabel%2F</url>
    <content type="text"><![CDATA[Babel 是一个广泛使用的 ES6转码器，可以将 ES6 代码转为 ES5 代码 配置文件.babelrcpresets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。1234567891011121314# ES2015转码规则$ npm install --save-dev babel-preset-es2015# react转码规则$ npm install --save-dev babel-preset-react### 最新的规则npm install --save-dev babel-preset-stage 0-3# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 Plugin/Preset 排序 Plugin 会运行在 Preset 之前。 Plugin 会从第一个开始顺序执行。 Preset 的顺序则刚好相反(从最后一个逆序执行)。 babel-core如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块,一般在node代码中使用12345678var es6Code = 'let x = n =&gt; n + 1';var es5Code = require('babel-core') .transform(es6Code, &#123; presets: ['es2015'] &#125;) .code;// '"use strict";\n\nvar x = function x(n) &#123;\n return n + 1;\n&#125;;' babel-cliBabel提供babel-cli工具，用于命令行转码1234567891011121314151617# 转码结果输出到标准输出$ babel example.js# 转码结果写入一个文件# --out-file 或 -o 参数指定输出文件$ babel example.js --out-file compiled.js# 或者$ babel example.js -o compiled.js# 整个目录转码# --out-dir 或 -d 参数指定输出目录$ babel src --out-dir lib# 或者$ babel src -d lib# -s 参数生成source map文件$ babel src -d lib -s babel-nodebabel-cli工具自带一个babel-node命令，提供一个支持ES6的REPL环境。它支持Node的REPL环境的所有功能，而且可以直接运行ES6代码。1$ babel-node es6.js babel-registerbabel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。12require("babel-register");require("./index.js"); 需要注意的是，babel-register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。 babel-polyfill和runtime TransformBabel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy`、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign`）都不会转码。 函数和方法 Generator Set Map Array.from Array.prototype.includes polyfill 全局垫片(会污染全局变量) 为开发应用准备(平常项目) 包含core-js 和regenerate-runtime (提供async 语法编译后的运行时环境) 12npm install babel-polyfill --saveimport "babel-polyfill" runtime Transform 局部垫片(不会污染全局变量) 为开发框架准备(例如vue) 12npm install babel-plugin-transform-runtime --Save-devnpm install babel-runtime --save .babelrc的配置123456789101112&#123; "presets": [ ["@babel/preset-env",&#123; "targets":&#123; "browsers":["&gt; 1%"] &#125; &#125;] ], "plugins": [ "@babel/transform-runtime" ]&#125; 异同对于以下代码执行时1234const key='babel'const obj=&#123; [key]='foo'&#125; babel默认会编译成以下代码1234567891011function _defineProperty(obj, key, value) &#123; if (key in obj) &#123; Object.defineProperty(obj, key, &#123; value: value, enumerable: true, configurable: true, writable: true &#125;); &#125; else &#123; obj[key] = value; &#125; return obj;&#125;var key = 'babel';var obj = _defineProperty(&#123;&#125;, key, Object.assign(&#123;&#125;, &#123; key: 'foo' &#125;)); _defineProperty的帮助函数，但是这个帮助函数仅仅在当前模块中生效，因此其他模块中如果用到了同样的语法，编译后就会出现大量的重复代码。 babel-polyfillbabel-polyfill 是直接在原型链上增加方法,所以会污染全局变量和内置的对象原型 babel-runtimeBabel为了解决这个问题，提供了单独的包 babel-runtime 供编译模块复用工具函数。启用插件babel-plugin-transform-runtime 后，Babel 就会使用babel-runtime 下的工具函数，转译代码如下12345678910'use strict';var _defineProperty2 = require('babel-runtime/helpers/defineProperty');var _defineProperty3 = _interopRequireDefault(_defineProperty2);function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;var key = 'babel';var obj = (0, _defineProperty3.default)(&#123;&#125;, key, 'foo'); 但是 babel-runtime 不能转码实例方法，比如这样的代码：12'!!!'.repeat(3);'hello'.includes('h'); babel-preset-env babel-preset-latest： 支持现有所有ECMAScript版本的新特性，包括处于stage 4里的特性（已经确定的规范，将被添加到下个年度的）。 babel-preset-env 功能类似 babel-preset-latest，优点是它会根据目标环境选择不支持的新特性来转译。 实验性的属性（babel-preset-latest不支持的）需要手动安装配置相应的plugins或者presets。这样你再不需要 es20xx presets了。 问题： 为什么需要env? 大部分现代浏览器已经支持ES6的generators了，但是如果你设置了babel-preset-es2015，generator函数还是会被转译成复杂的ES5代码。其他配置 modules(string, 默认值: &quot;commonjs&quot;) 将ES6模块语法转换为另一种模块类型，可选值: 各种流行的模块化规范：”amd”、 “commonjs”、 “systemjs”、 “umd” 禁止转译：false include, exclude (Array of strings, 默认值: []) include 必须要转译的功能 (比如 覆盖有故障的本地功能)。跟单独启用相应插件是一样的。 exclude 禁止转译的功能 debug (boolean, default: false) 以下内容都会用console.log输出 : 目标环境 启用的transforms 启用的plugins 启用的polyfills useBuiltIns (boolean, 默认值: false) babel-preset-env可以实现基于特定环境引入需要的polyfill core-js， 根据需要引入ES5，ES6+标准方法的实现 安装 polyfill: npm install core-js –save 引入 polyfill: import “core-js”; babel-polyfill 包含core-js 和regenerate-runtime(提供 async语法编译后的运行时环境)。 安装 polyfill: npm install babel-polyfill –save 引入 polyfill: import “babel-polyfill”; 两种方法最终都会根据环境转译成特定的polyfill。 比如:12345import "core-js/modules/es7.string.pad-start";import "core-js/modules/es7.string.pad-end";import "core-js/modules/web.timers";import "core-js/modules/web.immediate";import "core-js/modules/web.dom.iterable"; note:在整个应用里只能引入一次polyfill，可以在 “main” 模块里一次引入。useBuiltIns 会使浏览器下载的代码变少 (最终打包的文件大小变小了)。但是不会节约内存， 因为polyfill本身只会安装缺少的部分。 基于TC39不同阶段的提案的Presets (stage-0，1，2，3等) 也是去除的候选，因为在这些statges中的标准是不断变化的。提案可以在2个月内改变。因此，直接引用一些实验性的plugins会是更好的选择。 stage 0 transform-do-expressions transform-function-bind stage 1 transform-class-constructor-call (启用) transform-export-extensions stage 2 syntax-dynamic-import transform-class-properties transform-decorators – 在提案更新中被禁用 (可以同时使用 legacy 转换,babel7默认添加到stage0中) stage 3 transform-object-rest-spread transform-async-generator-functions]]></content>
      <tags>
        <tag>node</tag>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mobx]]></title>
    <url>%2F2018%2F07%2F25%2Fmobx%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[promise详解]]></title>
    <url>%2F2018%2F07%2F23%2Fpromise%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[异步与同步 异步：所谓”异步”，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段,比如，在我们烧水时可以干很多事情,当水烧开后在用水洗脸。这种不连续的执行，就叫做异步。 同步:连续的执行,例如在烧水的过程中我们一直等待水烧开而不去干别的事情。 异步发展历史 callback Promise gengrator函数 async-await 高阶函数了解异步时，我们先了解一下高阶函数这个概念 高阶函数： 接收一个或者多个函数作为参数 输出一个函数 1234//判断数据类型 isTypefunction isType(type,content)&#123;return Object.prototype.toString.call(content)===`[object $&#123;type&#125;]`&#125; 偏函数–&gt; 预置参数1234567function isType(type)&#123; return function(content)&#123; return Object.prototype.toString.call(content)===`[object $&#123;type&#125;]` &#125;&#125;let isString=isType('String')isString('哈哈') 预置函数作为参数12345678910111213// loadsh _.afterfunction(times,callback)&#123; return function(--times==0)&#123; callback() &#125;&#125;let eat=after(3,function()&#123; console.log('饱了')&#125;)// 当函数执行三次之后，调用回调函数eat()eat()eat() callback123456789function read(callback)&#123; setTimeout(function()&#123; let result = 'zpfx'; callback(result); &#125;)&#125;read(function(data)&#123; console.log(data);&#125;); promise虽然callbake可以解决异步调用的问题,但是它也有诸多毛病 异步不支持try/catch,回调函数是在下一事件环中取出,所以一般在回调函数的第一个参数预置错误对象 回调地狱问题,异步多级依赖的情况下嵌套非常深，代码难以阅读的维护 多个异步在某一时刻获取所有异步的结果 结果不能通过return返回 为了解决回调地狱问题，提出了Promise对象，并且后来加入了ES6标准。Promise本意是承诺，在程序中的意思就是承诺我过一段时间后会给你一个结果 Promise的三种状态 Pending Promise对象实例创建时候的初始状态 Fulfilled 可以理解为成功的状态 Rejected 可以理解为失败的状态 先用promise解决第一个问题”回调地狱”12345678910111213// 1.txt =&gt; 2.txt// 2.txt =&gt; 我很帅let fs = require('fs');function read()&#123; fs.readFile('./1.txt','utf8',function(err,data)&#123; if(err) return console.log(err); fs.readFile(data,'utf8',function(err,data)&#123; if(err) return console.log(err); console.log(data); // 我很帅 &#125;) &#125;)&#125;read(); promise实现就轻松多了12345678910111213141516let fs = require('fs');function read(file)&#123; return new Promise(function(resolve,reject)&#123; fs.readFile(file,'utf8',function(err,data)&#123; if(err) return reject(err); resolve(data); &#125;) &#125;)&#125;read('./1.txt').then(function(data)&#123; return read(data);&#125;).then(function(data)&#123; console.log(data)&#125;).catch(function(err)&#123; console.log(err)&#125;); 当第一个then中返回一个promise，会将返回的promise的结果,传递到下一个then中。这就是比较著名的链式调用了 解决同步异步的返回结果，按照顺序 我们将多个异步请求的结果在同一时间进行汇总 1234567891011121314151617181920212223242526let fs=require('fs');let path=require("path")function after(time,callback)&#123;//可以缓存函数 当达到条件时执行 let arr=[]; return function(data)&#123; arr.push(data) if(--time===0)&#123; callback(arr); &#125; &#125;&#125;let out=after(3,function(arr)&#123; console.log(arr)&#125;)let resolve=(dir)=&gt;path.resolve(__dirname,dir)fs.readFile(resolve("1.txt"),"utf8",(err,data)=&gt;&#123;out(data)&#125;)fs.readFile(resolve("2.txt"),"utf8",(err,data)=&gt;&#123;out(data)&#125;)fs.readFile(resolve("3.txt"),"utf8",(err,data)=&gt;&#123; out(data)&#125;) 使用promise实现12345678910111213let fs = require('fs');function read(file)&#123; return new Promise(function(resolve,reject)&#123; fs.readFile(file,'utf8',function(err,data)&#123; if(err) return reject(err); resolve(data); &#125;) &#125;)&#125;Promise.all([read('1.txt'),read('2.txt')]).then(([template,data])=&gt;&#123; console.log(&#123;template,data&#125;)&#125;);// 不管两个promise谁先完成，Promise.all 方法会按照数组里面的顺序将结果返回 promise API 详解Promise.race 接受一个数组，数组内都是Promise实例,返回一个Promise实例，这个Promise实例的状态转移取决于参数的Promise实例的状态变化。当参数中任何一个实例处于resolve状态时，返回的Promise实例会变为resolve状态。如果参数中任意一个实例处于reject状态，返回的Promise实例变为reject状态。 12345Promise.race([read('1.txt'),read('2.txt')]).then(data=&gt;&#123; console.log(&#123;template,data&#125;)&#125;,(err)=&gt;&#123; console.log(err)&#125;); Promise.resolve返回一个Promise实例，这个实例处于resolve状态123Promise.resolve('成功').then(data=&gt;&#123; console.log(data);&#125;); Promise.reject返回一个Promise实例，这个实例处于reject状态12345Promise.reject('失败').then(data=&gt;&#123; console.log(data); &#125;,err=&gt;&#123; console.log(err); &#125;) Generator我们发现Promise已经可以解决了异步编程问题,但是仍然不够优雅,我们更希望编写异步代码能够像同步代码一样简洁。 genrator 函数要用* 来比标识，yield(暂停产出 ) 他会将函数分割出好多个部分，调用一次next就会向下继续执行 返回结果是一个迭代器，迭代器有一个next方法 123456789101112131415161718192021// 迭代器的实现// 迭代器 就是有next方法的，每次调用后都会返回一个done和value的属性function read(arrs)&#123; let index=0;//默认先迭代第一项 let len=arrs.length; return &#123; next()&#123; return&#123; value:arrs[index], done:index++===len?true:false &#125; &#125; &#125;&#125;let it=read(['react','vue','angular']);let flag=true;do&#123;let &#123;done,value&#125;=it.next();flag=done;console.log(value)&#125;while(!flag) generator的用法123456789101112function* read()&#123; console.log(1); let a=2* (yiled '222') console.log(a) let b=yiled 9; console.log(b) return b;&#125;let it=read()console.log(it.next('213'))//1console.log(it.next('100'))//200console.log(it.next('100'))//100 yield 后面跟着的是value的值 yield 等号前面的是我们当前调用next传进来的值 第一次next传值是无效的 1234567891011// 异步 generator 主要和promise搭配使用let bluebird=require("bluebird")let fs=require("fs")let path=require("path");let resolve=(dir)=&gt;path.resolve(__dirname,dir)let read=bluebird.promisify(fs.readFile)function *r()&#123; let content1=yield read(resolve("./1.txt"),"utf8"); let content2=yield read(resolve(content1),"utf8") return content2;&#125; 不使用co这类的迭代库实现1234567//迭代库let it=r();it.next().value.then(function(data)&#123;//2.txt it.next(data).value.then(function(data)&#123; console.log(it.next(data).value) &#125;)&#125;) co有node大神tj写的co库，可以自动的将generator进行迭代1234let co=require("co");co(r()).then((data)=&gt;&#123; console.log(data)&#125;) 手写co库123456789101112131415161718function co(it)&#123;//it是迭代器//返回promisereturn new Promise(function(resolve,reject)&#123; // 考虑到是异步调用，一般用递归实现，while实现的是同步调用 function next(d)&#123; let &#123;value,done&#125;=it.next(d); if(!done)&#123; value.then(function(data)&#123; next(data) &#125;,reject)//如果抛出异常，就立马抛出 &#125;else&#123; resolve(value) &#125; &#125; next()&#125;)&#125; async/await - 异步的终极实现 async和await就是generator和co的语法糖,使用async关键字，你可以轻松地达成之前使用生成器和co函数所做到的工作 用async来修饰函数 async 需要陪await await只能跟promise 123456789101112131415async function r()&#123; try&#123; let contetn1=await read(resolve("1000.txt"),"utf8") let contetn2=await read(resolve(contetn1),"utf8") &#125;catch(e)&#123;//如果出错会catch console.log('e',e) &#125; return 1000;&#125;//async函数返回的是promise r().then((data)=&gt;&#123; console.log(data)&#125;).catch(err=&gt;&#123; console.log(err)&#125;) async/await解决的问题有哪些 回调地狱 2.并发执行异步，在同一时刻同步返回结果 promise.all 3.解决了返回值的问题 4.可以实现try/catch Q库 我们发现无论是generator还是async/await都离不开promise,我们在介绍几个有关promise的库。 12345678910111213141516//需要下载npm install qlet Promise=require("./Promise")let Q=require("q")function read(url)&#123;return new Promise(function(resolve,reject)&#123; require("fs").readFile(url,'utf8',function(err,data)&#123; if(err)reject(err); resolve(data) &#125;)&#125;)&#125;Q.fcall(function()&#123; return 100&#125;).then(function(data)&#123; console.log(data)&#125;) blueBird blueBird中有两个常用的方法一个叫promisify另一个叫promisifyAll1234567891011function promisify(fn)&#123;//promise化 将回调函数在内部进行处理return function(...arg)&#123; return new Promise(function(resolve,reject)&#123; fn(...arg,function(err,data)&#123; if(err)reject(err) resolve(data) &#125;) &#125;)&#125;&#125;promisify(fs.readFile)(url,"utf8").then() promisifyAll(fs)将所有的方法全部增加一个promise化123456789function(obj)&#123; Object.keys(obj).forEach(function(value)&#123; if(typeof obj[key]==='function')&#123; obj[`$&#123;key&#125;Async`]=promisify(obj[key]) &#125; &#125;)&#125;promisifyAll(fs)fs.readAsync(url,"utf8").then() 实现Promise Promise是一个类,需要传递一个函数,这个函数我们称之为执行函数,函数中有两个参数resolve和reject他们也是函数，调用resolve表示成功，调用reject表示失败 pending（进行中）、fulfilled（成功）、rejected（失败) 成功就不会再调用失败,默认状态是等待状态 then是原型上的一个方法接收两个参数分别是成功的回调和失败的回调 调用resolve后会执行成功的回调，调用reject后会执行失败的回调1234567891011121314151617181920212223242526272829303132333435function Promise(excutor)&#123;//excutor是执行函数 this.status='pending'//初始状态是pending this.value=undefined;//存储成功的值 this.reason=undefined;//存储失败原因 function resolve(value)&#123;// 只有再pending才能转换成功态 if(this.status==='pending')&#123; this.value=value; this.status="fulfilled"; &#125; &#125; function reject(err)&#123; // 只有再pending才能转换失败态 if(this.status==='pending')&#123; this.reason=err; this.status="rejected"; &#125; &#125; try&#123; excutor(resolve,reject)// executor中需要传入resolve和reject &#125;catch(e)&#123; // 如果executor执行发生异常，表示当前的promise是失败态 reject(e) &#125; &#125;Promise.prototype.then(function(onFufilled,onRejected)&#123; if(this.status==='fulfilled')&#123; //成功调用回调函数 onFufilled(this.value) &#125; if(this.status==='rejected')&#123; //失败调用回调函数 onRejected(this.reason) &#125;&#125;) 异步Promise在new Promise时内部可以写异步代码,并且产生的实例可以then多次,我们可以先将then中的成功的回调和失败的回调存到数组内，当成功时调用成功的数组即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function Promise(excutor)&#123;//excutor是执行函数 this.status='pending'//初始状态是pending this.value=undefined;//存储成功的值 this.reason=undefined;//存储失败原因+ this.onFulfilledcallback=[];///存放成功的回调+ this.onRejectedCallback = []; //存放then失败的回调 function resolve(value)&#123;// 只有再pending才能转换成功态 if(this.status==='pending')&#123; this.value=value; this.status="fulfilled"; // 依次执行成功的回调+ this.onFulfilledcallback.forEach((value)=&gt;&#123;+ value()+ &#125;) &#125; &#125; function reject(err)&#123; // 只有再pending才能转换失败态 if(this.status==='pending')&#123; this.reason=err; this.status="rejected";+ this.onRejectedCallback.forEach((value)=&gt;&#123;+ value()+ &#125;) &#125; &#125; try&#123; excutor(resolve,reject)// executor中需要传入resolve和reject &#125;catch(e)&#123; // 如果executor执行发生异常，表示当前的promise是失败态 reject(e) &#125; &#125;Promise.prototype.then(function(onFufilled,onRejected)&#123; if(this.status==='fulfilled')&#123; //成功调用回调函数 onFufilled(this.value) &#125; if(this.status==='rejected')&#123; //失败调用回调函数 onRejected(this.reason) &#125; if(this.status==="pending")&#123; // 如果是等待态,就将成功和失败的回调放到数组中 //成功调用回调函数 + this.onFulfilledcallback.push(()=&gt;&#123;+ onFufilled(this.value)+ &#125;) //失败调用回调函数 + this.onRejectedCallback.push(()=&gt;&#123;+ onRejected(this.reason)+ &#125;) &#125;&#125;) Promise链式调用promise实现链式调用,返回的并不是this而是一个新的promise,因为:如果当前promise已经进入成功了的回调，回调中发生了异常如果返回的仍是当前的promise那么状态无法更改到失败态！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function Promise(excutor)&#123;//excutor是执行函数 this.status='pending'//初始状态是pending this.value=undefined;//存储成功的值 this.reason=undefined;//存储失败原因 this.onFulfilledcallback=[];///存放成功的回调 this.onRejectedCallback = []; //存放then失败的回调 function resolve(value)&#123;// 只有再pending才能转换成功态 if(this.status==='pending')&#123; this.value=value; this.status="fulfilled"; // 依次执行成功的回调 this.onFulfilledcallback.forEach((value)=&gt;&#123; value() &#125;) &#125; &#125; function reject(err)&#123; // 只有再pending才能转换失败态 if(this.status==='pending')&#123; this.reason=err; this.status="rejected"; this.onRejectedCallback.forEach((value)=&gt;&#123; value() &#125;) &#125; &#125; try&#123; excutor(resolve,reject)// executor中需要传入resolve和reject &#125;catch(e)&#123; // 如果executor执行发生异常，表示当前的promise是失败态 reject(e) &#125; &#125;Promise.prototype.then(function(onFufilled,onRejected)&#123;+ let promise2; // promise2为then调用后返回的新promise if(this.status==='fulfilled')&#123; //成功调用回调函数 + promise2=new Promise(function(resolve,reject)&#123;+ onFufilled(this.value)+ &#125;) &#125; if(this.status==='rejected')&#123; //失败调用回调函数 + promise2=new Promise(function(resolve,reject)&#123;+ onRejected(this.reason)+ &#125;) &#125; if(this.status==="pending")&#123; // 如果是等待态,就将成功和失败的回调放到数组中 //成功调用回调函数 + new Promise((resolve,reject)=&gt;&#123; this.onFulfilledcallback.push(()=&gt;&#123; onFufilled(this.value) &#125;) //失败调用回调函数 this.onRejectedCallback.push(()=&gt;&#123; onRejected(this.reason) &#125;) &#125;) + &#125;+ return promise2&#125;) resolvePromisethen返回的结果可能是promise和value或者object123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107function Promise(excutor)&#123;//excutor是执行函数 this.status='pending'//初始状态是pending this.value=undefined;//存储成功的值 this.reason=undefined;//存储失败原因 this.onFulfilledcallback=[];///存放成功的回调 this.onRejectedCallback = []; //存放then失败的回调 function resolve(value)&#123;// 只有再pending才能转换成功态 if(this.status==='pending')&#123; this.value=value; this.status="fulfilled"; // 依次执行成功的回调 this.onFulfilledcallback.forEach((value)=&gt;&#123; value() &#125;) &#125; &#125; function reject(err)&#123; // 只有再pending才能转换失败态 if(this.status==='pending')&#123; this.reason=err; this.status="rejected"; this.onRejectedCallback.forEach((value)=&gt;&#123; value() &#125;) &#125; &#125; try&#123; excutor(resolve,reject)// executor中需要传入resolve和reject &#125;catch(e)&#123; // 如果executor执行发生异常，表示当前的promise是失败态 reject(e) &#125; &#125;Promise.prototype.then(function(onFufilled,onRejected)&#123; let promise2; // promise2为then调用后返回的新promise if(this.status==='fulfilled')&#123; //成功调用回调函数 promise2=new Promise(function(resolve,reject)&#123; // x是then返回的结果 let x = onFufilled(this.value) resolvePromise(promise2,x,resolve,reject) &#125;) &#125; if(this.status==='rejected')&#123; //失败调用回调函数 promise2=new Promise(function(resolve,reject)&#123; let x= onRejected(this.reason) resolvePromise(promise2,x,resolve,reject) &#125;) &#125; if(this.status==="pending")&#123; // 如果是等待态,就将成功和失败的回调放到数组中 //成功调用回调函数 new Promise((resolve,reject)=&gt;&#123; this.onFulfilledcallback.push(()=&gt;&#123; let x=onFufilled(this.value) resolvePromise(promise2,x,resolve,reject) &#125;) //失败调用回调函数 this.onRejectedCallback.push(()=&gt;&#123; let x= onRejected(this.reason) resolvePromise(promise2,x,resolve,reject) &#125;) &#125;) &#125; return promise2&#125;)function resolvePromise(p2,x,resolve,reject)&#123; // 处理结果时,尽可能完善一些 //如果then返回的值和p2是同一个值，规范要求抛出一个类型异常 if(p2===x)&#123; return reject(new TypeError("循环引用")) &#125; let called;//表示是否调用成功或者失败 // 可能是一个thenable(带有then方法)对象 if(x!==null &amp;&amp; (typeof x === 'object' || typeof x==='function'))&#123; // x可能是promise try&#123;// 如果用defineProperty定义的then方法获取时可能会有异常 let then=x.then; // 如果then是函数,说明是promise,我们要让promse执行 if(typeof then==='function')&#123; then.call(x,function(y)&#123; if(called) return; called=true; //y可能还是一个Promise，再去解析知道返回的是一个普通值 resolvePromise(promise2,y,resolve,reject) &#125;,function(err)&#123; if(called) return; called=true; //失败的回调 reject(err) &#125;) &#125;else&#123; // 不是函数,x就是一个普通的对象,直接成功即可 resolve(x); &#125; &#125;catch(e)&#123; if(called) return; called=true; reject(e) &#125; &#125;else&#123; // 是普通值直接调用成功 resolve(x); &#125;&#125; then中的方法异步执行为了保证程序执行的一致性,规范中要求then中的方法必须在下一队列中执行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071Promise.prototype.then(function(onFufilled,onRejected)&#123; let promise2; // promise2为then调用后返回的新promise if(this.status==='fulfilled')&#123; //成功调用回调函数 promise2=new Promise(function(resolve,reject)&#123; // x是then返回的结果 setTimeout(()=&gt;&#123; try&#123; let x = onFufilled(this.value) resolvePromise(promise2,x,resolve,reject) &#125;catch(e)&#123; reject(e); &#125; &#125;) &#125; &#125;) &#125; if(this.status==='rejected')&#123; //失败调用回调函数 promise2=new Promise(function(resolve,reject)&#123; setTimeout(()=&gt;&#123; try&#123; let x= onRejected(this.reason) resolvePromise(promise2,x,resolve,reject) &#125;catch(e)&#123; reject(e); &#125; &#125;) &#125;) &#125; if(this.status==="pending")&#123; // 如果是等待态,就将成功和失败的回调放到数组中 //成功调用回调函数 new Promise((resolve,reject)=&gt;&#123; this.onFulfilledcallback.push(()=&gt;&#123; setTimeout(()=&gt;&#123; try&#123; let x = onFufilled(this.value) resolvePromise(promise2,x,resolve,reject) &#125;catch(e)&#123; reject(e); &#125; &#125;) &#125;) //失败调用回调函数 this.onRejectedCallback.push(()=&gt;&#123; setTimeout(()=&gt;&#123; try&#123; let x = onRejected(this.value) resolvePromise(promise2,x,resolve,reject) &#125;catch(e)&#123; reject(e); &#125; &#125;) &#125;) &#125;) &#125; return promise2&#125;) 值的穿透在规范中定义then函数可以不传参,不传参默认会将成功的结果和失败的结果继续向下传递1234567Promise.prototype.then = function (onFufilled, onRejected) &#123;+ onFufilled = typeof onFufilled === 'function'?onFufilled:function(value)&#123;+ return value+ &#125;+ onRejected = typeof onRejected === 'function'?onRejected:function(err)&#123;+ throw err+ &#125; resolve接收promise12345678function resolve(value) &#123; // 调用resolve 会传入为什么成功+ if (value !== null &amp;&amp; (typeof value === 'object' || typeof value === 'function')) &#123;+ if(typeof value.then === 'function')&#123;+ // 将当前promise成功的结果再次传回resolve函数中+ return value.then(resolve,reject);+ &#125;+ &#125; if (self.status === 'pending') &#123; Promise.all1234567891011121314151617Promise.all=function(promises)&#123; let arrs=[];//返回的结果 let ind=0;//表示成功了几次 return new Promise(function(resolve,reject)&#123; function processDate(index,y)&#123; arr[index]=y; if(++ind===promises.length)&#123; resolve(arrs) &#125; &#125; for(let i=0;i&lt;len;i++)&#123; promises[i].then(function(y)&#123; processDate(i,y) &#125;,reject) &#125; &#125;)&#125; Promose.race12345Promise.race=function(promises)&#123; for(let i=0;i&lt;promises.length;i++)&#123; promises[i].then(resolve,reject) &#125;&#125; Promise.resolve12345Promise.resolve=function(data)&#123; return new Promise(function(resolve,reject)&#123; resolve(data) &#125;)&#125; Promise.reject12345Promise.reject = function(reason)&#123; return new Promise(function(resolve,reject)&#123; reject(reason); &#125;);&#125; catch123Promise.prototype.catch=function(fn)&#123; return this.then(null,fn)&#125;]]></content>
      <tags>
        <tag>promise</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css工程化]]></title>
    <url>%2F2018%2F07%2F10%2Fcss%E5%B7%A5%E7%A8%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[关注点 组织 优化 构建 维护 postcss postcss本身只有解析能力–可以检测css代码是否正确 各种神奇的特性全靠插件 目前至少有200多个插件 插件 import 模块合并 autoprefixier 自动加前缀 cssnano 压缩代码 cssnext 使用css新特性 precss 变量、mixin、循环等 BrowsersList cssnext precss 变量 条件 循环 mixin Extend import 属性值引用 postcss支持的构建工具 cli 命令行工具 webpack post-loader Gulp gulp-postcss Grunt grunt-postcss Rollup rollup-postcss … webpack js是整个应用的核心入口 一切资源均有js管理依赖 一切资源均有webpack打包 webpack和css css-loader 将css变成js style-loader将js样式插入head extractTextPlugin 将css从js中提取出来 css modules 解决css命名冲突的问题 less-loader sass-loader 各类预处理器 postcss-loader Postcss处理 问题 如何解决css模块化的问题 Less Sass等css预处理器 Postcss插件（postcss-import/press等） webpack处理css(css-loader+style-loader) postcss可以做什么？ 取决于插件可以做什么 autoprefixer cssnext precss 等 兼容性处理 import模块合并 css语法检查 兼容性检查 压缩文件 css modules是做什么的，如何使用 解决类名冲突问题 使用postcss或者webpack等构建工具进行编译 在HTML模板中使用编译过程产生的类名 为什么使用js来引用、加载css js作为入口、管理资源有天然的优势 将组件结构、样式、行为封装到一起，增加内聚 可以做更多处理（webpack）]]></content>
      <tags>
        <tag>css</tag>
        <tag>css工程化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css效果]]></title>
    <url>%2F2018%2F07%2F10%2Fcss%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[效果属性 这个效果怎么实现？ css最出彩的部分 box-shadow text-shadow border-radius background clip-path box-shadow 营造层次感(立体感) 充当没有宽度的边框 特殊效果 相当于元素的复制,可以制作一个div画出炫酷的效果text-shadow 立体感 印刷品质感 border-radius 圆角矩形 圆形 半圆/扇形 一些奇怪的角角 background 纹理、图案 渐变 雪碧图动画 背景图尺寸适应 clip-path 按路径对容器进行裁剪 常见几何图形 自定义路径 原容器的大小不变,可以做容器内动画 3d 变换 变换 transform 在3d空间中进行变换 问题 如何用一个div画xxx box-shadow无限投影 ::before ::after 如何产生不占空间的边框 outline box-shadow 如何实现圆形元素(头像) border-radius:50%; 如何实现ios图标的圆角 clip-path:(svg) 如何实现半圆、扇形等图形 border-radius 组合： 有无边框 边框粗细 圆角半径 如何实现背景图居中显示/不重复/改变大小 background-position background-repeat background-size(cover/contain) 如何平移/放大一个元素 transform:translateX(100px) transform:scale(2) 如何实现3D效果 perspective:500px; transform-style:preserve-3d transform:translate rotate…]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
        <tag>css效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css动画]]></title>
    <url>%2F2018%2F07%2F09%2Fcss%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[动画的原理 视觉暂留作用 画面逐渐变化 动画的作用 愉悦感 引起注意 反馈 掩饰 css中的动画类型 transition补间动画 keyframe关键帧动画 逐帧动画 补间动画 位置- 平移（left/right/margin/transform） 方位-旋转(transform) 大小-缩放（transform） 透明度（opacity） 其他-线性变换（transform） timing(easing) 定义动画进度和时间的关系 关键帧动画 相当于多个补间动画 与元素状态的变化无关 定义更加灵活 逐帧动画 适用于无法补间计算的动画 资源较大 使用steps() 指定关键帧之间有多少个动画 问题 css的动画实现方式有几种？ transition keyframes(animation) 过渡动画和关键帧动画的区别 过渡动画需要有状态的变化 关键帧动画不需要状态的变化 关键帧动画能控制更精细 如何实现逐帧动画 使用关键帧动画 去掉补间(steps) css动画的性能 性能不坏 部分情况下优于JS 但是JS可以做到更好 部分高危属性 box-shadow等]]></content>
      <tags>
        <tag>css</tag>
        <tag>css动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML汇总]]></title>
    <url>%2F2018%2F07%2F09%2FHTML%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[HTML常见元素head区的元素(页面相关资源、信息描述) meta title style link script base body区的元素 div/section/article/aside/header/footer p span/em/strong table/thead/tbody/tr/td ul/ol/li/dl/dt/dd a form/input/select/textarea/button 重要元素123456&lt;!-- 页面字符集 --&gt; &lt;meta charset="utf-8"&gt; &lt;!-- 以iphone为例，如果不指定viewport的话，视图（viewport）的默认宽度为980px,加viewport来适配移动端 --&gt; &lt;meta name="viewport" content="width=device-width,iniial-scale=1.0,maximum-scale=1.0,user-scalable=no"&gt; &lt;!-- 指定基础路径 页面中路径会以该路径为基准计算 --&gt; &lt;base href="/"&gt; viewport实例 重要属性 a[href,target] img[src,alt] table td[colspan,rowspan] form[target,method.enctype] input[type,value] button[type] select&gt;option[value] label[for] 如何理解html html”文档” 描述文档的”结构” 有区块和大纲 html版本 HTML4/4.0.1(SGML) XHTML(XML) HTML5 检查页面是否符合标准 HTML5新增内容 新区块标签 section article nav aside 表单增强 日期、时间、搜索 表单验证 Placeholder 自动聚焦 新增语义 header/footer头尾 section/article区域 nav 导航 aside 不重要内容 em/strong强调 i–&gt;icon HTML元素分类 按默认样式分 块级 block 行内 inline inline-block 按内容分 HTML元素嵌套关系 块级元素可以包含行内元素 块级元素不一定能包含块级元素,例如p “行内元素一般不能不含块级元素”,例如a 为什么a&gt;div是合法的？ 嵌套关系来自于内容分类和Content module 不一定合法，根据html5文档a标签包裹块级元素时，会将a元素变成透明的，看包裹a元素的标签是块级元素还是行内元素，例如： 123456&lt;body&gt;&lt;!-- 合法，应为body包裹a元素，是块级元素 --&gt;&lt;a&gt;&lt;div&gt;2121221&lt;/div&gt;&lt;/a&gt;&lt;!-- 不合法 --&gt;&lt;p&gt;&lt;a&gt;&lt;div&gt;2121221&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;&lt;/body&gt; HTML元素默认样式 默认样式的意义 默认样式带来的问题 css Reset 问题？ doctype的意义是什么？ 让浏览器以标准模式渲染 让浏览器知道元素的合法性 HTML XHTML HTML5的关系 HTML属于SGML XHTML属于XML,是HTML进行XML严格化的结果 HTML5不属于SGML或XML,比XHTML宽松 HTML5有什么变化 新的语义化元素 表单增强 新的API(离线、音视频、图形、实时通信、本地存储、设备能力) 分类和嵌套变更 em和i有什么区别？ em是语义化的标签，表强调 i 是纯样式的标签，表斜体 HTML5中i不推荐使用，一般用作图标 语义化的意义是什么？ 开发者容易理解 机器容易理解结构（搜索、读屏软件） 有助于SEO semantic microdata 那些元素可以自闭合 表单元素input 图片 img br、hr meta、link HTML和DOM的关系 HTML是”死”的 DOM是由HTML解析而来的，是活的 JS可以维护DOM property和attribute的区别 attribute是“死”的 property是“活”的 attribute的改变不会影响property，反之相同1234567&lt;!-- attribute --&gt;&lt;input type="text" value="1"&gt; //&lt;script&gt;$0.value="1"//property$0.setAttribute("value",'23')$0.value //1&lt;/script&gt; form的作用有哪些？ 直接提交表单 使用submit/reset按钮 便于浏览器保存表单 第三方库可以整体提取值 第三库可以进行表单验证]]></content>
      <tags>
        <tag>HTML</tag>
        <tag>HTML汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架中的css]]></title>
    <url>%2F2018%2F07%2F06%2F%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84css%2F</url>
    <content type="text"><![CDATA[Angular Vue React 三大框架 Angular Vue 内置样式集成 React 一些业界实践 Angular Angular.js(1.x) 没有样式集成能力 Angular (2+) 提供了样式封装能力 与组件深度集成 ShadowDOM 逻辑上一个DOM 结构上存在子集结构 Scoped css 限定了范围的css 无法影响外部元素 外部样式一般不影响内部 可以通过/deep/或&gt;&gt;&gt;穿透 模拟scoped css (兼容性差) 方案1：随机选择器(不支持) 方案2：随机属性 &lt;div abcdefg&gt; div[abcdefg]{} vue中模拟Scoped css 随机选择器 css modules 随机属性 &lt;div abcdefg&gt; div[abcdefg]{} react 官方没有集成方案 社区方案众多 css modules (babel)react-css-modules styled components styled jsx]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
        <tag>框架中的css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css框架bootstarp]]></title>
    <url>%2F2018%2F07%2F06%2Fcss%E6%A1%86%E6%9E%B6bootstarp%2F</url>
    <content type="text"><![CDATA[什么是bootstrap? 一个css框架 twitter出品 提供通用基础样式 Bootstrap 4 兼容IE10+ 使用flexbox布局 抛弃Nomalize.css 提供布局和reboot版本 Bootstrap主要做什么？ 基础样式 常用组件 js插件 Bootstrap js组件 用于组件交互 dropdown(下拉) modle(弹框) … 基于jQuery poper.js bootstrap.js 使用方式： 基于data-*属性 基于js-api bootstrap响应式布局bootstrap在不同的分辨率下有不同的分配 bootstrap的优缺点 优点：css代码结构合理 现成的样式可以直接用 缺点：定制较为繁琐 体积大 boostrap如何实现响应式布局 原理：通过media query设置不同分辨率的class 使用：为不同分辨率选择不同的网格class bootstrap 定制方法 使用css同名类覆盖 修改源码重新构建 引用scss源文件 –&gt; 修改变量 (可以按需加载,对bootstrap的结构要了解)]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css预处理器]]></title>
    <url>%2F2018%2F07%2F05%2Fcss%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[什么是预处理器 基于css的另一种语言 通过工具编译成css 添加了很多css不具备的特性 能提升css文件的组织 常见的css预处理器 less(Node.js) sass (Ruby有Node版本)(node-sass 是c++写的 安装有点复杂) 预处理器的作用 帮助更好地组织css代码 提高代码的复用率 提升可维护性 提供的功能 嵌套– 反映层级和约束 变量和计算–减少重复代码 extend和Mixin— 代码片段 循环– 适用于复杂的有规则的样式 import– css文件模块化 css预处理器框架 sass - Compass less -Lesshat/EST 提供现成的mixin 类似js类库 封装常用功能 预处理其的有缺点 优点： 提高代码的复用率和可维护性 缺点： 需要引入编译过程和学习成本高 EST est 提供了一系列方便快捷的 mixin 问题：现阶段是否推荐使用预处理器 除了预处理器，css工程化已经发展起来了，对于css的提升可以有其他手段]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
        <tag>预处理器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node深研]]></title>
    <url>%2F2018%2F06%2F26%2Fnode%E6%B7%B1%E7%A0%94%2F</url>
    <content type="text"><![CDATA[node概念node是单线程是指的主线程是单线程的 node工作原理 非node多线程服务器工作原理 node主线程工作原理 Node 解决了什么Node 的首要目标是提供一种简单的，用于创建高性能服务器的开发工具 Web 服务器的瓶颈在于并发的用户量，对比 Java 和 Php 的实现方式Node在处理高并发，I/O 密集场景有明显的性能优势 高并发,是指在同一时间并发访问服务器 I/O 密集指的是文件操作、网络操作、数据库,相对的有 CPU 密集,CPU 密集指的是逻辑处理运算、压缩、解压、加密、解密 Web 主要场景就是接收客户端的请求读取静态资源和渲染界面,所以 Node 非常适合 Web 应用的开发。 线程进程是操作系统分配资源和调度任务的基本单位，线程是建立在进程上的一次程序运行单位，一个进程上可以有多个线程。 js线程、ui线程这两个线程是互斥的,目的就是为了保证不产生冲突 ui线程会把更改放到队列中，当js线程空闲下来，ui线程在继续渲染 webworker 多线程 他和js主线程不是平级的，主线程可以控制webworker,webworker不能操作dom,document,window123456789101112131415&lt;!-- 文件1 --&gt;onmessage=function(e)&#123;let sum=0;for(let i=0;i&lt;e.data;i++)&#123; sum+=i;&#125;postMessage(sum)&#125;&lt;!-- 页面主线程 --&gt;let worker=new Worker('./worker.js')//把内容发给 工作线程，工作线程可以把结果丢回来worker.postMessage(100)worker.onmessage=function(e)&#123; console.log(e.data)&#125; global 在浏览器端 全局作用域我们通过window访问 我们可以直接在node中访问global1234567// 在浏览器端var a=1;window.a//1// 在服务器端var a=1;global.a//undefined 原因：node在执行的时候,为了实现模块增加了一个闭包 控制台 在Node.js中，使用console对象代表控制台(在操作系统中表现为一个操作系统指定的字符界面，比如 Window中的命令提示窗口)。 123456// 标准输出console.log('log')console.info('info')// 错误输出console.error('error')console.warn('warn') 当我们执行以下语句时,1.log文件中仅仅只有标准输出1node node1.js&gt; 1.log 只有我们执行以下语句时,才能将错误输出添加到1.log中。标准输出用1表示,错误输出用2表示1node node1.js &gt; 1.log 2&gt;&amp;1 默认有些属性是隐藏的12console.dir(Array.prototype)//[]console.dir(Array.prototype,&#123;showHidden:true&#125;)//可以显示隐藏属性 time和timeEnd中的内容是一对,名字相同时才能打印出两端时间的间隔12345console.time('label')for(var i=0;i&lt;10000;i++)&#123;&#125;console.timeEnd('label') 断言 断言有错误抛出一个AssertionError 单元测试mocha,kamra 断言库 chai, TDD, BDD, DDD持续继承,测试覆盖率 node 提供一个模块 asset1console.assert((1+1)===2,'error') 其他属性 process进程 argv后续执行时可能会传递参数 http-server --port 3000 pid 进程id 端口占用的情况 任务管理器 lsof -i :8080,kill -9 id号 chdir change directory 工作目录 cwd current working directory 当前工作目录 nextTick 微任务 stdout: [Getter], stderr: [Getter], stdin: [Getter], Buffer 存储文件内容 二进制 setImmediate 设置立即 setInterval setTimeout process.cwd与_dirname的区别 process.cwd表示当前工作目录,就是代码执行目录 __dirname 这个属性不是global上的，指代的是当前文件所在的文件夹,不会更改 Event Loop详解要探究Event Loop，就要先明白两个概念 JS是单线程的JavaScript语言最大特点就是单线程，但是这里的单线程指的是主线程是单线程的。那为什么js要单线程呢？因为，JS主要用于操作DOM，如果是有两个线程，一个在DOM上添加内容，一个在DOM上删除内容，此时浏览器该以哪个为准呢？所以为了避免复杂性，JavaScript从诞生起就是单线程的。 同步和异步 &amp;&amp; 阻塞非阻塞 阻塞和非阻塞指的是调用者的状态，即是等待结果的状态，等待的过程干不了别的，那就是调用者被阻塞了 同步和异步指的是被调用者是如何通知的,即是消息的通知方式 堆、栈、队列 堆（heap）是指程序运行时申请的动态内存，在JS运行时用来存放对象。 栈（stack）遵循的原则是“先进后出”，JS中的基本数据类型与指向对象的地址存放在栈内存中，此外还有一块栈内存用来执行JS主线程–执行栈（execution context stack），此文章中的栈只考虑执行栈。我们可以通过console.trace()查看栈的执行顺序 队列（queue）遵循的原则是“先进先出”，JS中除了主线程之外还存在一个“任务队列”（其实有两个，后面再详细说明）。 任务队列因为JavaScript是单线程的。就意味着所有任务都需要排队，前一个任务结束，后一个任务才能执行。前一个任务耗时很长，后一个任务也得一直等着。但是IO设备（比如ajax网络请求）很慢，CPU一直初一显得状态，这样就很不合理了。所以，其实主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。于是有了同步任务和异步任务。 同步任务是指在主线程上执行的任务，只有前一个任务执行完毕，下一个任务才能执行。 异步任务是指不进入主线程，而是进入任务队列（task queue）的任务，只有主线程任务执行完毕，任务队列的任务才会进入主线程执行。 浏览器中 Event Loop 主线程运行的时候产生堆（heap）和栈（stack） 栈中的代码调用各种外部API，它们在&quot;任务队列&quot;中加入各种事件（click，load，done） 只要栈中的代码执行完毕，主线程就会去读取&quot;任务队列&quot;，将队列中的事件放到执行栈中依次执行。 主线程继续执行，当再调用外部API时又加入到任务队列中，等主线程执行完毕又会接着将任务队列中的事件放到主线程中。 上面整个过程是循环不断的。 node 中的 Event Loop node是异步 、非阻塞i/o的，是用libuv(通过多线程和阻塞的i/o)实现的。 我们写的js代码会交给v8引擎进行处理解析。 代码中可能会调用nodeApi,node会交给libuv库处理 libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。 libuv是通过阻塞i/o和多线程实现了异步io的 通过事件驱动的方式,将结果放到事件队列中,最终交给我们的应用。 除了setTimeout和setInterval这两个方法，Node.js还提供了另外两个与”任务队列”有关的方法：process.nextTick和setImmediate。 微任务 &amp;&amp; 宏任务（队列） 微任务 process.nextTick, 原生 Promise (有些实现的promise 将 then 方法放到了宏任务中，浏览器默认放到了微任务), Object.observe (已废弃), MutationObserver（不兼容） MessageChannel（vue中 nextClick 实现原理） 12345678910111213141516&lt;!-- MutationObserver的用法 --&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;!-- 当dom加载完毕后 来一句渲染完成 --&gt; &lt;script&gt; let observe=new MutationObserver(function()&#123; console.log('渲染完成') &#125;); observe.observe(app,&#123; childList:true,//节点列表 characterData:true,//节点里的数据 &#125;) for(var i=0;i&lt;100;i++)&#123; let p= document.createElement('p') app.appendChild(p); &#125; &lt;/script&gt; 12345678910 //管道的消息流动console.log(1) let channel=new MessageChannel(); let port1=channel.port1 let port2=channel.port2; port1.onmessage=function(e)&#123; console.log(e.data) &#125; console.log(2); ports.postMessage(100) 宏任务 setTimeout、setInterval、setImmediate、I/o 执行顺序 在浏览器中，先执行当前栈，执行完走微任务，然后走事件队列里的内容,拿出一个放到当前栈中执行,再去执行微任务-在 Node环境中，Event Loop 分为 6 个阶段，每一个阶段对应着一个宏任务队列。Node中的Event Loop会在每次切换队列的时候 清空微任务队列，也就会会将当前队列都执行完，在进入下一阶段的时候检查一下微任务中有没有任务 timers: 这个是定时器阶段，处理setTimeout()和setInterval()的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。 I/O callbacks 除了以下操作的回调函数，其他的回调函数都在这个阶段执行。 setTimeout()和setInterval()的回调函数 setImmediate()的回调函数 用于关闭请求的回调函数，比如socket.on(‘close’, …) idle, prepare 该阶段只供 libuv 内部调用，这里可以忽略。 Poll: 这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。 这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。 check:该阶段执行setImmediate()的回调函数。 close callbacks:该阶段执行关闭请求的回调函数，比如socket.on(‘close’, …)。 栗子事件循环的示例猜猜以执行步奏1234567891011121314151617const fs = require('fs');const timeoutScheduled = Date.now();// 异步任务一：100ms 后执行的定时器setTimeout(() =&gt; &#123; const delay = Date.now() - timeoutScheduled; console.log(`$&#123;delay&#125;ms`);&#125;, 100);// 异步任务二：文件读取后，有一个 200ms 的回调函数fs.readFile('test.js', () =&gt; &#123; const startCallback = Date.now(); while (Date.now() - startCallback &lt; 200) &#123; // 什么也不做 &#125;&#125;); 脚本进入第一轮事件循环以后，没有到期的定时器，也没有已经可以执行的 I/O 回调函数，所以会进入 Poll 阶段，等待内核返回文件读取的结果。由于读取小文件一般不会超过 100ms，所以在定时器到期之前，Poll 阶段就会得到结果，因此就会继续往下执行。 第二轮事件循环，依然没有到期的定时器，但是已经有了可以执行的 I/O 回调函数，所以会进入 I/O callbacks 阶段，执行fs.readFile的回调函数。这个回调函数需要 200ms，也就是说，在它执行到一半的时候，100ms 的定时器就会到期。但是，必须等到这个回调函数执行完，才会离开这个阶段。 第三轮事件循环，已经有了到期的定时器，所以会在 timers 阶段执行定时器。最后输出结果大概是200多毫秒 setTimeout 和 setImmediate由于setTimeout在timers 阶段执行，而setImmediate在 check阶段执行。所以，setTimeout会早于setImmediate完成。12setTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2)); 上面代码应该先输出1，再输出2，但是实际执行的时候，结果却是不确定，有时还会先输出2，再输出1。 这是因为setTimeout的第二个参数默认为0。但是实际上，Node 做不到0毫秒，最少也需要1毫秒，根据官方文档，第二个参数的取值范围在1毫秒到2147483647毫秒之间。也就是说，setTimeout(f, 0)等同于setTimeout(f, 1)。 实际执行的时候，进入事件循环以后，有可能到了1毫秒，也可能还没到1毫秒，取决于系统当时的状况。如果没到1毫秒，那么 timers 阶段就会跳过，进入check 阶段，先执行setImmediate的回调函数。 但是下面的代码一定是先输出2，再输出1。123456const fs = require('fs');fs.readFile('test.js', () =&gt; &#123; setTimeout(() =&gt; console.log(1)); setImmediate(() =&gt; console.log(2));&#125;); promise.nextTick的用途12345678910111213function Fn()&#123; this.arrs; process.nextTick(function()&#123; this.arrs(); &#125;)&#125;Fn.prototype.then=function(d)&#123; this.arrs=function()&#123; console.log(1) &#125;&#125;let Fn = new Fn()Fn.then() nextTick不要写递归,可以放一些比settimeout优先执行的任务1234567//机器会卡死function nextTick()&#123; process.nextTick(function()&#123; nextTick() &#125;)&#125;settimeout(function()&#123;&#125;) 注意: 当触发回调函数时，才会将回调函数放到队列中,例如setTimeout只有在时间到的情况下才会将回调函数，放入队列中 settimeout在不写时间或者时间为0的时候,因为浏览器工作原理,默认4ms process.nextTick比then快 参考 hey，你的Event Loop]]></content>
      <tags>
        <tag>node</tag>
        <tag>global</tag>
        <tag>Event Loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML补充知识]]></title>
    <url>%2F2018%2F06%2F24%2FHTML%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[全局属性 accesskey &amp; tabindex 与键盘按键相关。 12345678&lt;p&gt; &lt;input type="text" accesskey="i" placeholder="Press Ctrl+Alt+I"&gt;&lt;/p&gt;&lt;p&gt; &lt;a href="http://www.baidu.com" accesskey="e" tabindex="-1"&gt;press &lt;kbd&gt;Ctrl+Alt+E&lt;/kbd&gt; &lt;/a&gt;&lt;/p&gt; id保证唯一性，class多用在css，style指定内联样式。 contenteditable 页面的内容可以被编辑。spellcheck拼写检查 12345678&lt;!--contenteditable：使页面可编辑--&gt; &lt;section contenteditable spellcheck="true"&gt; &lt;p&gt;计算机基础&lt;/p&gt; &lt;p&gt;了解浏览器的渲染原理、开发调试工具以及各种调试技巧。了解 Web 协议栈，学习掌握 HTTP 协议基础， 理解网络、浏览器性能和安全相关的问题以及常用的优化技巧，掌握专业的前端性能优化能力。 学习 UI 常用动画效果的算法原理和基础，掌握通过 JavaScript、CSS3、SVG 实现高性能动画的技巧。 学习其他前端相关的数学知识、数据结构和常用算法。&lt;/p&gt; &lt;/section&gt; 语言 lang 指定页面的语言；dir 指定语言书写的方向。 12345&lt;div lang="zh-CN"&gt; &lt;p&gt;哈哈哈&lt;/p&gt;&lt;/div&gt;&lt;!-- 阿拉伯语 右对齐 --&gt;&lt;p dir="rtl" lang="ar"&gt;sasdasda&lt;/p&gt; title 属性 1&lt;abbr title="你好"&gt;hello&lt;/abbr&gt; hidden属性。隐藏元素。可用性好 1&lt;p hidden&gt;你看不见我&lt;/p&gt; 无障碍性 或可访问性，Accessibility。 确保任何人都有办法获取放在网页上的媒体内容。 不让身体、心理或技术上的问题成为获取信息的障碍 Web开发者应该做的事情 WCAG(Web Content Accessibility Guidelines) 2.0 ARIA(Accessible Rich Internet Applications)123456&lt;!-- ARIA 属性,告诉读屏软件该标签充当什么角色 --&gt;&lt;ol role="tablist"&gt; &lt;li role="tab"&gt;&lt;a href="#ch1"&gt;Chapter 1&lt;/a&gt;&lt;/li&gt; &lt;li role="tab"&gt;&lt;a href="#ch2"&gt;Chapter 2&lt;/a&gt;&lt;/li&gt; &lt;li role="tab"&gt;&lt;a href="#ch3"&gt;Chapter 3&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt; 提升无障碍性 为 img 提供 alt 属性。 noscript 当浏览器不支持脚本script时的替代性方案。 input 和 label 相对应。 图形验证码与语音验证码`。 文字和背景有足够对比度。 键盘可操作。 语义化 HTML中的元素、属性及属性值都拥有某些含义 开发者应该遵循语义来编写HTML 为什么语义化很重要？ 提升代码可读性、可维护性 搜索引擎优化 提升无障碍性 扩展HTML meta 如：如何编码、页面关键词、页面介绍、页面缩放、电话号码自动识别、360浏览器指定内核、指定IE渲染模式 123456789101112131415161718192021&lt;!--编码--&gt;&lt;meta charset="UTF-8"&gt;&lt;!--指定 HTTP Header--&gt;&lt;meta http-equiv="content-security-policy" content="script-src 'self'"&gt;&lt;!--SEO 搜索引擎优化--&gt;&lt;meta name="keywords" content="关键词"&gt;&lt;meta name="description" content="页面介绍"&gt;&lt;!--移动设备 Viewport--&gt;&lt;meta name="viewport" content="initial-scale=1"&gt;&lt;!--关闭 ios 电话号码自动识别--&gt;&lt;meta name="format-detection" content="telphone=no"&gt;&lt;!--360 浏览器指定内核--&gt;&lt;meta name="renderer" content="webkit"&gt;&lt;!--指定 IE 渲染模式--&gt;&lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt; data-*:dataset属性是一个map，其中存放data-*东西。 12345&lt;ul&gt; &lt;li data-id="1"&gt;水果1&lt;/li&gt; &lt;li data-id="2"&gt;水果2&lt;/li&gt; &lt;li data-id="3"&gt;水果3&lt;/li&gt;&lt;/ul&gt; microdata HTML5中的一个规范 itemscope 属性描述的是：在此标签内的东西是一个实体。itemtype=&quot; &quot;属性描述的是：再次标签内的东西的实体类型。itemprop=&quot; &quot;属性描述的是：该实体内的具体属性是啥。 在HTML 中 通过属性嵌入格式化数据 提供给搜索引擎、浏览器（插件）使用1234567891011121314151617181920 &lt;h2&gt;microdata&lt;/h2&gt;&lt;section itemscope itemtype="http://schema.org/Person"&gt; Hello, my name is &lt;span itemprop="name"&gt;Xiao Xiao&lt;/span&gt; I am a &lt;span itemprop="jobTitle"&gt;Graduate Student&lt;/span&gt; at the &lt;span itemprop="University"&gt;UESTC&lt;/span&gt; My friends call me &lt;span itemprop="additionalName"&gt;Xiao&lt;/span&gt; You can visit my homepage at &lt;a href="http://blog.csdn.net/sunxiaofre" itemprop="url"&gt;blog&lt;/a&gt; &lt;section itemprop="address" itemscopt itemtype="http://schema.org/PostalAddress"&gt; I live at &lt;span itemprop="addressCountry"&gt;China&lt;/span&gt; &lt;span itemprop="addressLocality"&gt;SiChuan&lt;/span&gt; &lt;span itemprop="addressStreet"&gt;XiJie&lt;/span&gt; &lt;/section&gt;&lt;/section&gt; RDFa JSON-LD json类型的数据组织形式12345678910111213141516171819&lt;h2&gt;JSON-LD&lt;/h2&gt; &lt;script type="application/ld+json"&gt; &#123; "@context": "http://schema.org", "@type": "Person", "name": "Xiao Xiao", "jobTitle": "Graduate Student", "University": "UESTC", "additionalName": "Xiao", "url": "http://blog.csdn.net/sunxiaofre", "address": &#123; "@type": "PostalAddress", "addressCountry": "China", "addressLocality": "SiChuan", "addressStreet": "XiJie" &#125; &#125; &lt;/script&gt; 参考 Google Schemas Schema.org HTML编程规范 Google Coding Style W3C Validator 工具 Emmet markdown]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单]]></title>
    <url>%2F2018%2F06%2F21%2F%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[使用form获取让用户提供数据12345&lt;form action="/echo" method="post"&gt; &lt;p&gt;USER: &lt;input type="text" name="uesename"&gt;&lt;/p&gt; &lt;p&gt;PASSWORD: &lt;input type="password" name="password"&gt;&lt;/p&gt; &lt;p&gt;&lt;button type="submit"&gt;LOGIN&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; GET与POST 获取还是修改 get：从服务器获取东西； post：向服务器提交东西。 数据传输方式的区别： get：把字段数据放到url中提交，一次性将数据发送给服务器； post：不会把数据放到路径url中，而是将数据以某种形式进行编码，将编码后的内容放到HTTP的body中提交。需要分两次才能发送给服务器。HTTP分两次发送，第一次发送head，第二次发送body。 发送的位置不同而已，都没有做加密解密的操作。只不过get方式放在url中在浏览器的url中可以看到,而post看不到。 URL Encode（URL编码） 空格 =&gt; %20 （空格会默认替换为加号+） ! =&gt; %21 &quot; =&gt; %22 # =&gt; %23 $ =&gt; %24 % =&gt; %25 ’ =&gt; %27 + =&gt; %2B HTTP method GET POST HEAD：只返回head中的东西。 PUT :放置 DELETE：删除。 OPTIONS：返回http有哪些headers的选项。如查看是否允许跨域。 单行多行文本框 name就是发送数据到服务器的key。value给用户一个默认值。 placeholder提示词 autofocus 聚焦 password 密码1&lt;input type="text" placeholder="提示文字" autofocus&gt; 多行文本框12&lt;textarea cols="30" rows="7"&gt;&lt;/textarea&gt; 输入验证 尽早提示用户错误输入。required表示此项必须填写， minlength,maxlength pattern正则表达式。1234567891011121314&lt;form action="/echo"&gt; &lt;p&gt; &lt;input required minlength="3" maxlength="12" placeholder="3-12位"&gt; &lt;/p&gt; &lt;p&gt; &lt;input pattern="1\d&#123;10&#125;" placeholder="输入手机号"&gt; &lt;/p&gt; &lt;p&gt; &lt;button type="submit"&gt;确认&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; type 在可用性上做一些辅助 对手机上键盘的布局有影响 对输入自行进行验证，提高可用性 type=”search” type=”email” type=”url” type=”submit” novalidate 去掉系统自带的验证。根据自己的业务需要用JavaScript自己实现一个验证。1&lt;form action="" novalidate&gt;&lt;/form&gt; radio 单选框 从一组数据中选择其中一个12345678910&lt;form action=""&gt; &lt;p&gt;你最喜欢的水果是？&lt;/p&gt; &lt;p&gt; &lt;input type="radio" name="fruit" value="barries"&gt; 草莓 &lt;input type="radio" name="fruit" value="banana"&gt; 香蕉 &lt;input type="radio" name="fruit" value="mango"&gt; 芒果 &lt;input type="radio" name="fruit" value="dragon"&gt; 火龙果 &lt;/p&gt; &lt;p&gt;&lt;button&gt;提交&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; checkbox 复选框12345678910&lt;form action=""&gt; &lt;p&gt;你最喜欢的水果是？&lt;/p&gt; &lt;p&gt; &lt;input type="checkbox" name="fruit" value="barries"&gt; 草莓 &lt;input type="checkbox" name="fruit" value="banana"&gt; 香蕉 &lt;input type="checkbox" name="fruit" value="mango"&gt; 芒果 &lt;input type="checkbox" name="fruit" value="dragon"&gt; 火龙果 &lt;/p&gt; &lt;p&gt;&lt;button&gt;提交&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; label标签 可用性提升 在使用 radio 和 checkbox 时，点击文字也可以进行选择，而不是只能点击框才能选择。12345678910111213&lt;form action=""&gt; &lt;p&gt;你最喜欢的水果是？&lt;/p&gt; &lt;p&gt; &lt;label for="barries"&gt;&lt;input type="checkbox" name="fruit" value="barries" id="barries"&gt; 草莓&lt;/label&gt; &lt;input type="checkbox" name="fruit" value="banana" id="banana"&gt;&lt;label for="banana"&gt; 香蕉&lt;/label&gt; &lt;input type="checkbox" name="fruit" value="mango" id="mango"&gt;&lt;label for="mango"&gt; 芒果&lt;/label&gt; &lt;input type="checkbox" name="fruit" value="dragon" id="dragon"&gt;&lt;label for="dragon"&gt; 火龙果&lt;/label&gt; &lt;/p&gt; &lt;!-- 关联input 支持读屏软件 --&gt; &lt;label for="name"&gt;请输入你的名字：&lt;/label&gt; &lt;p&gt;&lt;input id="name"/&gt;&lt;/p&gt; &lt;p&gt;&lt;button&gt;提交&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; select标签 当选项特别特别多时，可用下拉框来表示选项，使页面简洁。 1234567&lt;select&gt;&lt;option&gt;&lt;/option&gt;&lt;/select&gt;&lt;!-- 可以多选 --&gt;&lt;select mutiple&gt;&lt;/select&gt; &lt;!-- 当前显示在页面中的选项的个数 --&gt;&lt;select size="3"&gt;&lt;/select&gt; &lt;!-- 分组 --&gt;&lt;optgroup&gt;&lt;option&gt;&lt;/option&gt;&lt;/optgroup&gt; 多选 1234567891011121314151617181920212223&lt;form action=""&gt; &lt;label for=""&gt;想去的城市：&lt;/label&gt; &lt;select name="city"&gt; &lt;optgroup label="1-4"&gt; &lt;option value="1"&gt;1&lt;/option&gt; &lt;option value="2"&gt;2&lt;/option&gt; &lt;option value="3"&gt;3&lt;/option&gt; &lt;option value="4"&gt;4&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label="5-8"&gt; &lt;option value="5"&gt;5&lt;/option&gt; &lt;option value="6"&gt;6&lt;/option&gt; &lt;option value="7"&gt;7&lt;/option&gt; &lt;option value="8"&gt;8&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label="9-12"&gt; &lt;option value="9"&gt;9&lt;/option&gt; &lt;option value="10"&gt;10&lt;/option&gt; &lt;option value="11"&gt;11&lt;/option&gt; &lt;option value="12"&gt;12&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt;&lt;/form&gt; hidden 某些数据需要从页面上提交，但是不希望在页面上展示出来，此时用hidden。 1&lt;input type="hidden" name="secret" value="1"&gt; 文件选择 enctype=&quot;multipart/form-data&quot;属性、multipart将文件分段传输 mutiple ：可以同时选择多文件 accept=&quot;image/*&quot;只支持图片上传1234567891011121314&lt;!-- 文件选择框 --&gt;&lt;form action="" method="post" enctype="multipart/form-data"&gt; &lt;p&gt; &lt;label for=""&gt;您的姓名： &lt;/label&gt; &lt;input name="fullname"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=""&gt;请上传简历&lt;/label&gt; &lt;input type="file" multiple name="resume"&gt; &lt;/p&gt; &lt;p&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; date &amp; time1234567&lt;form action=""&gt; &lt;p&gt;date: &lt;input type="date"&gt;&lt;/p&gt; &lt;p&gt;datetime-local: &lt;input type="datetime-local"&gt;&lt;/p&gt; &lt;p&gt;month: &lt;input type="month"&gt;&lt;/p&gt; &lt;p&gt;week: &lt;input type="week"&gt;&lt;/p&gt; &lt;p&gt;time: &lt;input type="time"&gt;&lt;/p&gt;&lt;/form&gt; number &amp; range12345678910111213141516171819202122232425262728293031323334&lt;!--number &amp; range--&gt;&lt;form action="" id="heightAndWeight"&gt; &lt;p&gt; &lt;label&gt;身高(m)：&lt;/label&gt; &lt;input type="number" min="0.5" max="2.5" step="0.01" name="height" value="1.7"&gt; &lt;!-- html数据的展示 --&gt; &lt;output for="height"&gt;&lt;/output&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;体重(kg)：&lt;/label&gt; &lt;input type="range" min="10" max="200" step="0.1" name="weight" value="50"&gt; &lt;output for="weight"&gt;&lt;/output&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;BMI&lt;/label&gt; &lt;output for="weight height"&gt;&lt;/output&gt; &lt;/p&gt;&lt;/form&gt;&lt;script&gt; var form = document.querySelector('#heightAndWeight'); form.addEventListener('input', update); update(); function update() &#123; var data = new FormData(form); var height = parseFloat(data.get('height')); var weight = parseFloat(data.get('weight')); document.querySelector('[for="weight"]').value = weight; document.querySelector('[for="weight height"]').value = getBMI(height, weight); &#125; function getBMI(height, weight) &#123; return(weight/Math.pow(height, 2)).toFixed(2); &#125; color1&lt;input type="color"&gt; button123456789&lt;!--button--&gt;&lt;form action=""&gt; &lt;p&gt; &lt;!-- 默认事type="submit" --&gt; &lt;button type="submit"&gt;默认submit提交表单数据&lt;/button&gt; &lt;button type="button"&gt;button点击这种行为，不提交&lt;/button&gt; &lt;button type="reset"&gt;reset重置表单&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 回车提交123456789&lt;!--回车提交 自动触发type="submit" 的click事件 --&gt;&lt;form&gt; &lt;p&gt;Name: &lt;/p&gt; &lt;p&gt;&lt;input type="text" name="fullname" value="abc"&gt;&lt;/p&gt; &lt;p&gt; &lt;button onclick="alert(1)"&gt;不指定type&lt;/button&gt; &lt;button onclick="alert(2)" type="button"&gt;button&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 实际用途：尽量不取消回车提交的功能,一般将submit事件定义到form上 12345678910111213&lt;form&gt; &lt;input type="text" name="ana" id=""&gt; &lt;p&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/p&gt; &lt;/form&gt; &lt;script&gt; var from = document.querySelector("form") from.onsubmit = function (e) &#123; e.preventDefault(); alert('1') &#125; &lt;/script&gt; 控件状态 readonly：会提交到服务器上，但页面上无法进行修改。 disabled：不会提交到服务器上 表单设计 帮助用户不出错，能选不填，给出提示 尽早提示错误 扩大选择／点击区域 控件较多时要分组 分清主要动作和次要动作]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表格]]></title>
    <url>%2F2018%2F06%2F21%2F%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[基本格式 th不仅可以出现在thead中，也可以出现在tbody中，只要认为此单元格是表头性质的，就可以用th。tr表示行，td表示列。 部分错误的嵌套，浏览器会尽可能补全缺失的部分123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;表格&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border="1"&gt; &lt;caption&gt;浏览器及其引擎&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;浏览器&lt;/th&gt; &lt;th&gt;渲染引擎&lt;/th&gt; &lt;th&gt;JavaScript 引擎&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;Chrome&lt;/th&gt; &lt;td&gt;Blink&lt;/td&gt; &lt;td&gt;V8&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Opera&lt;/th&gt; &lt;td&gt;Blink&lt;/td&gt; &lt;td&gt;V8&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Firefox&lt;/th&gt; &lt;td&gt;Gecko&lt;/td&gt; &lt;td&gt;SpiderMonkey&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 合并单元格 合并行 rowspan：一个单元行占几行。 合并列 colspan：一个单元格占几列。123456789101112131415161718192021222324252627&lt;!--合并行--&gt;&lt;table border="2"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;浏览器&lt;/th&gt; &lt;th&gt;渲染引擎&lt;/th&gt; &lt;th&gt;JavaScript 引擎&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;Chrome&lt;/th&gt; &lt;td rowspan="2"&gt;Blink&lt;/td&gt; &lt;td rowspan="2"&gt;V8&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Opera&lt;/th&gt; &lt;!--&lt;td&gt;Blink&lt;/td&gt;--&gt; &lt;!--&lt;td&gt;V8&lt;/td&gt;--&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Firefox&lt;/th&gt; &lt;td colspan="2" align="center"&gt;Gecko&lt;/td&gt; &lt;!--&lt;td&gt;SpiderMonkey&lt;/td&gt;--&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 表格说明 表头caption必须是table的第一个元素。 列组 colgroup12345678910111213141516171819202122232425262728293031&lt;table border="2"&gt; &lt;caption&gt;浏览器及其引擎&lt;/caption&gt; &lt;colgroup&gt; &lt;col class="browser" style="background: #a7c7dc;"&gt; &lt;col class="engine" span="2" style="background: #f0ad4e;"&gt; &lt;/colgroup&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;浏览器&lt;/th&gt; &lt;th&gt;渲染引擎&lt;/th&gt; &lt;th&gt;JavaScript 引擎&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;Chrome&lt;/th&gt; &lt;td rowspan="2"&gt;Blink&lt;/td&gt; &lt;td rowspan="2"&gt;V8&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Opera&lt;/th&gt; &lt;!--&lt;td&gt;Blink&lt;/td&gt;--&gt; &lt;!--&lt;td&gt;V8&lt;/td&gt;--&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Firefox&lt;/th&gt; &lt;td colspan="2" align="center"&gt;Gecko&lt;/td&gt; &lt;!--&lt;td&gt;SpiderMonkey&lt;/td&gt;--&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连接与图片]]></title>
    <url>%2F2018%2F06%2F21%2F%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[链接 省略协议 12&lt;!-- 根据当前页面的协议 --&gt;&lt;a href="//www.baidu.com"&gt;&lt;/a&gt; 省略协议和host 12&lt;!-- 根据当前页面的协议和host --&gt;&lt;a href="/index.html"&gt;&lt;/a&gt; 相对路径与绝对路径 12345678&lt;!-- 开发时一般用省略协议和host的绝对路径 --&gt;&lt;!-- 相对路径 --&gt;&lt;a href="a/index.html"&gt;&lt;/a&gt;&lt;!-- 相对路径 --&gt;&lt;a href="../../index.html"&gt;&lt;/a&gt;&lt;!-- 绝对路径 --&gt;&lt;a href="/a/index.html"&gt;&lt;/a&gt; 页面内跳转：锚点 12&lt;a href="#idName"&gt;连接到本页面id=idName的元素所在处&lt;/a&gt;&lt;a href="#"&gt;链接到本页面顶部&lt;/a&gt; 链接目标 target:_self 当前窗口 target:_blank 新窗口 target:abc 随意一个值,指定同一个值会共用同一个页面 图片12&lt;img src="" alt="替代文字" width="300" height="200"&gt;&lt;figcaption&gt;图片说明&lt;/figcaption&gt; 指定图片宽高： 不指定宽高：原图大小显示 指定宽度：按比例缩放到指定宽度 指定高度：按比例缩放到指定高度 指定宽高：强制按指定宽高显示 常用图片格式： jpg：照片，色彩丰富的图片（常用） png：色彩较少时使用，png24可以半透明（常用） gif：色彩较少时使用，gjf无法半透明，可以多帧做动画（较少用） webp：有些浏览器不支持]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html简述与文本]]></title>
    <url>%2F2018%2F06%2F21%2Fhtml%E7%AE%80%E8%BF%B0%E4%B8%8E%E6%96%87%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[HTML是什么 HyperText Markup Language 使用标签来描述页面的内容和结构 HTML的产生 1989年,TimBerners-Lee 共享文档需要 还发明了浏览器、服务器和HTTP Doctype的作用 指定HTML页面使用的标准和版本 浏览器根据doctype决定使用哪种渲染模式 渲染模式 Quirks Mode 怪异模式 —-(html4之前) Almost Standard Mode 准标准模式—-(有些标签大小写不严格) Standard Mode 标准模式—(标签大小写严格标准) 123456789&lt;!-- html5 --&gt;&lt;!DOCTYPE html&gt;&lt;!-- 准标准模式 --&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;!-- 标准模式 --&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;!-- 当 doctype 缺失的时候，浏览器会选择 Quirks Mode --&gt; HTML 版本 HTML 1.0,1991 HTML 2.0,1994,IETE HTML 3.2, 1997,W3C Netscape引入私有标签 HTML 3.0失败 W3C接管HTML标准化 HTML 4.01,1998 样式与内容分离,CSS支持 Doctype XHTML 1.0,2000 用XML语法重新定义HTML 语法严格要求 XHTML 2.0 不兼容历史 去除样式类标签 去除img、a标签 彻底修改Form 开发者不欢迎,浏览器不支持 HTML5 2004年,WHATWG继续发展HTML 2008年,W3C HTML5草案发布 HTML5 设计思想 兼容已有内容 避免不必要的复杂性 解决现实的问题 优雅降级 尊重事实标准 用户的需求–&gt;开发者的需求–&gt;浏览器厂商的需求–&gt;标准的制定者的需求–&gt;理论完美 HTML5 中的变化 doctype、meta 新增语义化标签和属性 去掉纯展示性标签 canvas、video、audio、离线、本地存储、拖拽等 HTML5语法 标签不区分大小写,推荐小些 空标签可以不闭合,如&lt;input&gt; &lt;meta&gt; 属性不必引号,推荐双引号 某些属性值可以省略,如required、readonly 文本标签 p h1~h6 hr 段落级别的话题切换（效果：一条横线） 列表： 有序列表 ol、li 无序列表 ul、li 自定义列表dl、dt、dd 1234567891011&lt;h3&gt;霸王别姬&lt;/h3&gt;&lt;dl&gt; &lt;dt&gt;导演：&lt;/dt&gt; &lt;dd&gt;陈凯歌&lt;/dd&gt; &lt;dt&gt;主演：&lt;/dt&gt; &lt;dd&gt;张国荣&lt;/dd&gt; &lt;dd&gt;巩俐&lt;/dd&gt; &lt;dd&gt;张丰毅&lt;/dd&gt; &lt;dt&gt;上映日期：&lt;/dt&gt; &lt;dd&gt;1993-01-01&lt;/dd&gt;&lt;/dl&gt; 列表是可以嵌套的（列表中有列表,自动默认有缩紧）。 嵌套规则：内外不要混搭 引用 长段落引用块标签 1&lt;blockquote cite="myURL"&gt;长段落引用块标签&lt;/blockquote&gt; 短引用 1&lt;cite&gt;短引用说来源，如书名、标题&lt;/cite&gt; 引用内容 1&lt;q&gt;引用的内容，如引用一句话&lt;/q&gt; 预格式化文本 pre保留空格和换行 代码段code 插图figure 可以包裹图片或代码段12345678910&lt;figure&gt; &lt;figcaption&gt;定义一个函数&lt;/figcaption&gt; &lt;pre&gt; &lt;code&gt; function add(x,y)&#123; return x+y &#125; &lt;/code&gt; &lt;/pre&gt;&lt;/figure&gt; 网页总体结构html5 Doctor header 页头 footer 页尾 main 正文(网页想要表达的主要内容) aside 侧边栏(和正文内容无关) article 文章 section 文档中的节，一段1234567891011&lt;article&gt; &lt;header&gt; &lt;h1&gt;字体排版&lt;/h1&gt; &lt;p&gt;作者：XXX&lt;/p&gt; &lt;/header&gt; &lt;section&gt; &lt;h2&gt;语言及范围&lt;/h2&gt; &lt;p&gt;在当代，。。。。。&lt;/p&gt; &lt;p&gt;字体排版。。。&lt;/p&gt; &lt;/section&gt;&lt;/article&gt; 强调： strong：重要性、严重性、紧急性 em：从一句话中突出某个词语 b：仅为了将词语从视觉上和其他部分区分，比如一篇论文摘要中的关键词。（不推荐） i：换一种语调去说一句话时，比如其他语言翻译，对话中的旁白。（不推荐） 定义与缩写：12&lt;dfn&gt;定义&lt;/dfn&gt; &lt;abbr title="对缩写的解释"&gt;缩写&lt;/abbr&gt; 代码1234&lt;code&gt;代码段&lt;/code&gt; &lt;var&gt;变量&lt;/var&gt; &lt;kbd&gt;键盘按键 F12&lt;/kbd&gt;&lt;samp&gt;举个例子&lt;/samp&gt; 上标和下标12&lt;sub&gt;&lt;/sub&gt; &lt;sup&gt;&lt;/sup&gt; mark 和用户当前行为相关的突出，比如在搜索结果中匹配到的词 一部分内容需要在后面引用时。 插入和删除1234&lt;ins&gt;更新&lt;/ins&gt; &lt;del&gt;删除&lt;/del&gt;&lt;!-- 用途 --&gt;&lt;del&gt;原价：199&lt;/del&gt;&lt;ins&gt;双十一：100&lt;/ins&gt; 换行控制（尽量避免）123&lt;br&gt; &lt;!-- 用途 --&gt;&lt;p&gt;https://blog.csdn.net/sunxiaofre/&lt;wbr&gt;article/&lt;wbr&gt;details&lt;wbr&gt;/695002&lt;/p&gt; div 和 span 实在找不到其他更符合语义的标签时使用 实体（Entity）字符 &amp;&nbsp;&gt; &copy;&yen;&#9775; &amp;amp;&amp;nbsp;&amp;gt;&amp;copy;&amp;yen;&amp;#9775;]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[text-size-adjust使用汇总]]></title>
    <url>%2F2018%2F06%2F21%2Ftext-size-adjust%E4%BD%BF%E7%94%A8%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[-webkit-text-size-adjust 的本职是用于mobile的，见规范 CSS Mobile Text Size Adjustment Module Level 1 和 apple 的 Safari Web Content Guide。之所以现在的桌面版webkit浏览器支持他，是因为实际上这是一下bug。Bug 56543 – CSS property “-webkit-text-size-adjust” means different things in Safari and iOS这个bug在最新版的 WebKit Nightly Builds 里已经被修复了。 这属性现在的一般用处是防止iPhone在坚屏转向横屏时放大文字（注意，就算viewport设置了maximum-scale=1.0 文字还是会放大的）。 而且iPhone和iPad的默认设定是不一样的iPhone默认设定 -webkit-text-size-adjust: auto; iPad默认设定-webkit-text-size-adjust: none;所以iPad默认是不调节的。 此属性还支持百分比，这在当前的桌面版的webkit浏览器是不支持的，所以如果不想让iPhone横坚屏切换的时候调节文字，用-webkit-text-size-adjust: 100%;绝对不能用-webkit-text-size-adjust: none;这会导致仍然支持 -webkit-text-size-adjust: none;的桌面版的webkit浏览器无法人为放大文字大小，严重影响可用性。 关于如何在chrome里实现小于12px的文字。当然文字缩小到12px以下本来就一定程度影响到可用性了，建议无视chrome的这个特性。硬要实现的话，我想到的一个变通方法是先用js判断是否为chrome （至今还没听说有区分safari 和 chrome 的 css hack ） 1var isChrome = !!window.chrome; 再用-webkit-transform: scale( ) 缩小到合适值。如果你非得要font-size:10px(使用em单位时方便计算)，你会发现在chrome里最小还是12px，就算你设置了font-size: 10px;-webkit-text-size-adjust: 100%;(或-webkit-text-size-adjust: none;)也没用。原因如下： 123div&#123; -webkit-text-size-adjust: 100%|none;&#125; 只对chrome27.0 版本以下有效，27.0以上版本无效； 只对英文才有效，对中文无效。 在新版的chrome中，已经禁止了改属性,建议使用CSS3中的方法:transform:scale(0.875);当使用transform:scale(0.875)时; 不仅是文字变小了，整个文字所在的容器也同时会变小。 123综上所述：采用-webkit-text-size-adjust: 100%;必须要用小于12px字体时，用-webkit-transform: scale( ) 缩小到合适值。]]></content>
  </entry>
  <entry>
    <title><![CDATA[工程化]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%B7%A5%E7%A8%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[工程化目的 提供一致、合理的开发基础 应对变化 提升效率 文件结构 CSS reset 设置HTMl标签的默认样式 使其在各个浏览器表现基本一致 让默认样式归零注意：reset normalize.css 设置HTML标签的默认演示 使其在各个浏览器表现基本一致 保留标签的默认样式注意：normalize CSS模块 可复用的CSS代码段 与模块在HTML中的位置无关 一般与使用的HTML标签无关 CSS模块原则面向对象（OOCSS） 结构和皮肤分离 .btn, .btn-primary, .btn-info, .btn-danger 容器和内容分离123456789101112131415161718192021/* 不推荐这样写 */.header .btn&#123; background:#f66; color:#fff;&#125;/* 推荐如下 */.btn&#123;display:inline-block;padding:0.36em 0.8em;margin-right:0.5em;border:none;border-radius:0.3em;cursor:pointer;&#125;.btn--primary&#123; background:#09c; color:#fff;&#125; /* html */&lt;button class="btn"&gt;按钮&lt;/button&gt;&lt;button class="btn btn--primary"&gt;按钮&lt;/button&gt; Media Object结构 .media .media__image .media__object .media__body .media__tile .media__description 1234567891011&lt;div class="media media--left"&gt; &lt;a class="media__image"&gt; &lt;img src="//placehold.it/100*100" alt="" class="media__object"&gt; &lt;/a&gt; &lt;div class="media__body"&gt; &lt;h3 class="media__tile"&gt;Title&lt;/h3&gt; &lt;p class="media__description"&gt; A paragraph about the media &lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415.media,.media__body&#123; overflow:hidden;&#125;.media__body:first-child&#123; margin-top:0;&#125;.media--left .media__image&#123; float:left; margin-right:1em;&#125;.media--right .media__image&#123; float:right; margin-left:1em;&#125; 单一职责原则（SRP） 尽可能细地拆分可独立复用的组件 通过组合方式使用多个组件 比如将布局和其他样式拆分123456789101112.btn&#123;display:inline-block;padding:0.36em 0.8em;margin-right:0.5em;border:none;border-radius:0.3em;cursor:pointer;&#125;.btn--primary&#123; background:#09c; color:#fff;&#125; 开闭原则 对扩展开放 对修改关闭123456789101112.box&#123; display:block; padding:10px;&#125;/* bad explame */.content .box&#123; padding:20px;&#125;/* better example */.box--large&#123; padding:20px;&#125; Don’t Repeat Yourself（DRY）1234567891011/* bad example */.selector&#123; border-top:1px solid #fcc; border-left:1px solid #fcc; border-bottom:1px solid #fcc;&#125;/* better example */.selector&#123; border:1px solid #fcc; boder-right:none;&#125; 命名 Naming 基于功能 它是用来干什么的？ .botton/ .form/ .list/ .external-link/ .tab-item/ .nav 基于内容 元素里面放的是什么内容？ .news/ .user-info/ .help/ .contact-me 基于视觉 看起来是什么样的？ .round-image/ .nowrap 命名原则 优先使用基于功能的命名 样式与内容无关 中小型网站可以基于内容去命名（如个人简历、个人博客） 大型网站可以基于视觉去命名 不要使用太具体的样式 如：不要用#left, #right 用#main, #aside 功能VS视觉VS具体样式 .warning vs .orange .btn-primary vs .btn-blue .size-large vs .width-200 .form-inline .nav-stacked CSS命名规范-BEM Block：可以独立出来的一个个块 Element：Block里面的元素 Modifier：修饰，对抽象出来的基本样式的扩展 .block__element--modifier12345&lt;nav class="tabs tabs--stacked"&gt; &lt;a href="#" class="tabs__item tabs__item--active"&gt;Home&lt;/a&gt; &lt;a href="#" class="tabs__item"&gt;Javascript&lt;/a&gt; &lt;a href="#" class="tabs__item"&gt;Css&lt;/a&gt;&lt;/nav&gt; 编写简洁易维护的CSS-CSS预处理 less Sass Stylus PostCSS css新特性cssnext css变量 123456:root&#123; --primary-color:#f66;&#125;h1,h2,h3&#123; color:var(--primary-color)&#125; Nesting 嵌套 1234567.navbar&#123; display:table; &amp; .navbar__item&#123; display:table-cell; color:#fff; &#125;&#125; minxs 1234567891011:root&#123; --h-center&#123; margin-left:auto; margin-right:auto; &#125;&#125;.main&#123; @apply --h-center; max-width:100em; min-width:40em;&#125; 颜色相关函数 12345678910:root&#123; --primary-color:#666;&#125;.btn&#123; background:var(--primary-color); &amp;:hover&#123; /* 把颜色加暗20% */ background: color(var(--primary-color) blackness(20%)); &#125;&#125; import (http请求数量大) 12345/* app.css */@import 'variables.css';@import 'common.css';@import 'modules/button.css';@import 'modules/form.css' Plugins AutoPrefixer StyleLint]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兼容性]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%85%BC%E5%AE%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[CSS中的兼容性问题 浏览器不支持该特性 某些特定条件下触发浏览器bug 浏览器特性支持 caniuse.com MDN CSS Reference Codrops CSS Reference QuirksMode.org CSS 你需要兼容哪些浏览器 根据用户群体决定 面向普通用户：IE8+、Chrome、Firefox 企业级产品：IE9+、Chrome、Firefox 了解浏览器市场份额 日志分析 百度统计、NetMarketShare 浏览器不支持时怎么办？ 如果低版本浏览器没有这个特性可以接受吗？ border-radius不支持时，没有圆角 box-shadow不支持时，没有阴影 可以使用效果稍微差一点的替代方案吗？ min-height:100vh用min-height:800px代替 可以使用一些替代方案吗？ opacity:0.5在IE下用filter:alpha(opacity=50) 可以使用JavaScript让浏览器支持吗？ 使用html5shim.js让IE6～8支持新标签 使用DD_belatePNG.js让IE6只吃半透明png图片 更换实现方式 不同浏览器使用不同的样式@supports123456789.contrainer&#123; display:flex;&#125;@supports(display:grid)&#123; .container&#123; display:grid; grid-template:repeat(4,1fr)/50px 100px; &#125;&#125; 浏览器hack原理-层叠 同一个属性，后面书写的值覆盖前面书写的值 12line-height:2;line-height:3; 对当前浏览器来说无效的属性和属性值会被忽略 1234p&#123; display:table; display:flex; &#125; 浏览器hack原理- 条件注释1234567891011&lt;!-- [if IE 7] &gt;&lt;p&gt;只能在 IE 7下看见我&lt;/p&gt;&lt;![endif] --&gt;&lt;!-- [if lt IE 8] &gt;&lt;p&gt;只能在小于 IE 8的浏览器下看见我&lt;/p&gt;&lt;![endif] --&gt;&lt;!--[if lt IE 7 ]&gt;&lt;html class="ie6" lang="zh-cn"&gt;&lt;![endif]--&gt;&lt;!--[if IE 7 ]&gt;&lt;html class="ie7" lang="zh-cn"&gt;&lt;![endif]--&gt;&lt;!--[if IE 8 ]&gt;&lt;html class="ie8" lang="zh-cn"&gt;&lt;![endif]--&gt;&lt;!--[if IE 9 ]&gt;&lt;html class="ie9" lang="zh-cn"&gt;&lt;![endif]--&gt;&lt;!--[if (gt IE 9)|!(IE)]&gt;&lt;!--&gt;&lt;html class="" lang="zh-cn"&gt;&lt;!--&lt;![endif]--&gt; 浏览器怪癖 iE6 IE 6 不支持两个或多个类选择器直接组合，只会解析最后一个。 只有iE6会忽略_123456789/* ie6不支持两个或多个类选择器直接组合 */.unsed-class.selector&#123; /* iE6 only css */&#125;.container&#123; height:100px; /* 只有iE6会忽略_ ,认为是height*/ _height:200px;&#125; iE7 只有IE6 和7 会忽略*12345.container&#123; height:100px; /* 只有IE6 和7 会忽略* */ *height:200px;&#125; ie8 IE6-8不支持 :root选择器 IE6-8 会忽略\9 :root选择器相当于html123456789/* IE6-8不支持 `:root`选择器 */:root .selector&#123; /* ie6-8 style */&#125;.selector&#123; color:#fff; /* ie6-8 会忽略\9 */ color:#fff\9;&#125; 小测试：123456.top&#123; background:blue; background:red\9; *background:block; _background:orange;&#125; css2选择器的兼容性（IE6-7）IE6不支持多个类直接组合 p.class-a.class-b被当作p.class-b 解决方法：处理好选择器优先级 IE 6 不支持父子选择器和兄弟选择器 E&gt; F、E+F和E~F选择器无效 解决办法：避免使用，用后代选择器替代 IE 6 不支持属性选择器 任何一种都不支持 解决办法：用class选择器替代 IE 6-7 不支持某些伪元素 不支持:before和:after 解决办法：改变实现方式、或在HTML中添加标签 IE 6 不支持某些伪类 非链接不能使用:hover, :active 解决办法：使用a嵌套需要hover的元素 IE6-7不支持：:focus伪类 解决办法：使用javascript IE 6 不支持first-child伪类 解决办法：给第一个元素添加class=&quot;first&quot; IE6不支持min/max-width/height min-height解决办法 1234div&#123; min-height:500px; _height:500px;&#125; max-width解决办法 123456789101112131415&lt;div&gt; &lt;div class="strut"&gt;&lt;/div&gt; &lt;!-- other content --&gt;&lt;/div&gt;&lt;style&gt;.container&#123; min-width:500px;&#125; /* IE6 */.container .strut&#123; height:1px; width:500px;&#125;&lt;/style&gt; max-width/height解决办法 使用javascript iE6不支持position:fixed123456789html,body&#123; height:100%;&#125;.go-top&#123; position:fixed; _position:absolute; bottom:0; right:0;&#125; ie6-7不支持块级元素inline-block 行级元素支持,而块级元素不支持 解决办法123456.selector&#123; display:inline-block; *display:inline; /* BFC可以设置上下padding和margin,width,height,块级盒子拥有的属性*/ *zoom:1;&#125; ie6-7 不支持display:table 请使用float或者inline-block布局 不要使用table布局 CSS3 选择器兼容性 CSS3中的大部分选择器，兼容性是IE 9+ 例如：:target, :empty, :nth-child, :nth-of-type, :checked, :disabled 无法在IE6-8用 移动端支持绝大多数CSS3选择器iE8 box-sizing outline ie8 不支持 background-size 推荐在IE8及以下使用固定宽度布局 border-radius box-shadow opacity filter:alpha(opacity=50) rgba、hsl、hlsa 一般场景下，使用相近的不透明颜色代替 Alpha可以通过增加额外元素，并设置透明度实现 rem/vh/vw/calc 降级为固定宽度 ie9 transition与animation 可以接受的降级 实在不能使用就用Javascript media query 基本的媒体(all/print/screen/speech)都支持 媒体特性（width/height/orientation、、、）IE9及其以上 还是建议IE8及其以下使用固定宽度 浏览器前缀 浏览器厂商为了实验新特性,在属性名前加前缀 Chrome/Safari/Opera：-webkit- Microsoft：-ms- Mozilla/Firefox：-moz- 注意：前缀 语义化的HTML5标签12345678&lt;!--[if lte IE 8]&gt; &lt;script src="html5shiv.js"&gt;&lt;/script&gt;&lt;![endif] --&gt;&lt;style&gt; article,main,nav,aside,section,header,footer,figure,figcaption&#123; display: block; &#125;&lt;/style&gt; html5shiv.js12345678(function()&#123; var tags='abbr,article,aside,audio,bdi,canvas,data,datalist,details,dialog,figcaption,figure,footer,header,hgroup,main,mark,meter,nav,output,picture,progress,section,summary,template,time,video'.split(','); console.log(tags) var i=tags.length; while(i--)&#123; document.createElement(tags[i]) &#125; &#125;)() 浏览器BUGIE6下半透明png显示不正确- [DD_belatedPNG.js](http://www.dillerdesign.com/experiment/DD_roundies/) - filter 123456789.select&#123; background:url(/path/to/img.png) no-repeat; _background:none; /* 图片URL必须是完整路径 */ _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader( src='/path/to/img.png', sizingMethod='crop' )&#125; IE6浮动双边距 浮动元素的与浮动同方向的边距加倍 12345.selector&#123; float:left; /* IE6下显示20px */ margin-left:10px;&#125; 解决办法 12345.selector&#123; float:left; margin-left:10px; _display:inline;&#125; hasLayout On Having Layout zoom:1 IE 模式 浏览器模式 Browser Mode 切换渲染引擎、JavaScript引擎和HTTP请求的UserAgent 兼容模式相当于使用IE7的引擎 对于IE浏览器可以用F12切换浏览器模式 文档模式 切换文档模式，即渲染引擎和JavaScript引擎 浏览器模式指定之后，会自动切换文档模式 控制IE模式（&lt;=10） DocType有无控制是否进入怪异模式 meta标签控制进入哪种文档模式12345&lt;!--使用IE7模式渲染--&gt;&lt;meta http-equiv="x-ua-compatible" content="IE=7"&gt;&lt;!--使用最新引擎--&gt;&lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;&lt;title&gt;控制IE模式&lt;/title&gt; 测试兼容性 虚拟机 BrowserStack Polyfill 使用代码帮助浏览器实现它尚未支持的特性 使用（未来）标准写法 css Polyfills selectivizr CSS3 PIE box-sizing-polyfill flexibility cssSandpaper]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式设计]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[响应式页面设计 响应式设计：同一个页面可以适应不同屏幕大小设备的设计方案 viewport PC页面宽度：980px &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 响应式的图片 大图随容器自动缩放，保持高宽比 实现方式：给所有图片添加：max-width:100%123img&#123; max-width:100%;&#125; 背景图片 background-size:cover：图片会覆盖容器，铺满，图片可能被裁切掉， background-size:contain：若图片很重要，不希望被裁切，用这个，图片会完整显示 保持高宽比（做视频时常用小技巧） padding的百分比是相当于盒子的宽度的百分比 可以用于：保持高宽比12345div&#123; height:0; padding-top:50%; background:#f99;&#125; 两栏：自适应布局 float 与 BFC 绝对定位 模拟table flex布局 搜索12345678910111213141516171819202122&lt;form action=""&gt; &lt;input type="search"&gt; &lt;button&gt;搜索&lt;/button&gt;&lt;/form&gt; &lt;style&gt; form&#123; margin-right: 4em; position: relative; &#125; form input&#123; width: 100%; font-size: inherit; line-height: 1.4; &#125; form button&#123; position: absolute; left: 100%; top: 0; width: 4em; font-size: inherit; &#125; &lt;/style&gt; 网格布局，自动换行 inline-block + justify flex123456789101112131415161718192021222324252627&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt;&lt;/ul&gt;&lt;style&gt; ul&#123; margin: 0; padding: 0; text-align: justify; &#125; li&#123; display: inline-block; width: 30%; width: 4em; height: 0; padding-top: 20%; background: lightcyan; text-align: center; margin-bottom: 1em; &#125;&lt;/style&gt; media query 针对不同的屏幕，应用不同的样式1234567&lt;link rel="stylesheet" href="media.css" media="screen and (max-width: 480px)"&gt;&lt;style&gt;@media screen and (min-width: 480px)&#123; .selector&#123;...&#125; &#125;&lt;/style&gt; 可以查询的media width height device-width device-height device-pixel-ratio(屏幕分辨率,img上应用) orientation (横屏、竖屏)123456789101112131415161718192021222324252627282930313233&lt;nav&gt; &lt;a href="#"&gt;javascript&lt;/a&gt; &lt;a href="#"&gt;css&lt;/a&gt; &lt;a href="#"&gt;html&lt;/a&gt; &lt;style&gt; body&#123; margin:0; &#125; nav&#123; display: flex; width:100%; background:#00BCD4; &#125; nav a&#123; flex:1; text-decoration: none; color:#fff; padding: 0 1em; font:normal 14px/2 Helvetica,sans-serif; &#125; nav a:not(:first-child)&#123; border-left:1px solid rgba(255,255,255,0.7) &#125; @media screen and (max-width:480px)&#123; nav&#123; flex-direction: column; &#125; nav a:not(:first-child)&#123; border-left:none; border-top:1px solid rgba(255,255,255,0.7) &#125; &#125; &lt;/style&gt; 字体设置12345@media screen and (max-width:1000px)&#123;html&#123; font-size:14px;&#125;&#125; calc(计算)123html&#123; font-size:calc(10px + 1vw)&#125; 参考：更多]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级选择器]]></title>
    <url>%2F2018%2F06%2F20%2F%E9%AB%98%E7%BA%A7%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[伪类:target 伪类 表示元素被hash匹配时的状态 比如 URL 是/post/a#headTopic时，name 为headTopic的元素处于被target的状态 可以实现简单的内容的切换（高亮显示）123456789101112131415161718192021222324252627&lt;a href="#p1"&gt;One&lt;/a&gt;&lt;a href="#p2"&gt;Two&lt;/a&gt;&lt;a href="#p3"&gt;Three&lt;/a&gt;&lt;a href="#p4"&gt;Four&lt;/a&gt;&lt;p id="p1"&gt;此处是第一段&lt;/p&gt;&lt;p id="p2"&gt;此处是第二段&lt;/p&gt;&lt;p id="p3"&gt;此处是第三段&lt;/p&gt;&lt;p id="p4"&gt;此处是第四段&lt;/p&gt; &lt;style&gt; p:target&#123; background: red; color: #FFFFFF; &#125; a&#123; font-size: 24px; width: 20%; height: 40px; text-align: center; display: inline-block; text-decoration: none; color: #b6c1d3; background: #bee6b9; &#125; a:hover&#123; color: red; &#125; &lt;/style&gt; :lang 伪类 元素匹配上指定语言时的状态 浏览器通过lang属性获得语言信息1234567891011&lt;section lang="fr"&gt; &lt;p&gt;&lt;q&gt;C'est la vie&lt;/q&gt;,il parlait.&lt;/p&gt;&lt;/section&gt;&lt;style&gt; :lang(fr) q:before&#123; content:"《" &#125; :lang(fr) q:after&#123; content: "》" &#125;&lt;/style&gt; :nth-child() 结构性伪类（与元素出现的位置有关） 通过：:nth-child(an+b)选中某些子元素 例如：:nth-child(3n)选中第3、6、9 … 个子元素 其中a可以为负数 n是自然数,可以为01234567891011121314&lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;li&gt;Item 4&lt;/li&gt; &lt;li&gt;Item 5&lt;/li&gt; &lt;li&gt;Item 6&lt;/li&gt;&lt;/ul&gt;&lt;style&gt; li:nth-child(3n+1)&#123; /* 第一个和第四个 */ color:red; &#125;&lt;/style&gt; 隔行换色 123456789101112131415161718&lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;li&gt;Item 4&lt;/li&gt; &lt;li&gt;Item 5&lt;/li&gt; &lt;li&gt;Item 6&lt;/li&gt;&lt;/ul&gt;&lt;style&gt; li:nth-child(odd)&#123; /*奇数 */ color:red; &#125; li:nth-child(even)&#123; /* 偶数 */ color:green; &#125;&lt;/style&gt; :nth-of-type (第n个这种类型的) 同一种类型的元素nth-child() 与 nth-of-type 的区别 父级 :nth 123456789101112131415&lt;article&gt; &lt;h2&gt;这是标题&lt;/h2&gt; &lt;p&gt;Paragraph one&lt;/p&gt; &lt;p&gt;Paragraph two&lt;/p&gt; &lt;p&gt;Paragraph three&lt;/p&gt; &lt;p&gt;Paragraph four&lt;/p&gt;&lt;/article&gt;&lt;style&gt; article :nth-child(3n+1)&#123; color: #cc0804; &#125; article :nth-of-type(3n+1)&#123; text-decoration: line-through; &#125; &lt;/style&gt; 子集:nth 1234567891011121314151617&lt;article&gt; &lt;h2&gt;这是标题&lt;/h2&gt; &lt;p&gt;Paragraph one&lt;/p&gt; &lt;p&gt;Paragraph two&lt;/p&gt; &lt;p&gt;Paragraph three&lt;/p&gt; &lt;p&gt;Paragraph four&lt;/p&gt;&lt;/article&gt;&lt;style&gt; p:nth-child(2)&#123; /* &lt;p&gt;Paragraph one&lt;/p&gt; */ color: #cc0804; &#125; p:nth-of-type(2)&#123; /* &lt;p&gt;Paragraph two&lt;/p&gt; */ text-decoration: line-through; &#125; &lt;/style&gt; 更多区别 :first-child/:last-child 伪类:not() 伪类 排除匹配的元素 比如：img:not([alt])选择没有写alt属性的图片123button:not(:last-child)&#123; margin-right:2em;&#125; 其他选择器 伪类 :nth-last-child (对应nth-child) :nth-last-of-type(对应nth-of-type) :first-of-type (对应first-child) :last-of-type (对应last-child) :only-child (父母唯一的子元素) :only-of-type (父母唯一同一类型的子元素) :empty 伪类1234&lt;!-- 标签中没内容 --&gt;li:empty&#123; display:none;&#125; 伪元素伪类与伪元素的区别 伪类是在HTML中真实存在的元素 伪元素在HTML中是根本就没有的元素，是在CSS中虚拟出来的元素。 伪元素一般用两个冒号开头::。如：p::first-line{}。 ::first-line 伪元素选中第一行123p::first-line&#123; color:red;&#125; ::first-letter 伪元素选中第一个字母12345p::first-letter&#123; font-size:2em; float:left; color:red;&#125; 兄弟选择器 相邻兄弟选择器E+F 通用兄弟选择器E~F注意:这两种兄弟选择器选择的都是在其下面的兄弟，不管上面的兄弟。（只选弟弟）123456789101112&lt;p&gt;The first paragraph&lt;/p&gt;&lt;h2&gt;The h2 title&lt;/h2&gt;&lt;p&gt;The second paragraph&lt;/p&gt;&lt;p&gt;The third paragraph&lt;/p&gt;&lt;style&gt; h2 + p &#123; color: #e8c; &#125; h2 ~ p &#123; text-decoration: underline; &#125;&lt;/style&gt; :checked~F123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;div class="toggle"&gt; &lt;input type="checkbox" checked id='t'&gt; &lt;label for="t"&gt;&lt;/label&gt;&lt;/div&gt;&lt;style&gt; .toggle &#123; width: 80px; height: 26px; background: #333; margin: 20px auto; position: relative; border-radius: 50px; box-shadow: inset 0px 1px 1px 1px rgba(0, 0, 0, 0, 0.5), 0px 1px 0px rgba(255, 255, 255, 0.2); &#125; .toggle:after &#123; content: 'OFF'; color: #fff; position: absolute; right: 10px; z-index: 0; font: 12px/26px Arial, sans-serif; font-weight: bold; text-shadow: 1px 1px 0 rgba(255, 255, 255, .15) &#125; .toggle:before &#123; content: 'ON'; color: #f66; position: absolute; left: 10px; z-index: 0; font: 12px/26px Arial, sans-serif; font-weight: bold; &#125; .toggle label &#123; display: block; width: 34px; height: 20px; cursor: pointer; position: absolute; top: 3px; left: 3px; z-index: 1; background: #fcfff4; background: linear-gradient(top, #fcfff4 0%, #dfe5d7 40%, #b3bead 100%); border-radius: 50px; transition: all 0.4s ease; box-shadow: 0px 2px 5px 0px rgba(0, 0, 0, .3) &#125; .toggle input[type=checkbox] &#123; visibility: hidden; &#125; .toggle input:checked+label &#123; left: 43px; &#125;&lt;/style&gt;]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画]]></title>
    <url>%2F2018%2F06%2F19%2F%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[transform 变换 对元素进行平移、旋转、缩放 transform不会对其他元素布局产生影响,类似position:reltive 取值：none|&lt; transform-list&gt; translate translateX/translateY/translateZ translateZ 前后移动 负值向后移动 正值 向前移动rotate 单位：deg rotateX/rotateY/rotateZ scale 缩放 (原始大小的多少倍) scaleX/scaleY skew 斜切 单位：deg skewX/skewY 正值 拉 左上角 和 右下角 负值 拉 右上角 和 左下角 transform-origin 旋转原点 关键字: top bottom center left right; 具体的长度单位(em,rem,px…) transform-style(3d空间) transform-style: preserve-3d; / 保留子元素的3d变换， 3d空间/ perspective 视点 指定进行3D渲染时，人眼距离Z平面的距离 不会影响元素本身的渲染 只会影响子元素的3D效果 放在要变换的元素的父级身上 backface-visibility(隐藏背面) backface-visibility:hidden; 背面即和父级角度相对的面 是给每个子元素加backface-visibility:hidden; 重点: rotate、skew、scale默认都是围绕着元素的中心点进行变化的 transform 的执行循序后写的先执行 会受到原点影响的变换有：rotat、skew、scale translate 移动不会改变原点的位置 transform-origin: center center 0px;有3d，参数分别代表x,y,z; 默认值：center center 0px transform-style表示父级进行3d变化是第一子集是够保留3d变化.如果是第二子集,要在第一子集上写tansform-style ios设备下变换原点的z轴有问题会变大,和一些其他的bug。解决方法 子元素可以rotate(90deg) transformZ(50px)移动 ,但是还会变大：所以父元素transformZ(-50px); translation 过渡 指定一个样式状态到另一个状态时如何过渡，即两个状态之间的过渡 动画的意义：告诉用户发生了什么 指定过渡： 什么属性发生变化时需要过渡 过渡持续多长时间 速度变化是什么样 是否有延迟 transition transition-property transition-duration transition-timing-function transition-delay 可以给每个属性指定不同的transition12345678910.box&#123; height:100px; width:100px; background:orange; transition:width 1s ease 1s,height 1s ease;&#125;.box:hover&#123; width:200px; height:200px;&#125; transition-timing-function 时间与进度的关系参考:http://cubic-bezier.com/#.63,.47,.83,.67 animation 动画 animation可以实现更复杂的样式变化效果，多个状态的连续的变化 定义关键帧 指定动画行为123456789101112131415161718192021222324252627&lt;i class="scroll-down"&gt;↓ 喜欢我就点我吧！&lt;/i&gt; &lt;style&gt; @keyframes down&#123; from&#123; margin-top: 0; opacity: 1; /*opacity：透明度， 当opacity为1时就是完全不透明。*/ &#125; 50%&#123; margin-top: 0.5em; opacity: 0.3; &#125; to&#123; margin-top: 0; opacity: 1; &#125; &#125; .scroll-down&#123; position: fixed; top: 50%; left: 50%; margin-left: -0.5em; font: normal normal 36px/1 Helvetica; color: #f55; animation: down 1.5s ease infinite; &#125; &lt;/style&gt; 复杂动画效果：盛开的花朵123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;div class="box"&gt; &lt;div class="leaf"&gt;&lt;/div&gt; &lt;div class="leaf"&gt;&lt;/div&gt; &lt;div class="leaf"&gt;&lt;/div&gt; &lt;div class="leaf"&gt;&lt;/div&gt; &lt;div class="leaf"&gt;&lt;/div&gt; &lt;div class="leaf"&gt;&lt;/div&gt; &lt;div class="leaf"&gt;&lt;/div&gt; &lt;div class="leaf"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .box&#123; position: relative; height: 200px; width: 200px; margin: 2px 0 0 80px; &#125; .box .leaf&#123; position: absolute; &#125; .leaf&#123; margin-top: 200px; width: 100px; height: 150px; border-radius: 150px 0; background: linear-gradient( 45deg, rgb(255, 229, 229) 10%, rgb(255, 134, 161) 30%, rgb(255, 249, 24) 100% ); opacity: 0.5; transform: rotate(45deg); transform-origin: top right; &#125; .leaf:nth-child(2)&#123; animation: show-2 6s ease-in-out 1; &#125; .leaf:nth-child(3)&#123; animation: show-3 6s ease-in-out 1; &#125; .leaf:nth-child(4)&#123; animation: show-4 6s ease-in-out 1; &#125; .leaf:nth-child(5)&#123; animation: show-5 6s ease-in-out 1; &#125; .leaf:nth-child(6)&#123; animation: show-6 6s ease-in-out 1; &#125; .leaf:nth-child(7)&#123; animation: show-7 6s ease-in-out 1; &#125; .leaf:nth-child(8)&#123; animation: show-8 6s ease-in-out 1; &#125; @keyframes show-2&#123; 0%&#123; transform: rotate(45deg); &#125; 100%&#123; transform: rotate(71deg); &#125; &#125; @keyframes show-3&#123; 0%&#123; transform: rotate(45deg); &#125; 100%&#123; transform: rotate(96deg); &#125; &#125; @keyframes show-4&#123; 0%&#123; transform: rotate(45deg); &#125; 100%&#123; transform: rotate(123deg); &#125; &#125; @keyframes show-5&#123; 0%&#123; transform: rotate(45deg); &#125; 100%&#123; transform: rotate(149deg); &#125; &#125; @keyframes show-6&#123; 0%&#123; transform: rotate(45deg); &#125; 100%&#123; transform: rotate(175deg); &#125; &#125; @keyframes show-7&#123; 0%&#123; transform: rotate(45deg); &#125; 100%&#123; transform: rotate(200deg); &#125; &#125; @keyframes show-8&#123; 0%&#123; transform: rotate(45deg); &#125; 100%&#123; transform: rotate(220deg); &#125; &#125; &lt;/style&gt;]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布局]]></title>
    <url>%2F2018%2F06%2F19%2F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[布局方法 float position inline-block table flex grid 水平居中 行级元素：text-align:center 块级元素：margin:auto auto是根据盒子的宽度和两边剩余的宽度决定的,如果盒子的左右边的间距没设置，他会根据剩余间距的一半来对其盒子，使盒子居中 垂直居中 单行文字:line-height 行级盒子：vertical-align:middle 绝对定位：top:50%;left:50%; 行级元素 12345678910111213141516171819&lt;p&gt;&lt;em&gt;共享&lt;/em&gt;未安装人群&lt;/p&gt;&lt;style&gt; p&#123; padding: 0 1em; background: #eee; line-height: 2; font-size: 16px; &#125; em&#123; font-size: 12px; background: #0c7dc5; display: inline-block; vertical-align: middle; line-height: 1.5; padding: 0 0.5em; font-style: normal; color: #fff; &#125;&lt;/style&gt; 块级元素(已知宽高) 12345678div&#123; width:20em; height:10em; left:50%; top:50%; margin-left:-10em; margin-right:-5em;&#125; float-based(两栏布局)1234567891011121314151617&lt;main&gt; &lt;aside&gt;aside&lt;/aside&gt; &lt;article&gt;3月20日，据北京市政一卡通公司消息，一卡通公司已经试点推出了“扫码乘公交”服务，用户无论持何种型号的智能手机，只要扫描二维码即可乘坐公交车&lt;/article&gt;&lt;/main&gt;&lt;style&gt; aside&#123; width: 10em; float:left; background:lightblue; min-height: 10em; &#125; article&#123; overflow: hidden; min-height: 10em; background:orange; &#125;&lt;/style&gt; float-based的缺点：后面的内容区域一定要BFC,aside和article的位置不能改变 updated（两栏布局）1234567891011121314151617181920212223242526272829&lt;main&gt; &lt;article&gt;3月20日，据北京市政一卡通公司消息，一卡通公司已经试点推出了“扫码乘公交”服务，用户无论持何种型号的智能手机，只要扫描二维码即可乘坐公交车&lt;/article&gt; &lt;aside&gt;aside&lt;/aside&gt; &lt;/main&gt; &lt;style&gt; main &#123; font-size: 14px; padding-left: 10em; &#125; article &#123; float: left; width: 100%; min-height: 10em; background: orange; &#125; aside &#123; width: 10em; float: left; background: lightblue; min-height: 10em; position: relative; /* 重要 */ margin-left: -10em; /* 重要 */ left:-100%; &#125; &lt;/style&gt; （伪）等高 在float布局的时候,我们通过padding-bottom和margin-bottom实现的,padding的效果是content的高度不变,但是把整个容器撑开了,但是margin如果是负值,他会把整个盒子的高度缩小。所以我们能看到背景颜色一直等高。其实就是padding撑开的。背景颜色实际就是padding。 12345678910111213141516171819202122232425262728293031&lt;main&gt; &lt;article&gt;3月20日，据北京市政一卡通公司消息，一卡通公司已经试点推出了“扫码乘公交”服务，用户无论持何种型号的智能手机，只要扫描二维码即可乘坐公交车&lt;/article&gt; &lt;aside&gt;aside&lt;/aside&gt; &lt;/main&gt; &lt;style&gt; main &#123; font-size: 14px; padding-left: 10em; overflow: hidden; &#125; article &#123; float: left; width: 100%; background: orange; /* 重要 */ padding-bottom:99em; margin-bottom: -99em; &#125; aside &#123; width: 10em; float: left; background: lightblue; position: relative; margin-left: -10em; left:-100%; /* 实现 */ padding-bottom:99em; margin-bottom: -99em; &#125; position(两栏布局)12345678910111213141516171819202122232425&lt;main&gt; &lt;article&gt;3月20日，据北京市政一卡通公司消息，一卡通公司已经试点推出了“扫码乘公交”服务，用户无论持何种型号的智能手机，只要扫描二维码即可乘坐公交车&lt;/article&gt; &lt;aside&gt;aside&lt;/aside&gt; &lt;/main&gt; &lt;style&gt; main &#123; font-size: 14px; position:relative; &#125; article &#123; background:coral; margin-left:10em; &#125; aside &#123; width: 10em; background: lightblue; position: absolute; left:0; top:0; /* 伪登高 */ bottom:0; &#125; &lt;/style&gt; table table会自适应table-layout:fixed是按th的比例,来平均分配单元格的宽度的 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;浏览器&lt;/th&gt; &lt;th&gt;Javascript 引擎&lt;/th&gt; &lt;th&gt;css 引擎&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;Chrome&lt;/th&gt; &lt;td&gt;V8&lt;/td&gt; &lt;td&gt;Blink&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Firefox&lt;/th&gt; &lt;td&gt;SpiderMonkey&lt;/td&gt; &lt;td&gt;Geocko&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Edge&lt;/th&gt; &lt;td&gt;ChakraCore&lt;/td&gt; &lt;td&gt;Edgehtml&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;style&gt; table&#123; width: 100%; font-size: 14px; /* 合并单元格 */ border-collapse: collapse; &#125; tr&#123; text-align: center; &#125; td,th&#123; border:1px solid #666; padding: 1em; &#125; th&#123; width:8em; &#125; &lt;/style&gt; 注意:不要使用表格标签布局,用语义化标签 display:table(等高两栏布局)123456789div&#123;display:table; /* &lt;table&gt; */display:table-cell; /* &lt;td&gt; */display:table-row;/* &lt;tr&gt; */display:table-column; /* &lt;col&gt; */display:table-column-group; /* &lt;colgroup&gt; */display:table-footer-group; /* &lt;tfoot&gt; */display:table-header-group; /* &lt;thead&gt; */&#125; table布局没有指定宽度,就是自适应的 12345678910111213141516171819202122&lt;main&gt; &lt;article&gt;3月20日，据北京市政一卡通公司消息，一卡通公司已经试点推出了“扫码乘公交”服务，用户无论持何种型号的智能手机，只要扫描二维码即可乘坐公交车&lt;/article&gt; &lt;aside&gt;aside&lt;/aside&gt;&lt;/main&gt;&lt;style&gt; main &#123; display: table; width: 100%; font-size: 14px; &#125; article,aside &#123; display: table-cell; padding: 1em; &#125; article&#123; background:orange; &#125; aside&#123; background:lightblue; &#125;&lt;/style&gt; 导航条 123456789101112131415161718192021222324252627&lt;nav&gt; &lt;a href="#"&gt;HTML&lt;/a&gt; &lt;a href="#"&gt;CS&lt;/a&gt; &lt;a href="#"&gt;JAVASCRIPT&lt;/a&gt; &lt;a href="#"&gt;REACT&lt;/a&gt;&lt;/nav&gt; &lt;style&gt; nav&#123; width: 100%; display: table; border-collapse: collapse; font-size: 14px; line-height: 3; &#125; nav a&#123; display: table-cell; border: 1px solid white; background: hsl(160, 27%, 60%); color: rgba(255,255,255,0.9); text-align: center; text-decoration: none; &#125; nav a:hover&#123; background: hsl(181, 27%, 55%); color: #000; &#125; &lt;/style&gt; 垂直居中1234567891011&lt;div&gt;&lt;img src="https://p.pstatp.com/list/190x124/pgc-image/15290431498490a3c384181" alt=""&gt;&lt;/div&gt;&lt;style&gt;div&#123; width: 300px; height: 300px; text-align: center; vertical-align: middle; background: orange; display: table-cell;&#125;&lt;/style&gt; flexbox真正为解决布局问题而生的规范 Flexbox可控制子元素： 水平或垂直排成一行 控制子元素对齐方式 控制子元素的宽度／高度 控制子元素的显示顺序 控制子元素是否折行 display:flex 将元素变为Flexbox 子元素在容器内水平（默认）或垂直摆放 flex-direction 子元素排列方向 取值：row（默认按行排列）| row-reverse | column | column-reverse 主轴与侧轴 主轴永远是子元素流动、摆放的方向 flex-wrap 折行 元素在主轴方向摆放时，是否换行 取值：nowrap | wrap | wrap-reverse justify-content 主轴方向摆放 子元素沿主轴方向的摆放 取值：flex-start | flex-end | center | space-between | space-around align-items 侧轴方向摆放 在侧轴方向的对齐方式 取值：flex-start | flex-end | center | baseline | stretch 默认值：stretch align-content 多行内容在容器内侧轴方向的对齐 取值：flex-start|flex-end|center|space-between|space-around|stretch align-self在某个子元素上设置对齐方式。 flex-grow 弹性 定义每一个子元素在盒子内的弹性 拓展盒子剩余空间的能力 取值：数字,默认0 flex-shrink 收缩 元素收缩的能力 取值：数字，默认为1 flex-shrink:0;不收缩 order 指定摆放时的顺序，从小到大 取值：数字，默认为0 flexbox 语法变化12345678910111213141516div &#123; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-direction: normal; -webkit-box-orient: horizontal; -ms-flex-direction: row; flex-direction: row; -ms-flex-wrap: nowrap; flex-wrap: nowrap; -webkit-box-pack: start; -ms-flex-pack: start; justify-content: flex-start; -ms-flex-line-pack: stretch; align-content: stretch;&#125; Grid 兼容性]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-排版细节(7)]]></title>
    <url>%2F2018%2F06%2F15%2F%E6%8E%92%E7%89%88%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[行级格式化上下文（Inline Formatting Context） baseline基线;ascender line上线;descender line下线;mean line均线;cap line 大写字母的上线 line-height行高：两行的base-line间的间距 vertical-align 定义盒子所处的行盒（line box）的垂直对齐关系 取值：baseline | sub | super | top | text-top | middle | bottom | text-bottom |&lt; percentage&gt;|&lt; length&gt; 百分比相对于元素自身的行高 初始值baseline top和bottom的值,是由该行盒的最高点和最低点决定的,middle是text-top和text-bottom的中间位置 strut baseline是如何确立的呀?虽然p元素里面没有文字,但是他会默认的生成一个匿名的盒子,继承父级的font-size和font-family 123456789&lt;p&gt; &lt;img src="http://img0.utuku.china.com/400x0/news/20180615/1cea34c8-569f-4cd8-b0fe-dd05cd0ff077.jpg" alt=""&gt;&lt;/p&gt;&lt;style&gt;p&#123; padding: 0; background: red;&#125;&lt;/style&gt; 解决办法： font-size:0 将img元素转成块级元素 img设置vertical-align:middle vertical-align:起作用的元素 inline（行内元素） table-cell（单元格） inline-block（行内块元素） vertical-align:middle inline/inline-block元素： 元素的垂直中心点和父元素基线上1/2 x-height处对齐。 table-cell元素： 单元格填充盒子相对于外面的表格行居中对齐。 lists style 列表 display:list-item会生成两个盒子：Principle Block Box(li内容)和Marker Box(li的小圆点) Marker Box的内容和位置可以通过list-style系列属性指定list-style-position inside outside(默认) list-style-type none disc实心 circle空心 square方块 decimal数字 lower-roman罗马字符 upper-roman lower-greek希腊字符 lower-latin拉丁字符 upper-latin armenian georgian lower-alpha upper-alpha list-style-image list-style-image:url(http://…) list-style缩写 list-style-type、list-style-position和list-style-image三个属性的简写 background background-color background-image background-repeat background-position123body&#123; background: red url(path/to/img.png) no-repeat 0 0;&#125; background-sizebackground-size:宽度,高度;：调整背景图大小。或者：background-size:contain;。或者：background-size:cover; CSS Sprites 将小图片合并成一张图，从而减少页面请求的次数，加快页面的加载速度.background-position:50% 50%是将图片的50%和容器的50%对齐 border-radius border-radius:5px 可以指定四个方向 可以指定百分数123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div class="id1"&gt;1&lt;/div&gt; &lt;div class="id2"&gt;2&lt;/div&gt; &lt;div class="id3"&gt;3&lt;/div&gt; &lt;div class="id4"&gt;4&lt;/div&gt; &lt;div class="id5"&gt;5&lt;/div&gt; &lt;div class="id6"&gt;6&lt;/div&gt; &lt;div class="id7"&gt;7&lt;/div&gt; &lt;style&gt; .id1&#123;border-radius: 10px &#125; .id2&#123; border-radius: 10px; border:3px solid green; &#125; .id3&#123; border-radius: 5px 20px; &#125; .id4&#123; /* 控制两边的弧度 */ border-radius: 10px/30px; &#125; .id5&#123; border-radius: 30px/10px; &#125; .id6&#123; border-radius:50%; &#125; .id7&#123; width: 200px; border-radius: 50%; &#125; div&#123; background: #BADA55; width: 100px; height:100px; text-align: center; line-height: 100px; color: #000; font-size: 24px; font-family: Helvetical,sans-serif; float: left; margin: 1em; &#125; &lt;/style&gt; box-shadow none 无阴影 阴影水平偏移值,可负值 阴影垂直偏移值,可负值 设置对象的阴影模糊值,不允许负值 用来设置对象的阴影外延值,可负值 设置对象的阴影的颜色 inset:设置对象的阴影类型为内阴影,默认：外阴影 可以用一个元素创造出来各种各样的小图标 1234div&#123; /* 可以多个阴影并存,相当于可以复制多个图标 */ box-shadow:1px 1px 22px 0 rgba(0,0,0,0.6),1px 1px 22px 0 rgba(0,0,0,0.6)&#125; 实例：https://saeedalipoor.github.io/icono/]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-定位与堆叠(6)]]></title>
    <url>%2F2018%2F06%2F14%2F%E5%AE%9A%E4%BD%8D%E4%B8%8E%E5%A0%86%E5%8F%A0%2F</url>
    <content type="text"><![CDATA[定位模式（Positioning schemeschemes） 常规流（Normal Flow） 浮动（Float） 绝对定位（Absolute Positioning） position static：非定位，默认值 relative：相对定位 absolute：绝对定位，相对非static祖先元素定位 fixed：相对于视口绝对定位 relative 在常规流里面布局 相对于自己本应该在的位置进行偏移 使用top、left、bottom、right设置偏移长度 流内其他元素当它没有偏移一样布局,所以它不会对其他元素造成布局上的影响12345678910111213141516171819202122232425&lt;figure&gt; &lt;img src="http://ww4.sinaimg.cn/bmiddle/98e8fcd9jw1f2xkao7pcuj21kw11sdo8.jpg" alt="" width="512px"&gt; &lt;figcaption&gt;图片标题&lt;/figcaption&gt;&lt;/figure&gt;&lt;!-- 虽然figcaption元素向上移了28px,但是因为relative的特性,figcaption元素依旧占据位置 --&gt;&lt;p&gt;其他文本内容。&lt;/p&gt;&lt;style&gt; figure&#123; width: 512px; &#125; figure img&#123; display: block; &#125; figcaption&#123; position: relative; top: -28px; background: rgba(0,0,0,0.3); color: #FFFFFF; font-size: 14px; line-height: 2; /*因为font-size为14px，line-height为2，故figcaption占的高度是28px*/ padding: 0 1em; &#125; &lt;/style&gt; absolute 脱离正常流 相对于最近的非static祖先的padding box定位 不会对流内元素布局造成影响 可以有margin，但不会折叠12345678910111213141516171819202122232425&lt;figure&gt; &lt;img src="http://ww4.sinaimg.cn/bmiddle/98e8fcd9jw1f2xkao7pcuj21kw11sdo8.jpg" alt="" width="512px"&gt; &lt;figcaption&gt;图片标题&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;其他文本内容。&lt;/p&gt;&lt;style&gt; figure&#123; width: 512px; position:relative; &#125; figure img&#123; display: block; &#125; figcaption&#123; position: absolute; bottom:0; width:100%; background: rgba(0,0,0,0.3); color: #FFFFFF; font-size: 14px; line-height: 2; padding: 0 1em; &#125; &lt;/style&gt; 自动计算 这些值都可以不指定 top left right bottom width height 默认是auto,它会待在原本的位置(原常规流的位置),但是不影响其他元素的,可以通过margin-left等来实现位置的移动 fixed 相对于Viewport定位 不会随页面滚动发生位置变化 z-index堆叠层次 为定位元素(设置了position非static的元素)指定其在z轴的上下等级 用一个整数表示，数值越大，越靠近用户 初始值为auto，可以为负数、0、正数12345678910111213141516171819202122232425262728&lt;div class="box-a"&gt;Box a&lt;/div&gt;&lt;div class="box-b"&gt;Box b&lt;/div&gt;&lt;div class="box-c"&gt;Box c&lt;/div&gt; &lt;style&gt; [class^="box-"]&#123; position: absolute; width: 200px; /* 单行文字一般只设置line-height,不设置height */ line-height: 200px; text-align: center; color: #FFFFFF; &#125; .box-a&#123; background: #f44336; &#125; .box-b&#123; top: 100px; left: 100px; z-index: -1; background: #0097a7; &#125; .box-c&#123; top: 150px; left: 150px; z-index: 1; background: #4caf50; &#125; &lt;/style&gt; z-index大的一定在上面吗?不一定！要看堆叠上下文,不同的堆叠上下文的z-index大小不影响,先找到相同的堆叠上下文环境 堆叠上下文的生成 Root元素 z-index值不为auto的定位元素 设置了某些CSS3属性的元素，如opacity、transform、animation等。绘制顺序 在每一个堆叠上下文中，从下到上： 形成该上下文的元素的border和background z-index为负值的子堆叠上下文 常规流内的块级元素非浮动子元素 非定位的浮动元素 常规流内非定位行级元素 z-index为0的子元素或子堆叠上下文 z-index为正数的子堆叠上下文]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-盒模型(5)]]></title>
    <url>%2F2018%2F06%2F14%2F%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[box model width 指定的是content box的宽度,不包含padding、border、margin的宽度,仅仅包含content的宽度。 百分数是指相对于父容器（包含块）的content box的宽度。 height 指定content box高度。 百分数是相对于父容器（包含块）的content box的高度。 只有当包含块的高度不依赖该元素时,其实就是父元素的高度确定值不为auto,百分比高度才生效。 根元素是viewport,高度确定,所以只需将html元素的height设为100%,body才可以设置100%1234567891011121314151617181920&lt;div class="container"&gt; &lt;div class="child"&gt; 哈哈哈哈哈哈 &lt;/div&gt;&lt;/div&gt;&lt;style&gt; body &#123; margin: 0 &#125; .container &#123; background: #f00; height: 100vh; &#125; .child &#123; height: 100%; background: coral; &#125;&lt;/style&gt; padding 内边距：内容距离盒子的距离 padding-top、padding-right、padding-bottom、padding-left 缩写：padding:上 右 下 左 两个值：padding:上下 、左右 三个值：padding:上 、左右、下 margin 外边距：一个盒子距离另外一个盒子的距离，不能超过这个数 margin-top、margin-right、margin-bottom、margin-left 缩写：margin margin折叠：margin的真正含义是：在这个盒子外多远的距离内不能再摆放其他的盒子！ margin可以为负值吗?:可以的。负值意味着两个盒子有重叠，即允许这个盒子和其他的盒子重叠多少 box-sizing（CSS3新增） 改变盒模型的计算方式 取值：border-box (padding+content+border) | content-box 初始值：content-box123456789*&#123; box-sizing:inherit&#125;html&#123; box-sizing:border-box;&#125;.book&#123; box-sizing:content-box;&#125; border 边框的三个要素： border-width：&lt; length &gt; | thin | medium | thick border-style:none | solid | dashed | dotted | double border-color:&lt; color &gt; 边框的四个方向： border-top border-right border-bottom border-left 实战当width,height设置0时,我们可以实现各种三角形了12345678910111213&lt;div class="box"&gt;&lt;/div&gt;&lt;style&gt; .box&#123; border-width: 50px; border-style:solid; border-color:#f35 #259 #649 #fa0; width:200px; height:200px; transition:all 2s ease-in; margin: 1em auto; &#125;&lt;/style&gt; max-width &amp;&amp; max-width 可以通过设置article的min-width和max-width来做文字的排版,特别是响应式的布局时比较有用。1234article&#123; max-width:40em; min-width:20em;&#125; min-height &amp;&amp; max-height min-height可以在内容少的时候,把容器撑开 123456article&#123; max-width:40em; min-width:20em; max-height:10em; overflow:hidden;&#125; overflow 溢出控制 取值：visible | hidden | scroll |auto 初始值：visible 视觉格式化模版-浏览器是怎么排版的?视口（Viewport） 浏览器的可视区域 用户通过视口查看网页内容（透过窗户看风景） 块级元素（Block-level Elements） 会被格式化成块状的元素，一块一块的，另起一行。 例如：p、div、section等 将display设置为block、list-item、table使元素变为块状 行级元素／内联元素（Inline-level Elements） 不会为其内容生成块级框 让其内容分布在多行中 display设置为inline、inline-block、inline-table使元素变为行级元素 盒子的生成 元素与盒子是两个不同的概念,元素是HTML中一个个的标签;盒子是在排版的时候,浏览器在摆放的时候会生成一个一个的盒子,一个元素可能生成多个盒子。 每个块级元素生成一个主块级盒（principal block-level box）,用它来包含子级盒 每个行级元素生成一个行级盒子，行级盒分布于多行。 Box Model - revisited margin：行级盒的margin-top和margin-bottom不会产生效果。但是行级盒的margin-left和margin-right会有效果。 padding：行级盒的padding-top和padding-bottom不影响布局，不会影响元素的摆放。 块级盒子中的字盒子的生成 块级盒子中可以包含多个子块级盒子 也可以包含多个行级盒子 不在行级元素里面的盒子，会生成匿名行级盒。比如&lt;p&gt;Some&lt;em&gt;Text&lt;/em&gt;&lt;/p&gt; 块级盒子中不能同时包含块级和行级盒子。遇到这种会生成匿名块级盒子来包裹行级盒。比如&lt;div&gt;&lt;h1&gt;标题&lt;/h1&gt;&lt;span&gt;2018-12-12&lt;/span&gt;&lt;/div&gt;行级盒子内的子盒子的生成 行级盒子内可以包含行级盒子 行级盒子包含一个块级盒子时,会被块级盒子拆成两个行级盒子，这两个盒子又分别被匿名块级盒包含123456&lt;span&gt; &lt;em&gt;（行级元素中的行级元素）&lt;/em&gt; &lt;p&gt;（行级元素中的块级元素）陈坚与机组协商无果后，多名警察登机，强行将陈坚从其靠窗的座位上拽了出来。 拉拽过程中，陈坚一度大声呼叫，随后躺倒在地上被拖拽出去。&lt;/p&gt; &lt;strong&gt;（行级元素中的行级元素）&lt;/strong&gt;&lt;/span&gt; display属性 block生成块级盒 inline生成行级盒 inline-block生成行级盒（不会换行），为其内容生成块级盒（可以设置width、height、margin、border、padding） none在排版时将元素忽略（不展示此元素） visibility（相当于是透明的） 控制元素展示（明明在那里，但是对你不可见） 取值：visible | hidden | collapse 初始值为 visible Generated Content 控制元素。这个元素在CSS中多产生一个盒子，用来存放指定的内容 ::before和::after content 打印的时候可以使用123456789&lt;a href="http://www.baidu.com"&gt;点击访问&lt;/a&gt;&lt;style&gt; a::before&#123; content: '\1993' &#125; a:after&#123; content: '('attr(href)')'; &#125;&lt;/style&gt;]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-层叠、继承和css单位(4)]]></title>
    <url>%2F2018%2F06%2F14%2F%E5%B1%82%E5%8F%A0%E7%BB%A7%E6%89%BF%E5%92%8Ccss%E5%8D%95%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[css-层叠、继承和css单位选择器的特异度(Specificity) 选择器 内联？ id个数 (伪)类个数 标签个数 特异度 #nav.listlia:link 0 1 2 2 0122 .hd ul.links a 0 0 2 2 0022 122&gt;22所以第一个的特异度大,优先级高 简单选择器的特异度级别 Level 0: * Level 1: 标签选择器、伪元素(:before、:after) Level 2:类、伪类(:link、:first-child)、属性 Level 3:id Level 4:内联 !important优先级最高,慎用 css 样式的来源 页面开发者 用户设置 浏览器预设 用户样式 浏览器可以指定一个本地css文件,打开所有页面时自动加载 浏览器预设样式 Mozilla Firefox 预设样式 Google Chrome 预设样式 Internet Explorer 预设样式 那条声明起作用 找出匹配到的该属性所有声明 根据规则来源,优先级从低到高： 浏览器预览 用户设置 网页样式 同一来源中，按照特异度排序，越特殊优先级越高 特异度一样时，按照样式书写顺序，后面的优先级高 有!important 时的变化 找出匹配到的该属性所有声明 根据规则来源,优先级从低到高： 浏览器预览 用户设置 网页样式 含!important 的网页样式 含!important 的用户网页设置 同一来源中，按照特异度排序，越特殊优先级越高 特异度一样时，按照样式书写顺序，后面的优先级高 默认值策略 Defaulting继承 某些属性会自动继承其父元素的计算值,除非显式指定一个值 123456789&lt;p&gt;this is a &lt;em&gt;test&lt;/em&gt; of &lt;strong&gt;inherit&lt;/strong&gt;&lt;/p&gt;&lt;style&gt; p&#123; color:#666; &#125; em&#123; color:red; &#125;&lt;/style&gt; 显式继承 文字相关的css会自动继承，其他的一些不可以继承可以手动继承 123456789*&#123; box-sizing:inherit;&#125;html&#123; box-sizing:border-box;&#125;.some-widget&#123; box-sizing:content-box;&#125; 初始值 css中,每个属性都有一个初始值 background-color的初始值为transparent margin-left的初始值为0 可以显式重置为初始值，比如background-color:initial; css求值的过程 由 DOM树 &amp; 样式规则 filtering:对应用到该页面的规则用以下条件进行筛选：选择器匹配、属性有效、符合当前media等 声明值:Declared Values，一个元素的某属性可能由0到多个声明值。如：p{font-size:16px}和p.text{font-size:1.2em} cascading:按照来源、!important、选择器特异性、书写顺序等选出优先级最高的一个属性值 层叠值:Cascaded Value，在层叠过程中，赢得优先级比赛的那个值。如 1.2em defaulting:当层叠值为空时，使用继承或初始值 指定值:Specified Value，经过cascading和defaulting之后，保证指定值一定不为空 resolving:将一些相对值或者关键字转化成绝对值。如em转为px，相对路径转为绝对路径 计算值:Computed Value，一般来说是，浏览器会在不进行实际布局的情况下，所能得到的最具体的值。如60%。继承是继承的计算值） formatting:将计算值进一步转换。如关键字、百分比等都转为绝对值 使用值:Used Value，进行实际布局时使用的值，不会再有相对值或关键字。如400.2px constraining:将小数像素值转为整数 实际值:渲染时实际生效的值。如400px strong 元素font-size的求值过程12345678910111213141516171819&lt;article&gt; &lt;h1&gt;思维导图&lt;/h1&gt; &lt;p&gt;思维导图又叫&lt;strong&gt;心智导图&lt;/strong&gt;，是表达发散性思维的有效图形思维工具 ，它简单却又很有效，是一种革命性的思维工具&lt;/p&gt;&lt;/article&gt;&lt;style&gt; body&#123; color:#333;background:#f0f0f0; &#125; article&#123; font-size: 14px; line-height: 1.6; &#125; h1&#123; font-size: 2em; &#125; p&#123; font-size: 1.1em; &#125;&lt;/style&gt; 各种类型的值 关键值：font-size:inatial, box-sizing:inherit, color:red 字符串：content:”abc” URL：background-image:url(/resources/img/xiong.png) 长度：font-size:2em, height:100px, width:100px 百分比：width:50%, font-size:150% 整数：z-index:9 浮点数：line-height:1.8 颜色：color:#fff, color:rgb(0,0,100) 时间：transition-duration:0.3s 角度：transform:rorateX(deg) 函数：content:attr(title), height:calc(100vh-100px) 长度单位 绝对单位 px：像素，对应显示器的一个像素点 in：英寸 cm：厘米 mm：毫米 pt：磅（1pt=1/72英寸） pc：1pc=12pt 相对单位 em：相对于该元素的一个font-size大小的值。（常用） rem：相对于根元素root即html的font-size。（手机上用） vh：浏览器窗口高度的1%。（做全屏的布局时用） vw：浏览器窗口宽度的1%（做全屏的布局时用） vmin：vh和vw中的较小者 （手机横屏竖屏） vmax：vh和vw中的较大者 颜色 关键字：147种颜色的关键字。如red Hex：十六进制的指定方法，如#十六进制的数 RGB &amp; RGBA RGB：rgb(255,0,0)，从0到255的数值范围内。 RGBA比RGB增加了透明度。一个元素可以是半透明的，但是其中的元素不是半透明的。rgba(0,0,0,0.1),其中最后一位表示透明度，取值范围是0-1。 HSL Hue:色相是色彩的基本属性，就是平常所说的颜色的名称，如红色、黄色等。取值范围是0-360,按角度取值。一般固定 Saturation:饱和度是指色彩的纯度，值越高色彩越纯，越低则逐渐变灰。取值范围是0-100% Lightness:亮度，越高颜色越亮。取值范围是0-100%,三个数字来表示颜色。 例如：hsl(0,50%,50%,50%)、hsla(120,50%,30%,0.5)]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-浮动(3)]]></title>
    <url>%2F2018%2F06%2F13%2F%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[浮动定位模式 常规流( Normal Flow) 浮动 (Float) 绝对定位 (Absolute Positioning) 常规流 除根元素、浮动元素、绝对定位元素外，其他元素都在常规流之内(in-flow) 而根元素、浮动和绝对定位的元素会脱离常规流(out of flow) 常规流中的盒子，属于块级格式化上下文或行级格式化上下文 块级格式化上下文（Block Formatting Context） 盒子在容器(包含块)内从上到下一个接一个地放置 两个兄弟盒之间的竖直距离有margin属性决定 同一个BFC内垂直margin会合并 盒子的左外边缘挨着容器(包含块)的左边 行级格式化上下文（inline Formatting Context） 盒子一个接一个水平摆放 盒之间的水平margin，border和padding都有效 同一行的盒子所在的举行区域叫行盒(Line box) 当一个行盒放不下上下文内所有盒子时，会被分到多个垂直堆叠的行盒里 行盒内的水平分布有text-align属性决定 如果一个行级块无法分割(单词、inline-block),该元素会被作为一个整体决定分布在哪一个行盒 float 浮动元素从常规流中脱离，被漂浮在容器(包含块)左边或右边 浮动盒会一直漂到其外边缘挨到容器边缘或另外的浮动盒 浮动元素不会影响其后面的流内块级盒 但是浮动元素后面的行级盒子会变短以避开浮动元素1234567891011121314151617181920212223&lt;section&gt; &lt;img src="https://ubmcmm.baidustatic.com/media/v1/0f000csC0xlmAaJk3ffAt0.jpg" alt="house"&gt;&lt;p&gt; &lt;span&gt; 浮动元素从常规流中脱离,被漂浮在容器(包含块)左边或右边, 浮动盒会一直漂到其外边缘挨到容器边缘或另外的浮动盒, 浮动元素不会影响其后面的流内块级盒, 但是浮动元素后面的行级盒子会变短以避开浮动元素。 &lt;/span&gt;&lt;/p&gt;&lt;style&gt; img&#123; float: left; &#125; p&#123; border:1px solid red; font-size: 14px; line-height: 1.8; &#125; span&#123; border:1px solid green; &#125;&lt;/style&gt; clear 浮动元素会对后面的行级元素产生影响,clear:both可以清除浮动,使后面的块级元素永远处于浮动元素下面 指定元素那一边不能与之前的浮动框相邻 取值： left | right | both clearfix1234567.clearfix:after&#123; content:''; display:block; clear:both; height:0; overflow:hidden;&#125; 相当于在浮动元素父级后面添加了一个空div,并且cler:both 块级格式化上下文（BFC）的特性 BFC内的浮动元素不会影响到BFC外部的元素 BFC 的高度会包含其内的浮动元素 BFC 不会和浮动元素重叠 BFC 可以通过overflow:hidden等方法创建 BFC的创建 浮动框 绝对定位框 非块级的块容器(inline-block) overflow 属性非visible的块框 BFC的作用 清除浮动 防止margin折叠 双栏布局 外边距叠加 两个或多个毗邻的普通流中的块元素垂直方向上的 margin 会折叠 两个或多个:说明其数量必须是大于一个,又说明，折叠是元素与元素间相互的行为，不存在 A 和 B 折叠，B 没有和 A 折叠的现象。 毗邻:是指没有被非空内容、padding、border 或 clear 分隔开，说明其位置关系。注意：在没有被分隔开的情况下，一个元素的 margin-top 会和它普通流中的第一个子元素(非浮动元素等)的 margin-top 相邻;只有在一个元素的 height 是 “auto” 的情况下，它的 margin-bottom 才会和它普通流中的最后一个子元素(非浮动元素等)的 margin-bottom 相邻。 垂直方向:是指具体的方位，只有垂直方向的 margin 才会折叠，也就是说，水平方向的 margin 不会发生折叠的现象。 解决办法 浮动元素、inline-block元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠（注意这里指的是上下相邻的元素） 创建了BFC的元素和它的子元素不会发生margin折叠 触发BFC因素的子集(浮动元素、inline-block元素、绝对定位元素)，也就是说如果我为上下相邻的元素设置了overflow:hidden,虽然触发了BFC，但是上下元素的上下margin还是会发生折叠 可以给叠加父元素添加padding、border、clear来解决它与子元素发生margin折叠1234567891011121314151617181920212223&lt;section&gt; &lt;div&gt;hahahh&lt;/div&gt; &lt;h1&gt;this is h1&lt;/h1&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; section&#123; margin-top:10px; &#125; div&#123; /* 这里的inline-block可以,但是如果用overflow:hidden;却不可以 */ display: inline-block; margin-bottom:50px; outline: 1px solid red; &#125; h1&#123; margin-top:100px; outline: 1px solid red; &#125; &lt;/style&gt;&lt;/section&gt; 父元素添加padding、border、clear来解决它与子元素发生margin折叠1234567891011121314&lt;section&gt; &lt;div&gt;hahahh&lt;/div&gt; &lt;style&gt; section&#123; margin-top:10px; outline: 1px solid #000; border:1px solid #eee; &#125; div&#123; margin-top:50px; outline: 1px solid red; &#125; &lt;/style&gt;&lt;/section&gt;]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-文本样式(2)]]></title>
    <url>%2F2018%2F06%2F12%2F%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[css-文本样式字体注意：字体是可以向下继承的,但是所有的表单元素都是无法继承body的字体属性的， font-family 使用逗号分隔的字体族或者族类名称 初始值有浏览器设置决定,可继承 有两种类型的名称可用于分类字体： 字体族名称（family-name） 字体族名称（就是我们通常所说的“字体”）的例子包括“Arial”、“Times New Roman”、“宋体”、“黑体”等等。它们特点是代表着不同的粗细,字号大小 通用字体族（generic family） 一个通用字体族是一组具有统一外观的字体族。sans-serif就是一例，它代表一组没有“脚”的字体。 123h1&#123; font-family:Helvetica,sans-serif;&#125; 字体匹配算法 浏览器先获取一个系统字体列表 对于元素中每一个字符,使用font-family属性及其他属性进行匹配，如果能匹配就暂定改字体 如果步骤2没有匹配上，选择下一个可选的font-family执行步骤2 如果匹配到一个字体，但是字体中没有该字符，继续对下一个可选的font-family执行步骤2 如果没有匹配到字体，使用浏览器默认字体 font-family使用 英文字体放在中文字体前面 最后总是添加通用字体族 font-size 定义文字的大小,可使用px、百分比、em等做单位 取值 绝对值xx-small | x-small | small | medium | large | x-large | xx-large 相对值 larger | smaller 长度 百分数,相对于父元素计算值 初始值为medium(有浏览器设置决定，一般16px)，可继承 em 一般是相对于元素font-size的计算值 用在font-size属性上时,是相对于父元素的font-size计算值12345678910111213141516&lt;body&gt; &lt;div&gt; 哈哈 &lt;/div&gt; &lt;style&gt; body &#123; font-size: 16px; &#125; div&#123; /* 这里的1.5em等于24px */ font-size:1.5em; /* 这里的1em等于24px */ margin-left: 1em; &#125; &lt;/style&gt;&lt;/body&gt; font-style 定义文字以斜体还是正常方式显示 取值：normal | italic(字体族的斜体) | oblique(伪斜体,字体族中没有,一般算法弄斜,一般不用) 初始值为normal,可继承 font-weight 定义文字的粗细程度 取值：normal(400) | bold(700) | bolder(比继承值粗) | lighter(比继承值细) | 100 | 200 | … | 900 初始值为normal,可继承 line-height 元素所属的line box 所占高度 初始值为normal(具体值有浏览器决定),可继承 取值：&lt;长度&gt; | &lt;数字&gt; |&lt;百分比&gt;(相当于自身font-size的1.6倍) 段落文字一般取值1.4~1.8 12345678910111213141516&lt;section&gt; &lt;h1&gt;这是一个很长的标题&lt;/h1&gt; &lt;p&gt;这是正文&lt;/p&gt; &lt;/section&gt; &lt;style&gt; section&#123; width: 10em; font-size: 12px; line-height: 1.5em; &#125; h1&#123; font-size: 30px; /* 继承section中line-height的计算值为18px */ /* 相当于line-height:18px; */ &#125; &lt;/style&gt; 1234567891011121314151617&lt;section&gt; &lt;h1&gt;这是一个很长的标题&lt;/h1&gt; &lt;p&gt;这是正文&lt;/p&gt; &lt;/section&gt; &lt;style&gt; section&#123; width: 10em; font-size: 12px; /* 当line-height取值为数字的时候,子元素继承相对值 */ line-height: 1.5; &#125; h1&#123; font-size: 30px; /* 继承section中line-height的相对值1.5,等于1.5*30 */ /* 相当于line-height:45px; */ &#125; &lt;/style&gt; font缩写1234567891011&lt;h1&gt;this is Title&lt;/h1&gt;&lt;p&gt;this is Paragraph&lt;/p&gt;&lt;style&gt; h1&#123; /* 斜体 粗细 大小/行高 字体族 */ font:bold 14px/1.7 Helvetical,sans-serif &#125; p&#123; font:14px serif; &#125;&lt;/style&gt; web Fonts 字体的加载策略中我们可知，浏览器从本地把系统中安装的所有的字体列表列出来,然后一一去匹配，这时候假如我们想使用某一字体，但是不依赖用户的电脑，可以使用css3 web Font。web Font是指将字体文件放到服务器上,可以通过在css中去引用字体文件,让浏览器使用服务器上的字体,类似图片。 12345678910111213141516171819202122&lt;h1&gt; I like javscript and css &lt;/h1&gt;&lt;style&gt;@font-face&#123; /* 字体重命名 */ font-family: 'Lobster'; font-style:normal; font-weight: 400; src:local('Lobster'), /* 本地字体 */ local('Lobster-Regular'), /* 服务器上的字体 */ url(http://lib.baomitu.com/fonts/lobster/lobster-v18-latin-regular.woff2) /* 不同的浏览器对于web Font的支持度不一样,所以需要不同的字体格式 */ /*format： 字体的格式，主要用于浏览器识别等。 */ format('woff2'), url(http://lib.baomitu.com/fonts/lobster/lobster-v18-latin-regular.woff) format('woff');&#125;h1&#123; font-family: 'Lobster',cursive;&#125;&lt;/style&gt; 中文web Font 因为中文汉字的数量过多,如果中文也想使用字体的话，加载文件会超级大,解决办法是：将一些常用的字体进行裁剪，使用部分字体,可以减少字体库的大小 字体库CDN Google Fonts 75CDN font Spider text-align 定义文本在容器内的对齐方式 取值：left | right | center | justify 初始值有HTML的dir属性决定,可继承 dir文字从左到右还是从右到左的书写顺序text-align:justify最后一行不会两端对齐,所以当只有一行文字的时候,text-align:justify不起作用 letter-spacing 指定字符之间的间距 取值： normal | &lt; length &gt; 初始值为normal,可继承1234567&lt;h1&gt; Letter Spacing 字符间距&lt;/h1&gt;&lt;style&gt; h1&#123; /* 字体大小20%的字体间距 */ letter-spacing: 0.2rem; &#125;&lt;/style&gt; word-spcing 指定单词之间的间距 取值： normal | &lt; length &gt; 初始值为normal,可继承1234567&lt;h1&gt; word Spacing 字符间距&lt;/h1&gt;&lt;style&gt; h1&#123; /* 中文不能识别,因为不知道那个是单词 */ word-spacing: 0.2rem; &#125;&lt;/style&gt; text-indent 指定文本缩进 取值： normal | &lt;长度&gt; | &lt;百分比&gt; 初始值为0,可继承123p&#123; text-indent:2em;&#125; text-decoration 定义了文本的一些装饰效果，比如下划线、删除线等 初始值为none,可继承 其他值：underline | line-through | overline white-space html中的连续空格会合并成一个空格，遇到换行符时不换行,自动换行 指定空白符如何处理 取值：normal | nowrap(不换行) | pre(html怎么显示它就怎么显示) word-break 指定是否允许在单词中间换行 取值 normal | break-all(在所有的单词会折行) | keep-all(对于能放下的单词正常折行,对于长单词才折行)]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css概念与简单选择器(1)]]></title>
    <url>%2F2018%2F06%2F12%2Fcss%2F</url>
    <content type="text"><![CDATA[css概念与简单选择器css规则 代码风格1h1&#123;color:red;font-size:14px;&#125; 1234h1&#123; color:red; font-size:14px;&#125; 使用css123&lt;!-- 外链 --&gt;&lt;!-- rel 关系意思的缩写 --&gt;&lt;link rel='stylesheet' href="/path/t0/style.css"/&gt; 12345678910&lt;!-- 嵌入 --&gt;&lt;style&gt;li&#123; margin:0; list-style:none;&#125;p&#123; margin:1em 0;&#125;&lt;/style&gt; 12&lt;!-- 内联 --&gt;&lt;p style="margin:1em 0"&gt;你好&lt;/p&gt; 注释12345678910111213/* 设置按钮宽度 */.form button&#123; width:240px;&#125;/***设置默认样式*/body&#123; margin:0; /* font-size:12px; */ /* 原理是把//color整体当作属性去解析 */ //color:#333;&#125; 简单选择器 选择器用来从页面中选择元素，以给他们定义样式 通配选择器1234/* 匹配所有元素 */*&#123; box-sizing:inherit;&#125; 标签选择器1234/* 匹配所有p元素 */p&#123; margin:1em 0;&#125; id 选择器123456789101112&lt;p id="example"&gt;Hello world&lt;/p&gt;&lt;style type="text/css"&gt;/***匹配id为example的元素*注意：id值在一个HTML中必须唯一*/#example&#123; font-size:14px;&#125;&lt;/style&gt; 类选择器1234567891011&lt;!-- 可以给一个元素指定多个class,用空格隔开 --&gt;&lt;p class="warning icon"&gt;警告信息&lt;/p&gt;&lt;style type="text/css"&gt;.warning&#123; font-size:14px;&#125;.icon&#123; background:#f00;&#125;&lt;/style&gt; 属性选择器拥有某个属性123456789&lt;input name="username" value="zhao" disabled&gt;&lt;style&gt;input[disabled]&#123; background:#eee; /* 光标禁用 */ cursor:not-allowed;&#125;&lt;style&gt; 某个属性的值是password1234567&lt;input name="password" value=""&gt;&lt;style&gt;input[type="password"]&#123; background:red;&#125;&lt;style&gt; 属性的值包含height1234567891011121314151617181920212223242526 &lt;p&gt; &lt;label&gt; height: &lt;/label&gt; &lt;input type="text"&gt;22&lt;/input&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt; weight: &lt;/label&gt; &lt;input type="text"&gt;22&lt;/input&gt; &lt;/p&gt;&lt;p&gt; &lt;label&gt; BMI: &lt;/label&gt; &lt;!-- output与input对应，output是数据的展示，for属性代表值是从哪里获取的 --&gt; &lt;output for="weight height"&gt;22&lt;/output&gt; &lt;/p&gt;&lt;style&gt; [for~="height"]&#123; color:red; &#125;&lt;/style&gt; 属性的值以什么字段开头和结尾123456&lt;p&gt;&lt;a href="#top"&gt;回到顶部&lt;/a&gt;&lt;/p&gt;&lt;style&gt;a[href^="#"]&#123; color:red;&#125;&lt;/style&gt; 123456&lt;p&gt;你可以&lt;a href="a.jpg"&gt;查看原图&lt;/a&gt;&lt;/p&gt; &lt;style&gt; a[href$='.jpg']&#123; color:red; &#125; &lt;/style&gt; 属性的值在任意位置都可以用*123456&lt;i class="icon-user"&gt;用户&lt;/i&gt;&lt;style&gt; [class*="icon-"]&#123; color:coral; &#125;&lt;/style&gt; 伪类选择器基于DOM之外的信息去(比如根据用户和网页的交互状态)选择元素12345678910&lt;!-- 未访问过的连接 --&gt;a:link &#123; ... &#125; &lt;!-- 已访问过的连接 --&gt;a:visited &#123; ... &#125; &lt;!-- 鼠标移到连接上的样式 --&gt;a:hover &#123; ... &#125;&lt;!-- 鼠标在连接上按下时的样式 --&gt;a:active &#123; ... &#125;&lt;!-- 获得焦点时的样式 --&gt;a:focus &#123; ... &#125; 选择器组合直接组合 EF123456789&lt;p class="warning"&gt;警告&lt;/p&gt;&lt;div class="warning icon"&gt;警告2&lt;/div&gt;&lt;style&gt; p.warning&#123; color:orange; &#125;&lt;/style&gt; 组合形式(标签选择器在前) E[for=”bar”] E.warning E#myid #myid.warning .warning[foo=”bar”] 后代组合 E F12345678910111213&lt;article&gt; &lt;h1&gt;你好吗？&lt;/h1&gt;&lt;/article&gt;&lt;style&gt; /* 后代选择器 */ article p&#123; color:coral &#125; /* 亲子选择器 (直接子集)*/ article &gt; p&#123; color:aliceblue &#125;&lt;/style&gt; 同时为一组选择器定义样式 E,F,B1234body,h1,h2,h3&#123; margin:0; padding:0;&#125;]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信直播]]></title>
    <url>%2F2018%2F06%2F12%2F%E5%BE%AE%E4%BF%A1%E7%9B%B4%E6%92%AD%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[小程序]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[小程序开发环境搭建 后台地址 文档地址 开发工具下载 小程序入门文件结构 App.json配置文件 wxml模板+wxss样式 js页面渲染，数据驱动页面 app.js 项目全局的入口 生命周期 全局getApp函数获取实例 全局唯一 app.json 项目全局的配置 pages window tabbar wxml+wxss 类html+css wxml类似html,数据驱动 wxss样式,新增单位rpx(宽度750rpx满屏,自适应) 配置文件,覆盖app.json里面的window比如修改title js 自带数据驱动功能 { {显示数据} } setData,数据驱动不用深究,可以用vue语法开发(mpvue) 自带组件和api api 框架提供很多api,方便调用微信原生的能力 wx.request发送请求 wx.previewImage预览图片 wx.setStorage本地存储 Location地理位置 scanCode扫码 showToast显示提示信息 获取导航条 获取用户信息 页面导航navigateTo,redirectTo,switchTab 动画、震动、截屏、亮度 音乐、视频、地图、文件 加速计、罗盘、wifi、nfc等等 组件 提供了一些基础组件，也可以自定义组件 视图 表单 媒体 原生小程序的缺点 不能使用npm，使用第三方包的方式太原始 需要为小程序单独开发代码，不能和web系统重用 开发效率和学习成本（小程序特有的语法） mpvue因为原生的小程序开发复杂,所以我们引用了mpvue(基于Vue.js的小程序开发框架.从底层支持 Vue.js 语法和构建工具体系) 使用vue开发小程序 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中 开源即热门 mpvue是什么使用vue语法开发，编译为小程序语法 一套vue程序h5+小程序 Vue组件规范，熟悉vuejs即可开发小程序 比wepy工具对vue语法支持度更高 mpvue的优点 彻底的Vue组件化开发能力：提高代码复用性 完整的vue开发体验 彻底的Vue组件化开发能力：提高代码复用性 快捷的 webpack 构建机制：开发阶段 hotReload 支持npm安装依赖 使用 Vue.js 命令行工具 vue-cli 快速初始化项目 H5 代码转换编译成小程序目标代码的能力 mpvue工作原理 mpvue对比 mpvue步骤 12vue init mpvue/mpvue-quickstart my-project npm run dev 模板语法，计算属性，条件列表渲染， vue语法+小程序自带组件+小程序api 目录结构 生命周期 vue生命周期+兼容小程序生命周期 Created 创建初始化 Vue不支持的 用小程序自己的 比如onPullDownRefresh 模板语法 computed+模板+熟悉的html 动态style和class 使用计算属性返回字符串 V-if和v-for用法不变 表单v-model全支持 事件处理 bind换成@ 使用vue的绑定语法 模板 除了动态渲染，别的都支持 .vue单文件组件 小程序自带组件也可以用 自带组件事件绑定也使用vue的，比如@click 小程序腾讯云后台小程序后台要求 购买域名+机器 购买https证书 使用pm2+nginx自己部署 腾讯小程序解决方案 Koa2+mysql+wafer-sdk（腾讯小程序解决方案） 集成微信开发工具一键上传部署 调试免费域名+环境(测试环境不要钱) 开通步骤 注册腾讯云 进入管理后台 下载nodejs demo，熟悉开发工具 开发设置 Project.config.json Npm install wafer2-client-sdk –save 腾讯云解决方案sdk 全局和局部样式 本地开发环境 本地安装mysql 指南 获取密钥和appid 配置server的config npm install –g nodemon 指node tools/initDb.js(记得mysql新建数据库) npm run dev 项目目录: https://github.com/zhangyapeng0222/weixin]]></content>
      <tags>
        <tag>node</tag>
        <tag>小程序</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6快速预览]]></title>
    <url>%2F2018%2F05%2F31%2Fes6%E5%BF%AB%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[es6快速预览let&amp;&amp;constvar的问题: var没有作用域 var不能定义常量 var可以重复定义因为这些问题,es6引入了let和const来解决它们。es6之前js的作用域只有函数作用域和全局作用域。 let块级作用域 1234if(true)&#123; let name='zyp'&#125;console.log(name)// ReferenceError: name is not defined 不能提升作用域 12345let name='zhangyapeng'if(true)&#123; console.log(name))// ReferenceError: name is not defined let name='haha'&#125; 不会污染全局变量 1234if(true)&#123; let name = 'zfpx';&#125;console.log(window.name);//undefined 闭包实现 1234567891011121314151617//es5"use strict";var _loop = function _loop(i) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000);&#125;;for (var i = 0; i &lt; 2; i++) &#123; _loop(i);&#125;//es6 的实现for(let i=0;i&lt;2;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,1000)&#125; const 定义常量，常量一旦定义就不能修改 定义值类型 12const a=1;a=2;//Assignment to constant variable 定义引用类型 123const a=[1,2,3]a=[2,3,4]//Assignment to constant variablea[0]=9//a=[9,2,3] 解构解构的意思就是分解一个对象,解构的时候，等号两边结构类似，右边还必须时以这真实的值。 解构数组 12let [name,age]=['zyp','18']console.log(name,age)//zyp,18 嵌套赋值 12let [x, [y], z] = [1, [2.1, 2.2]];console.log(x, y, z);//1,2.1,undefined 省略赋值 12let [, , x] = [1, 2, 3];console.log(x); 默认值(赋值和传参的时候可以使用默认值) 12let [a = "a", b = "b", c =new Error('C必须指定')] = [1, , 3];console.log(a, b, c);//"a","b",3 字符串模板字符串 模板字符串用反引号包含,其中的变量用${}括起来 12let name='zyp',age=18let dec=`$&#123;name&#125;is $&#123;age&#125;old!` 数组循环 12345678910111213141516171819202122/** * 实现 * &lt;ul&gt; * &lt;li&gt;zhangyapeng&lt;/li&gt; * &lt;li&gt;zuhong&lt;/li&gt; * &lt;/ul&gt;*/let arr= [&#123;name:"zhangyapeng"&#125;,&#123;name:"zuhong"&#125;]//map 映射，把老数组的每一个元素映射为新数组的每一个元素let newList=arr.map((user,index)=&gt;&#123; return ( ` &lt;li&gt;$&#123;user.name&#125;&lt;/li&gt; ` )&#125;).join('')let ul=( ` &lt;ul&gt;$&#123;newList&#125;&lt;/ul&gt; `) 自己实现模板引擎 12345678let name='zyp',age=18let dec="$&#123;name&#125;is $&#123;age&#125;old!"//replace函数function replace(dec)&#123;return dec.replace(/\$\&#123;([^&#125;]+)\&#125;/g,function(matched,key)&#123;return eval(key)&#125;)&#125; 带标签的模板字符串 12345var name = 'zyp',age = 18;function desc(strings,...values)&#123; console.log(strings,values);&#125;desc`$&#123;name&#125; is $&#123;age&#125; old!`; 可以在模板字符串的前面添加一个标签，这个标签可以去处理模板字符串,标签其实就是一个函数,因为我们有些时候希望有自己的拼接字符串逻辑,才有了这个标签的模板字符串.rest运算符,会把后面的所有参数全都放在一个数组里,rest其他运算符只能作为最后一个参数 API includes():返回布尔值，表示是否找到了参数字符串 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 repeat:返回一个新字符串，表示将原字符串重复n次12345678let s="https://www.baidu.com"s.includes("https")//trues.startsWith("https")//trues.endsWith("https")//true//还支持第二个参数，表示开始搜索的位置,endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束s.endsWith('p',4)//true//重复"x".repeat(3) 函数]]></content>
      <tags>
        <tag>es6</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp插件]]></title>
    <url>%2F2018%2F05%2F30%2Fgulp%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[gulp插件gulp-babeles5转成es612345678910const gulp = require('gulp');const babel = require('gulp-babel');gulp.task('default', () =&gt; gulp.src('src/app.js') .pipe(babel(&#123; presets: ['@babel/env'] &#125;)) .pipe(gulp.dest('dist'))); gulp-rev-appendgulp-rev-append给页面的引用添加版本号，清除页面引用缓存。通过正则(?:href|src)=”(.)[?]rev=(.)[“]查找并给指定链接填加版本号(默认根据文件MD5生成，因此文件未发生改变，此版本号将不会变)12345678910111213&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;link rel="stylesheet" href="css/style.css?rev=@@hash"&gt; &lt;script src="js/js-one.js?rev=@@hash"&gt;&lt;/script&gt; &lt;script src="js/js-two.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;hello, world!&lt;/div&gt; &lt;img src="img/test.jpg?rev=@@hash" alt="" /&gt; &lt;script src="js/js-three.js?rev=@@hash"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12345678var gulp = require('gulp'), rev = require('gulp-rev-append'); gulp.task('testRev', function () &#123; gulp.src('src/html/index.html') .pipe(rev()) .pipe(gulp.dest('dist/html'));&#125;); del在 gulpfile 中，我们希望在运行我们的编译任务之前，将 mobile 文件的内容先清理掉：123456789101112131415var gulp = require('gulp');var del = require('del');gulp.task('clean:mobile', function () &#123;//del时Promise return del([ 'dist/report.csv', // 这里我们使用一个通配模式来匹配 `mobile` 文件夹中的所有东西 'dist/mobile/**/*', // 我们不希望删掉这个文件，所以我们取反这个匹配模式 '!dist/mobile/deploy.json' ]);&#125;);gulp.task('default', ['clean:mobile']); gulp-load-plugins这个插件能自动帮你加载package.json文件里的gulp插件。 例如假设你的package.json文件里的依赖是这样的:12345"devDependencies": &#123; "gulp": "^3.9.0", "gulp-concat": "^2.6.0", "gulp-connect": "^2.2.0" &#125; 然后我们可以在gulpfile.js中使用gulp-load-plugins来帮我们加载插件12var gulp = require('gulp');var $ = require('gulp-load-plugins')(); 然后我们要使用gulp-concat和gulp-connect这两个插件的时候， 就可以使用$.concat和$.connect来代替了,也就是原始插件名去掉gulp-前缀，之后再转换为驼峰命名 gulp-concat这个插件可以把几个文件合并到一块12345678910var gulp = require('gulp');var concat = require('gulp-concat');gulp.task('concat',function()&#123; return gulp.src(['app/js/*.js','!app/js/*.tmp.js'])//指定要合并的文件glob .pipe(concat('app.js'))//进行合并并指定合并后的文件名 .pipe(gulp.dest('dist/js'));//输出到目标路径&#125;);gulp.task('default',['concat']); gulp-uglify合并后我们可以对JS文件进行压缩,最小化处理123456789101112var gulp = require('gulp');var concat = require('gulp-concat');var uglify = require('gulp-uglify')gulp.task('uglify',function()&#123; return gulp.src(['app/js/*.js','!app/js/*.tmp.js']) .pipe(concat('app.js')) //把多个JS文件合并成一个文件 .pipe(uglify()) //对合并后的app.js文件进行压缩 .pipe(gulp.dest('dist/js')); //输出到目的地&#125;);gulp.task('default',['uglify']); gulp-rename在把处理好的文件存放到指定的位置之前，我们可以先去重新命名一下它1234567891011121314var gulp = require('gulp');var concat = require('gulp-concat');var uglify = require('gulp-uglify');var rename = require('gulp-rename');gulp.task('uglify',function()&#123; return gulp.src(['app/js/*.js','!app/js/*.tmp.js'])//指定要处理的文件 .pipe(concat('app.js'))//合并成一个文件 .pipe(gulp.dest('dist/js'))//保存此文件 .pipe(uglify())//进行压缩 .pipe(rename('app.min.js'))//对此文件进行重命名 .pipe(gulp.dest('dist/js'));//再输出一次&#125;);gulp.task('default',['uglify']); gulp-minify-css压缩css1234567891011121314var gulp = require('gulp');var less = require('gulp-less');var minify = require('gulp-minify-css');//在文件的顶部去包含这个插件，起个名字，叫做 minifyvar rename = require('gulp-rename');gulp.task('minify',function()&#123; return gulp.src('app/less/page.less')//指定 less文件 .pipe(less())//把less编译成css .pipe(gulp.dest('dist/css'))//输出到目的地 .pipe(minify())//对 css再进行压缩 .pipe(rename('page.min.css'))//重命名 .pipe(gulp.dest('dist/css'));//输出到目的地&#125;);gulp.task('default',['less']); gulp-minify-html压缩html12345678var gulp = require('gulp'), minifyHtml = require("gulp-minify-html");gulp.task('minify-html', function () &#123; gulp.src('src/*.html') // 要压缩的html文件 .pipe(minifyHtml()) //压缩 .pipe(gulp.dest('dist/html'));//输出到目的地&#125;); gulp-imagemin如果要想在保证不改变图像质量的情况下，让图像文件的体积变得更小一点,我们可以使用gulp-imagemin12345678910var gulp = require('gulp');var imagemin = require('gulp-imagemin');gulp.task('copy-images',function()&#123; return gulp.src('app/imgs/**/*.&#123;jpg,png&#125;')//指定要压缩的图片 .pipe(imagemin()) //进行图片压缩 .pipe(gulp.dest('dist'));//输出目的地&#125;);gulp.task('default',['copy-images']); gulp-connect有些时候我们需要把文件放到本地服务器上去预览，gulp-connect可以帮我们创建一个本地服务器去运行我们的项目1234567891011var gulp = require('gulp');var connect = require('gulp-connect');gulp.task('server',function()&#123; connect.server(&#123; root:'dist',//服务器的根目录 port:8080 //服务器的地址，没有此配置项默认也是 8080 &#125;);&#125;);gulp.task('default',['server']); //运行此任务的时候会在8080上启动服务器 自动刷新我们希望当文件变化的时候浏览器可以自动刷新，这样我们就不需要文件修改后手动去刷新浏览器了123456789101112131415161718192021var gulp = require('gulp');var connect = require('gulp-connect');gulp.task('copy-html',function()&#123;gulp.src('app/index.html')//指定源文件 .pipe(gulp.dest('dist'))//拷贝到dist目录 .pipe(connect.reload());//通知浏览器重启&#125;);gulp.task('watch',function()&#123;gulp.watch('app/index.html',['copy-html']);//当index.html文件变化时执行copy-html任务&#125;);gulp.task('server',function()&#123;connect.server(&#123;root:'dist',//服务器的根目录port:8080, //服务器的地址，没有此配置项默认也是 8080livereload:true//启用实时刷新的功能&#125;);&#125;);gulp.task('default',['server','watch']);//运行此任务的时候会在8080上启动服务器， jshint可以用此插件进行代码检查,注意必须同时安装jshint和gulp-jshint 全部选项12345678var gulp = require('gulp'), jshint = require("gulp-jshint");gulp.task('jsLint', function () &#123; gulp.src('src/*.js') .pipe(jshint()) //进行代码检查 .pipe(jshint.reporter()); // 输出检查结果&#125;); sass的编译12345678var gulp = require('gulp'), sass = require("gulp-sass"); gulp.task('compile-sass', function () &#123; gulp.src('sass/*.sass') .pipe(sass()) .pipe(gulp.dest('dist/css'));&#125;); 自定义插件gulp.src()中这个流里的内容不是原始的文件流,而是一个虚拟文件对象流,这个虚拟文件对象中存储着原始文件的路径、文件名和内容等信息 vinyl123456789101112var File = require('vinyl');var indexFile = new File(&#123; cwd: "/",//当前路径 base: "/test/",//文件名 path: "/test/index.js",//路径 contents: new Buffer("name=zfpx")//文件内容&#125;);console.log(File.isVinyl(indexFile));//是否是vinylconsole.log(indexFile.isBuffer());//内容是否是Bufferconsole.log(indexFile.isStream());//内容是否是Stream through2through2：Node Stream的简单封装，目的是让链式流操作更加简单二进制流的方式123456789101112131415var through2 = require('through2');var fs = require('fs');fs.createReadStream('src.txt',&#123;highWaterMark:1&#125;) .pipe(through2(function (chunk, encoding, callback) &#123; for (var i = 0; i &lt; chunk.length; i++) chunk[i] = chunk[i] + 1; this.push(chunk); //向流中写数据,每push一次就发射一次data事件 callback(); &#125;)).on('data', function (data) &#123; console.log(data.toString()); &#125;).on('end', function (data) &#123; console.log('end');&#125;)//.pipe(fs.createWriteStream('dest.txt')) 对象方式1234567891011121314151617var through2 = require('through2');var fs = require('fs');var all = [];fs.createReadStream('src.txt', &#123;highWaterMark: 1&#125;).pipe(through2.obj(function (chunk, enc, callback) &#123; var data = &#123; name: chunk.toString() &#125; this.push(data); callback();&#125;)).on('data', function (data) &#123; console.log(data)&#125;).on('end', function () &#123; console.log('end')&#125;) 插件入门1234567891011121314151617181920212223242526module.exports = function (options) &#123; return through.obj(function (file, enc, cb) &#123; //file对象就是虚拟文件流 // 如果文件为空，不做任何操作，转入下一个操作，即下一个 .pipe() if (file.isNull()) &#123; this.push(file); return cb(); &#125; // 插件不支持对 Stream 对直接操作，跑出异常 if (file.isStream()) &#123; this.emit('error', new gutil.PluginError(PLUGIN_NAME, 'Streaming not supported')); return cb(); &#125; // 将文件内容转成字符串，并调用 preprocess 组件进行预处理 // 然后将处理后的字符串，再转成Buffer形式 var content = pp.preprocess(file.contents.toString(), options || &#123;&#125;); file.contents = new Buffer(content); // 下面这两句基本是标配啦，可以参考下 through2 的API this.push(file); cb(); &#125;);&#125;; 参考文档： 插件编写入门 代码]]></content>
      <tags>
        <tag>gulp</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp]]></title>
    <url>%2F2018%2F05%2F29%2Fgulp%2F</url>
    <content type="text"><![CDATA[gulp是一个前端构建工具,它通过nodejs中的stream来读取和操作数据，速度奇快。 gulp和grunt的区别Grunt主要是以文件为媒介来运行它的工作流的，比如在Grunt中执行完一项任务后，会把结果写入到一个临时文件中，然后可以在这个临时文件内容的基础上执行其它任务，执行完成后又把结果写入到临时文件中，然后又以这个为基础继续执行其它任务…就这样反复下去。而在Gulp中，使用的是Nodejs中的stream(流)，首先获取到需要的stream，然后可以通过stream的pipe()方法把流导入到你想要的地方，比如Gulp的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。所以Gulp是以stream为媒介的，它不需要频繁的生成临时文件，这也是Gulp的速度比Grunt快的一个原因。 gulp的安装 先安装node,然后全局安装gulp 1npm install -g gulp 安装局部gulp 1npm i gulp -D 在项目根目录下建立gulpfile.js文件 12345var gulp = require('gulp');gulp.task('default', function() &#123; // 将你的默认的任务代码放在这&#125;); 运行gulp 1gulp gulp的工作流程gulp的使用流程一般是 首先通过gulp.src()方法获取到想要处理的文件流 然后把文件流通过pipe方法导入到gulp的插件中 最后把经过插件处理后的流再通过pipe方法导入gulp.dest()中 gulp.dest()方法则把流中的内容写入文件中123var gulp = require('gulp');gulp.src('script/src.js') // 获取文件的流的api.pipe(gulp.dest('dist/dest.js')); // 写文件的api gulp的API对于gulp我们只需要知道4个api即可,gulp.task()、gulp.src()、gulp.dest()、gulp.watch()其他的可以参考文档 gulp.src()gulp.src()方法正是用来获取流的,它可以将匹配的文件转成流,但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流(Vinyl files)。这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息1gulp.src(globs[, options]) globs参数是文件匹配模式(类似正则表达式),用来匹配文件路径，当多个路径时，可以为数组 options为可选参数。通常情况下我们不需要用到。 gulp匹配规则时node-glob,可以了解。 gulp.dest()gulp.dest()方法是用来写文件的，其语法为：1gulp.dest(path[,options]) path写入文件的路径 options为可选参数。通常情况下我们不需要用到。 gulp.dest()传入的路径参数只能用来指定要生成的文件的目录,而不能指定生成文件的文件名 123// 最终生成的文件路径为 dist/jquery.js/jquery.js,而不是dist/jquery.jsvar gulp = require('gulp');gulp.src('script/jquery.js').pipe(gulp.dest('dist/jquery.js')); 注意：gulp.dest(path)生成的文件路径是我们传入的path参数后面再加上gulp.src()中有通配符开始出现的那部分路径通过指定gulp.src()方法配置参数中的base属性，我们可以更灵活的来改变gulp.dest()生成的文件路径1234//配置了base参数，此时base路径为script//假设匹配到的文件为script/lib/jquery.js//此时生成的文件路径为 build/lib/jquery.jsgulp.src('script/lib/*.js', &#123;base:'script'&#125;).pipe(gulp.dest('build')) gulp.task()gulp.task方法用来定义任务，内部使用的是Orchestrator，其语法为 12gulp.task(name[, deps], fn) name 为任务名 deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数 fn 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。 1234gulp.task('mytask', ['array', 'of', 'task', 'names'], function() &#123; //定义一个有依赖的任务 // Do something &#125;); 如果某个任务所依赖的任务是异步的，就要注意了，gulp并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务 1234567891011gulp.task('one',function()&#123; //one是一个异步执行的任务 setTimeout(function()&#123; console.log('one is done') &#125;,5000);&#125;);//two任务虽然依赖于one任务,但并不会等到one任务中的异步操作完成后再执行gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); 有三种方法解决： 回调函数来通知gulp这个异步任务已经完成,这个回调函数就是任务函数的第一个参数 123456789101112gulp.task('one',function(cb)&#123; //cb为任务函数提供的回调，用来通知任务已经完成 //one是一个异步执行的任务 setTimeout(function()&#123; console.log('one is done'); cb(); //执行回调，表示这个异步任务已经完成 &#125;,5000);&#125;);//这时two任务会在one任务中的异步操作完成后再执行gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); 定义任务时返回一个流对象。适用于任务就是操作gulp.src获取到的流的情况 12345678910gulp.task('one',function(cb)&#123; var stream = gulp.src('client/**/*.js') .pipe(dosomething()) //dosomething()中有某些异步操作 .pipe(gulp.dest('build')); return stream;&#125;);gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); 返回一个promise对象 1234567891011gulp.task('one',function()&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(function() &#123; resolve(); &#125;, 5000); &#125;)&#125;);gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); gulp.watch() gulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为 1gulp.watch(glob[, opts], tasks) glob 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。 opts 为一个可选的配置对象，通常不需要用到 tasks 为文件变化后要执行的任务，为一个数组 1234567gulp.task('uglify',function()&#123; //do something&#125;);gulp.task('reload',function()&#123; //do something&#125;);gulp.watch('js/**/*.js', ['uglify','reload']); gulp.watch()还有另外一种使用方式 1gulp.watch(glob[, opts, cb]) glob和opts参数与第一种用法相同 cb参数为一个函数。每当监视的文件发生变化时，就会调用这个函数,并且会给它传入一个对象，该对象包含了文件变化的一些信息，type属性为变化的类型，可以是added,changed,deleted；path属性为发生变化的文件的路径1234gulp.watch('js/**/*.js', function(event)&#123; console.log(event.type); //变化类型 added为新增,deleted为删除，changed为改变 console.log(event.path); //变化的文件的路径&#125;); 参考链接： gulp官网 前端构建工具gulpjs的使用介绍及技巧 gulp文档]]></content>
      <tags>
        <tag>gulp</tag>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npx:一个npm包执行器]]></title>
    <url>%2F2018%2F05%2F25%2Fnpx%2F</url>
    <content type="text"><![CDATA[最近小编在使用node的时候，发现了一个神器—npx,它只有在npm 5.2.0才有的欧 npx是什么？根据zkat/npx的描述,你就会发现它的神奇之处,npx可以帮你执行依赖包里面的二进制文件。 举个栗子： 举例来说，之前我们可能会写这样的命令： 12npm i -D webpack./node_modules/.bin/webpack -v 如果你对 bash 比较熟，可能会写成这样12npm i -D webpack`npm bin`/webpack -v 有了 npx，你只需要这样12npm i -D webpacknpx webpack -v 也就是说 npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装！ npx 甚至支持运行远程仓库的可执行文件，如12345678910npx github:piuccio/cowsay hellonpx: 1 安装成功，用时 1.663 秒 _______&lt; hello &gt; ------- \ ^__^ \ (oo)\_______ (__)\ )\/\ ||----w | || || 再比如 npx http-server 可以一句话帮你开启一个静态服务器！（第一次运行会稍微慢一些）npx 还允许我们单次执行命令而不需要安装；在某些场景下有可能我们安装了某个全局命令行工具之后一直忘了更新，导致以后使用的时候误用了老版本。而使用 npx create-react-app my-cool-new-app 来执行 create-react-app 命令时，它会正常地帮我们创建 React 应用而不会实际安装 create-react-app 命令行。1234567$ npx http-servernpx: 23 安装成功，用时 48.633 秒Starting up http-server, serving ./Available on: http://127.0.0.1:8080 http://192.168.5.14:8080Hit CTRL-C to stop the server]]></content>
      <tags>
        <tag>node</tag>
        <tag>npx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号]]></title>
    <url>%2F2018%2F05%2F25%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[微信公众号开发微信号的分类 企业号 不太适合与我们这种个人小型开发,是企业或组织提供移动应用入口，帮助企业建立与员工、上下游供应链及企业应用间的联系 订阅号 比较适合与个人、小团队，主要是用于信息传播，帮助管理用户以及和用户互动。比如撰写文章，咨询传播，消息定制等等 服务号 企业和组织，提供更强大的业务服务与用户管理能力，比如支付，智能接口 举个栗子 公众号 描述 订阅号 管理一个班级，一个学院的信息订阅，通知和互动 服务号 管理全学校的水果商店或者打印店,可以直接支付送货上门,及时推送一些特价水果 企业号 管理全学校所有学院，团委，学生处各个部门上班人员的考勤，活动进程等,例如OA系统 公众号的权限 公众号分为非认证和认证,认证的一般是需要你有一个开户过的企业 订阅号和服务号三点不同 出现位置不同 单月发送消息数量不同，订阅号可以一天1篇，服务号一个月最多4篇 订阅号没有9大接口和支付功能 服务号的9大接口 语音识别 客服接口 OAuth2.0网页授权 生成带参数二维码 获取用户地理位置 获取用户基本信息 获取关注者列表 用户分组接口 上传下载多媒体文件 订阅号的5大接口 会话界面的自定义菜单 多客服接口，提供贴心快捷的客服服务 获取用户地址位置，精确提供服务 高级群发接口，实现更灵活的群发功能 用户分组接口，方便管理用户 微信的交互流程 开发必备代理服务器的使用 使用localtunnel这个npm模块 需要支付6元的花生壳内网映射 免费的natpp内网映射 配置接入微信公众号 测试号的配置 验证公众号 将token、timestamp、nonce三个参数进行字典序排序 将三个参数字符串拼成一个字符串进行sha1加密 将加密后的字符串与signature对比，如果相同，表示这个请求来源与微信，我们直接原样返会echostr参数内容，接入验证成功了 获取access_token(全局票据) access_token每2个小时自动失效，需要重新获取 只更新了access_token，之前的那个就不能用了 微信js-SDK微信公众号引入网页的步骤 绑定域名 引入js文件 JS SDK初始化SDK与公众号的区别 公众号 是微信这个原生的应用中，开放的特殊账号，让很多人可以通过原生的聊天界面，与公众号互动，其实就是我们与服务器互动 微信的SDK 不是公众号中使用的，而是在微信内置的浏览器中使用的 SDK的作用形象的说：搭建了一座桥，使我们可以在微信内置的浏览器的网页中调用微信的原生应用，以及实现拍照、语音、及扫一扫等功能 SDK接口列表 基础接口 判断当前微信客户端版本是否支持指定js接口,有了这个判断，你就可以大胆的在网页中使用 温馨提示：即便是这个网页不在微信的浏览器中打开比如在电脑的浏览器打开，可以保证一些基础功能的可用性，只需要关掉跟微信 有关的功能就行，可以让这个网页不可访问，替换成一个二维码让用户来扫，也可以进入微信的环境中，算是一个折衷的方案 分享接口 图像接口 音频接口 智能接口 设备接口 地理位置 摇一摇周边 界面操作 微信扫一扫 小店 卡劵 支付 获取jsapi_ticket 参考文档与资料：微信公众号:https://mp.weixin.qq.com/wiki微信SDK:https://mp.weixin.qq.com/wikigithub项目参考:https://github.com/zhangyapeng0222/weixin]]></content>
      <tags>
        <tag>node</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo建站指南]]></title>
    <url>%2F2018%2F05%2F21%2Fhexo%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[简介hexo是一个快速、简洁且高效的静态站点生成框架，它基于 Node.js 。 它有许多的主题框架,小编选择的时Next。文档讲解的非常详细,小编就不在这里为大家介绍文档了，就写一些小编出错和注意的点。 安装安装 Hexo 只需几分钟时间，可以参考官网，若你在安装过程中遇到问题或无法找到解决方式，请留言，我会尽力解决你的问题。 安装前提 Git node 如果你的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装 安装步骤 安装hexo-cli 1npm install -g hexo-cli 安装完成后在指定的目录下执行hexo初始化 1hexo init 生成静态文件 1hexo g 启动本地静态服务器 1hexo s 发布项目 1hexo d 常见问题 - 图标显示Hexo 中的图标使用的是 Font Awesome ,所以，我们的博客已经自带了 Font Awesome 中的所有图标，基本可以满足我们的所有需求，我们可以去 Font Awesome 中查找我们想要使用的图标。123&lt;i class="fa fa-github"&gt;&lt;/i&gt;&lt;i class="fa fa-github fa-lg"&gt;&lt;/i&gt;&lt;i class="fa fa-github fa-2x"&gt;&lt;/i&gt; 常见问题 - 代码压缩优化在项目的根目录下，执行以下命令： 12cnpm install gulp -gcnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp --save-dev 然后在 gulpfile.js 里面写上相关代码，详情查看 源码 。 然后执行 gulp min 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 鼠标右键 -&gt; 查看网页源代码，可以看到已经是压缩过的。 常见问题 - 字数统计、阅读时长Next主题已经集成了字数统计、阅读时长,我们只需要在主题配置文件_config.yml中打开wordcount统计功能即可12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true # 单篇 字数统计 min2read: true # 单篇 阅读时长 totalcount: false # 网站 字数统计 separated_meta: true 如果还出现字数统计和阅读时长失效的情况，一般是因为没有安装 hexo-wordcount 插件，查看 Hexo 插件：1hexo --debug 安装 hexo-wordcount 插件1npm i --save hexo-wordcount 常见问题 - 自动备份Hexo博客源文件原理通过监听Hexo的事件来完成自动执行Git命令完成自动备份呢？通过查阅Hexo文档，找到了Hexo的主要事件，见下表： 事件名 事件发生时间 deployBefore 在部署完成前发布 deployAfter 在部署成功后发布 exit 在 Hexo 结束前发布 generateBefore 在静态文件生成前发布 generateAfter 在静态文件生成后发布 new 在文章文件建立后发布 于是我们就可以通过监听Hexo的deployAfter事件，待上传完成之后自动运行Git备份命令，从而达到自动备份的目的。 步骤 在命令中键入以下命令，完成shelljs模块的安装： 1npm install --save shelljs 编写自动备份脚本,在Hexo根目录的scripts文件夹下新建一个js文件，文件名随意取。如果没有scripts目录，请新建一个 1234567891011121314151617181920212223242526272829303132333435require('shelljs/global');try &#123; hexo.on('deployAfter', function() &#123;//当deploy完成后执行备份 run(); &#125;);&#125; catch (e) &#123; console.log("产生了一个错误&lt;(￣3￣)&gt; !，错误详情为：" + e.toString());&#125;function run() &#123; if (!which('git')) &#123; echo('Sorry, this script requires git'); exit(1); &#125; else &#123; echo("======================Auto Backup Begin==========================="); cd('D:/hexo'); //此处修改为Hexo根目录路径 if (exec('git add --all').code !== 0) &#123; echo('Error: Git add failed'); exit(1); &#125; if (exec('git commit -am "Form auto backup script\'s commit"').code !== 0) &#123; echo('Error: Git commit failed'); exit(1); &#125; if (exec('git push origin master').code !== 0) &#123; echo('Error: Git push failed'); exit(1); &#125; echo("==================Auto Backup Complete============================") &#125;&#125; 其中，需要修改第17行的D:/hexo路径为Hexo的根目录路径。（脚本中的路径为博主的Hexo路径） 如果你的Git远程仓库名称不为origin的话，还需要修改第28行执行的push命令，修改成自己的远程仓库名和相应的分支名。 常见问题 - 代码高亮 小编刚开始写的代码往往是这样的，[Next代码高亮]完全没有作用(http://theme-next.iissnan.com/theme-settings.html#syntax-highlight-scheme) 1require(&apos;shelljs/global&apos;); 原来是没有在三个`后加上语言名，如java。 1require('shelljs/global');]]></content>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodemon]]></title>
    <url>%2F2018%2F05%2F21%2Fnodemon%2F</url>
    <content type="text"><![CDATA[nodemon的配置详解nodemon 安装配置平常我们使用node的时候，经常修改一次js代码后，都要重新node xxx 才能看到改动后的效果，调试起来十分不方便。所以我引入了nodemon模块了弥补这样缺点。 首先安装nodemon 1npm i -g nodemon 安装完 nodemon 后，就可以用 nodemon 来代替 node 来启动应用： 1nodemon [your node app]（相当于 node [your node app]） 还可以来指定端口号 1nodemon ./server.js localhost 8080 可以通过帮助选项 1nodemon -h 或者 nodemon -help 有没有感觉好麻烦呀，但是nodemon大火的原因是它的灵活配置，让我们通过nodemon.json文件来了解它的其他参数。 nodemon基本配置12345678910111213141516171819202122232425&#123; "restartable": "rs", "ignore": [ ".git", "node_modules/**/node_modules" ], "verbose": true, "execMap": &#123; "": "node" "js": "node --harmony" &#125;, "events": &#123; "restart": "osascript -e 'display notification \"App restarted due to:\n'$FILENAME'\" with title \"nodemon\"'" &#125;, "watch": [ "test/fixtures/", "test/samples/" ], "env": &#123; "NODE_ENV": "development", "PORT": "3000" &#125;, "ext": "js json", "legacy-watch": false&#125; nodemon参数详解 restartable:重启命令,默认是rs,可以改成你自己喜欢的字符串。当用nodemon启动应用的时,可以直接键入rs直接重启服务。除了字符串值外，还可以设置fasle,这个值的意思是当nodemon影响你自己的终端命令时，设置为false则不会在nodemon运行期间监听rs的重启命令。 ignore: 忽略的文件后缀名或者文件夹 verbose：true表示输出详细启动与重启信息 execMap: 运行服务的后缀名和对应的运行命令,”js”: “node –harmony” 表示用 nodemon 代替 node –harmony 运行 js 后缀文件;”” 指 www 这些没有后缀名的文件;默认的 defaults.js 配置文件会识别一些文件：py:’python’,rb:’ruby’。 events:这个字段表示 nodemon 运行到某些状态时的一些触发事件，总共有五个状态： start - 子进程（即监控的应用）启动 crash - 子进程崩溃，不会触发 exit exit - 子进程完全退出，不是非正常的崩溃 restart - 子进程重启 config:update - nodemon 的 config 文件改变 watch:监控的文件夹路径或者文件路径。 env:运行环境 development 是开发环境，production 是生产环境。port 是端口号。 ext:监控指定后缀名的文件，用空格间隔 legacy-watch:nodemon 使用Chokidar作为底层监控系统，但是如果监控失效，或者提示没有需要监控的文件时，就需要使用轮询模式（polling mode），即设置 legacy-watch 为 true。nodemon监控和忽略文件的顺序 首先 nodemon 会先读取watch里面需要监控的文件或文件路径， 从文件中选择监控ext中指定的后缀名， 最后去掉从ignore中指定的忽略文件或文件路径。 参考文档：http://www.cnblogs.com/JuFoFu/p/5140302.html]]></content>
      <tags>
        <tag>nodemon</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2018%2F05%2F21%2Fgit%2F</url>
    <content type="text"><![CDATA[gitGIT基础知识 什么是git? 分布式版本控制系统，它是有Linux（全球比较大的服务器系统） 创始人花费两周时间使用C语言编写的工具（在GIT命令窗口中一般都是执行Linux命令） 什么是版本控制系统？ 在没有版本控制系统之前，我们的操作可能会向下面这样： 创建一个word文档，想要编写自己的年终总结，第一天写了一部分，第二天想接着写，但是发现还要吧第一天的内容进行修改，原有的内容就丢失了，以后也找不到了； 本质问题：后面修改的内容会替换原有内容，原有内容没保存，以后想找都找不到版本控制系统的优势 1、备份文件 2、记录历史 3、回到过去 4、多端共享 5、团队协作 常用的版本控制系统 git:分布式版本控制系统 svn:集中式版本控制系统 分布式和集中式的区别？ [集中式] 想做历史记录的查看或者备份，必须链接到中央服务器才可以（需要联网） 处理速度没有git快 [分布式] 每个开发者本地都是单独的仓库，在自己的仓库中就可以完成历史版本的记录和查看（不需要联网） 团队开发才需要中央服务器 GIT处理的速度更快（GIT是按照数据存储的） 个人可以在不联网的情况下，查看各个版本信息 其余还有一些区别，自己扩展 Linux常用命令 ~当前用户的根目录 ls 查看当前目录下的文件（或者文件夹） -l查看详细信息 -a查看隐藏文件 -la同时具备以上特点 clear 清屏 cd 目录切换 cd ../返回上级目录 cd ./返回当前目录 cd /返回根目录 cd xxx 进入到指定文件夹 cd E:进入到指定的磁盘 mkdir 创建文件夹 touch 创建空文件 可以创建无文件名的文件,例如：touch .babel 在电脑隐藏文件后缀名的情况下，我们也不至于创建1.txt.txt这样重复文件后缀名的文件 vi 向指定文件中插入内容 vi 1.txt 首先进入命令模式 我们先按i.进入插入内容模式 编辑需要写入的内容 按ESC键，再按：键，再按wq(保存并退出) 再按q!(强制退出，新输入的内容不保存) echo xxx&gt;1.txt把xxx内容放到1.txt文件中，如果没有这个文件则创建这个文件(新存放的内容会替换原有的内容) echo xxx&gt;&gt;1.txt新的内容会追加到原有内容后面 cat 查看文件中的内容 cp 拷贝文件 rm 删除文件 -r 递归删除(把当前文件夹中所有的后代元素也都遍历到删除) -f 强制删除 -rf强制递归删除，一旦rf后，没办法还原回来，所以删除要慎重慎重慎重 git工作流程及常用命令 安装完成git后，我们最好先把一些基础信息配置一下（只需要一次即可） git config -l 查看当前本机git的配置清单 [相对比较重要的配置 ：user.name/user.email],每次提交的时候知道是谁提交的 git config –global user.name xxx git config –global user.email xxx 设置的用户名和邮箱可以随便写，但是建议最好写成github/Codding等平台账号邮箱 GIT 的工作流程 git 分布式，每一台客户端都是一个独立的git仓库（有git工作的全套机制） 一个Git仓库分为三个区域： 工作区：平常写代码的地方 暂存区：把一些写好的代码暂时存放的地方 历史区： 生成一个个版本记录的地方 工作区可以看见，但是暂存区和历史区都以数据的形式保存在.git文件中 创建git仓库 在指定目录中，执行git init，相当于以当前目录作为基础，创建一个本地git仓库 创建完成后，会在项目的根目录中显示.git这个文件（隐藏文件）：有这个.git文件的才叫git仓库，没有则不能被称为git仓库（因为暂存区和历史区的内容都是存储在这个文件夹中的） 工作区提交到暂存区 git add xxx 把某个文件提交到暂存区git add . 把所有修改的文件（修改和新增的包含，删除不包含） git add -u 把所有修改的文件(包含修改和删除的，但是不包含新增)git add -A 是点和U的结合体，所有修改、新增、删除的信息都会提交到暂存区(点和-A但是真是效果中，两者差不多，用那个都可以) git status 查看当前文件的状态 红色:在工作区，还没有提交到暂存区 绿色：在暂存区，还没有提交到历史区 如果在提交内容的时候，有些内容不想提交，我们可以增加git提交的忽略文件：.gitignore(没有文件名只有后缀名)12345//=&gt;.gitignore中的信息.idea //=&gt;在使用WB打开项目或者编辑项目，会自动生成的文件node_modules //=&gt;使用npm安装模块的时候，当前安装在项目的模块都在这个文件夹中（之所以也忽略提交，是因为这里的东西太多了）.DS_Store //=&gt;MAC默认文件... 把暂存区提交到历史区 git commit git commit -m&quot;xxx&quot; 提交到历史区 git commit -a -m&#39;xxx&#39;把提交到暂存区和历史区的步骤合在一起完成（只适合已经提交过的一次的文件，被修改后，我们可以这样快速提交，对于新增加的文件，一次都没有提交过，是不允许这样操作的） [root-commit] 根提交简单理解为，第一次提交到历史区域，如果我们创建一个新的仓库，但是没有做过根提交，此时我们仓库中没有任何分支（哪怕是master）,也就不存在所谓的分支切换（当前仓库还不完整：一个工作流程走完一遍才算完整） 工作流中的一些细节知识 不管是从工作区提交暂存区，还是从暂存器提交到历史区，每个区域当前的内容是一直保存下来的，不会消失 git log / git reflog 查看历史提交记录（也相当于查看历史版本号），在没有版本回退的时候，我们用那个都可以，有历史版本回滚，git log只能查看当前回退版本以前的版本 git rm --cached . -r 可以把 . 替换为具体的文件名,从暂存区把所有内容（或者是你指定的具体文件）都撤回工作区。 不管暂存区中的内容是否已经提交到历史版本上了 也不管是你第几次放到暂存区的 统统撤回,这种方式太暴力，我们用的很少 git checkout . 把暂存区内容撤回工作区（覆盖现有工作区内容，并且工作区内容无法找回）,也可以理解为：用上一个暂存区存储的内容覆盖现有工作中的内容，工作去内容变为和上一个暂存区一样的内容，暂存区内容还在 问题：只能限制当前代码没有提交的情况，当前代码没提交回滚的就是上一次提交到暂存区的内容（和工作区内容不一样）；如果当前这次也提交了，暂存区和工作区一样，回滚回来也是一样的，这个方式解决不了 此时需要我们： 在暂存区中，回滚到上一次暂存区中的内容（暂存区先回滚一次） \ git reset HEAD . 把最新暂存区的信息回滚到工作区，替换工作区内容 \ git checkout . git diff 工作区 VS 暂存区 ： git diff 工作区 VS 历史区master 分支：git diff master 暂存区 VS 历史区 ： git diff –cached 查看不同区域之间代码的不同，我们一般都是基于可视化的页面来查看不一样的 最重要的一个回滚代码技巧： git reset --hard 版本号 回滚到指定历史版本,暂存区和工作区的内容都将被这个版本内容所代替 git log 查看版本号 --pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 --graph 显示 ASCII 图形表示的分支合并历史 --abbrev-commit仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 --oneline –pretty=oneline –abbrev-commit 的简化用法。 回滚时候指定的版本号不一定要全截取，有七八位即可 history &gt; 文件 把历史操作步骤输出 团队协作开发下的git操作 前面讲的都是单独开发，在本地建立git仓库的一系列操作流程，团队协作开发之下，流程上还是有所区别的 1、 创建中央仓库 一般是由团队技术LEADER或者指派的人完成的，仓库中默认是有一些初始化文件的。 中央仓库可能在：gitHub、Coding、自己公司的git仓库服务平台、自己公司的服务器等。。。 基于github创建远程仓库，创建完成后，会生成一个远程仓库，例：https://github.com/dapenglalala/2018test.git 作为LEADER,还需要把项目中一些基础的信息提交到远程仓库上 在自己本地上创建一个仓库，把一些基础的内容都放在仓库中 把新增加的信息提交到本地仓库历史区中 让本地仓库和远程仓库保持关联 把本地仓库历史区的信息同步（推送）到远程仓库中 让远程仓库和本地仓库保持关联： git remote add 名字（origin）远程仓库地址 git remote rm 名字 移除关联 git remote -v 查看当前仓库和那些远程仓库保持关联 … 让本地历史区信息和远程仓库信息保持同步： git push origin master 把本地信息推送到远程上 git pull origin master 把远程的拉取到本地 (origin是我们本地和远程仓库关联的那个名字，master是远程仓库的主分支) 当然我们创建完成远程仓库后,可以直接通过git clone 仓库地址 仓库别名（可以不写）的方式把远程仓库克隆到本地： 相当于在本地创建了一个仓库 也让本地这个仓库和远程仓库保持了连接（名字：origin） 也把远程仓库中现有的内容克隆到了本地 … 2、无分支模式下的团队协作 作为开发者每天来的第一件事或者提交代码之前，都要先PULL一下 [如果远程仓库和本地仓库不是同一个文件同一行代码冲突] git 会自动依赖于Fast-forward模式进行合并 自动合并后，我们重新提交即可 git add/ commit/push… [同一个文件同一行代码冲突] 找到冲突的文件，留下自己想要的代码 不管之前是否commit过，都要重新commit,然后push即可 3、单独分支管理 每天第一件事情，就是创建一个dev分支，并且切换到这个分支上 正常的开发代码，把每天开发的任务都先提交到自己的分支上 提交到远程仓库上 把本地自己分支DEV中的内容，合并到本地自己的MASTER分支下 把自己本地创建的分支删除（可以不删除，但是有的公司不希望远程中出现分支，或者避免开发人员的分支冲突，提交之前都把自己创建的分支删除掉） 和第一种只使用MASTER分支一样了，把本地最新合并的MASRER分支代码，提交到远程仓库的MASTER分支下（冲突合并即可） 操作分支的基础命令： git branch 查看现有分支 git branch xxx 创建一个新的分支 （当创建某个分支时，会把当期MASTER分支中的新信息同步到这个分支上） git checkout xxx 切换到某个分支上 git checkout -b xxx 创建一个新分支并且切换到这个分支上 git branch -D xxx 删除某个分支（一定要切换到其他分支上才可以删除当前分支） git merge xxx 合并分支内容到MASTER上（当前分支是MASTER） git log --graph/--oneline 在有分支的情况下，可以清楚查看分支的提交和合并内容（了解即可） 4、git rebase与 git merge的异同 两个使用场景是不一样的，merge只是合并另外一个分支的内容，rebase也合并另外一个分支的内容，但是会把本分支的commits顶到最顶端 用merge确实只需要解决一遍冲突，比较简单粗暴。用rebase有时候会需要多次fix冲突（原因在于本地分支已经提交了非常多的commit，而且很久都没有和上游合并过） 个人建议我个人推荐大家开发的时候，尽量及时rebase上游分支（我习惯是每周merge一次），有冲突提前就fix掉，即使我们自己的分支开发了很久（哪怕是几个月），也不会积累太多的(冲突）conflict，最后合并进主分支的时候特别轻松， 非常反对从master checkout出新分支，自己闷头开发几个月，结果最后merge进主分支的时候，一大堆冲突，自己还嗷嗷叫的行为 5、冲突解决 在rebase的过程中，也许会出现冲突(conflict). 在这种情况，Git会停止rebase并会让你去解决冲突；在解决完冲突后，用git add命令去更新这些内容的索引(index), 然后，你无需执行 git commit,只要执行:1git rebase --continue 这样git会继续应用(apply)余下的补丁。在任何时候，你可以用--abort参数来终止rebase的行动，并且”mywork” 分支会回到rebase开始前的状态。1git rebase --abort --skip跳过（注意此操作中当前分支的修改会直接覆盖目标分支的冲突部分） 6、 git merge 两种模式 请注意--no-ff参数，表示禁用Fast forward,默认操作 --ff-only 参数，表示Fast forward(快进模式)，也就是直接把master指向dev的当前提交，所以合并速度非常快.(但是这种模式下，删除分支后，会丢掉分支信息。) 可以发现 --ff-only 生成的历史记录和 rebase 十分相似，但是本质上 –ff-only 仍然是合并操作，但 rebase 并没有做合并，仅仅是提取修改到目标分支后面。 7、git reset –soft 或者 –hard 或者 git revert git reset –-soft：回退到某个版本，只回退了commit的信息，更改工作区文件。如果还要提交，直接commit即可； git reset -–hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，撤销的commit中所包含的更改被冲掉； git revert HEAD~2:Revert撤销一个提交的同时会创建一个新的提交.这是一个安全的方法，因为它不会重写提交历史（一般用在服务端） git revert可以用在公共分支上，git reset应该用在私有分支上。 如果已经git push了，使用git revert &lt;commit&gt;，恢复一个指定提交。 8、 当前分支还没开发完，突然需要到另外一个分支修复紧急bug如何处理？ 首先确认当前分支能否提交，可以提交的直接commit，但一般代码没写完不好提交，就储藏工作目录与暂存区的状态到堆栈中git stash，切换到另外一个分支修复bug后，切回本分支，git stash pop。 9、有两个稳定版本，将其中一个版本的功能应用到另外一个版本？ 比如某仓库有VIP版和普通版，分别在两个分支开发，普通版更新了一些功能，VIP版也希望将更新应用到分支，但又不能直接将普通版的分支merge过来，这个时候使用：git cherry-pick &lt;commit id&gt;将另一个分支上面的指定提交应用到当前分支上。 10、 分支太多，如何批量删除一个星期之前分支？ 1234567#!/bin/bash#删除一个星期之前的所有本地分支for k in $(git branch | sed /\*/d); do if [ -n &quot;$(git log -1 --before=&apos;1 week ago&apos; -s $k)&quot; ]; then git branch -D $k fidone 11、git tag（比如 v1.0 等等） git tag &lt;name&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息,-a指定标签名，-m指定说明文字 git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签 git tag可以查看所有标签。 git push origin &lt;tagname&gt;可以推送一个本地标签； git push origin --tags可以推送全部未推送过的本地标签； git tag -d &lt;tagname&gt;可以删除一个本地标签； git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。 12、git fetch 和git pull git fetch 并没更改本地仓库的代码，只是拉取了远程 commit 数据，将远程仓库的 commit id 更新为latest。 首先，你的每一个操作都是要指明来源和目标的，而对于 pull 来说目标就是当前分支其次，你得清楚 git 是有 tracking 的概念的，所谓 tracking 就是把来源和目标绑定在一起，节省一些操作是需要输入的参数。那么，假设你的 master 和 develop 都是 tracking 了的，于是：1234567# 当你在 master 下$ git pull# 等于 fetch origin，然后 merge origin/master# 当你在 develop 下$ git pull# 等于 fetch origin，然后 merge origin/develop 因此，若你有多个 remote，git pull [remote name] 所做的事情是： fetch [remote name] 的所有分支 寻找本地分支有没有 tracking 这些分支的，若有则 merge 这些分支，若没有则 merge 当前分支 另外，若只有一个 remote，假设叫 origin，那么 git pull 等价于 git pull origin；平时养成好习惯，没谱的时候都把 来源带上。 但是，如果我要合并 origin/master 去 develop 呢？123# 当你在 master 下$ git checkout develop # 切换到 develop，这就是 【目标】$ git pull origin master # 合并 origin/master，这就是 【来源】 那我怎么知道 tracking 了没有？ 如果你曾经这么推过：git push -u origin master，那么你执行这条命令时所在的分支就已经 tracking to origin/master 了，-u 的用处就在这里 如果你记不清了：cat .git/config，给你一张截图，注意红色方框标示的地方（上半部分是 tracking 的，下半部分是 untracking 的），由此可见，tracking 的本质就是指明 pull 的 merge 动作来源。别忘了：pull = fetch + merge。git fetch 到底干了些啥？1fetch = +refs/heads/*:refs/remotes/origin/* 它指明了 fetch 动作的来源，在本例中就是 叫做 origin 的那个 remote server 下的所有分支也就是说， git fetch 的操作就是取下上述目标的更新。但是——取下的东西到底在哪儿？就在这里：.git/FETCH_HEAD。上图特意也做了一个对比，第一次 cat 的时候没有 fetch，第二次 cat 的时候 fetch 了，于是你可以看到其中的区别，之后就可以明白 git pull 的 merge 是如何被触发的了。 提醒 git pull = git fetch + merge git fetch 拿到了远程所有分支的更新，我用 cat .git/FETCH_HEAD 可以看到其状态，若都是 not-for-merge 则不会有接下来的 merge 动作 merge 动作的默认目标是当前分支，若要切换目标，可以直接切换分支 merge 动作的来源则取决于你是否有 tracking，若有则读取配置自动完成，若无则请指明来源 13、给git pull默认加上rebase功能 git pull时可以加上–rebase参数, 使之不产生Merge点, 保证了代码的整洁, 即: git pull –rebase但每次都加–rebase似乎有些麻烦，我们可以指定某个分支在执行git pull时默认采用rebase方式：1git config branch.dev.rebase true 请使用以上命令时将 dev 修改成您自己本地的分支名字. 提示： 必须cd到你工程的目录下，才能更改分支的配置； 可以使用 git branch 命令， 列出您当前仓库中的所有本地分支；如果你觉得所有的分支都应该用rebase，那就设置：1git config --global branch.autosetuprebase always 这样对于新建的分支都会设定上面的rebase=true了。已经创建好的分支还是需要手动配置的。 14、删除分支 删除本地分支 1git branch -D [本地分支名];//删除本地master分支 删除远程分支 12git push origin --delete &lt;branchName&gt;//删除远程分支git push origin --delete tag &lt;tagname&gt;//删除远程tag 删除远程master分支 github gitlab当前分支不能为要删除分支 在github上将master分支设置成不是default的分支，这里就要选择temp分支了，因为只有两个分支。github操作，点击后面的settings，选择不是master的分支为默认。 删除本地master分支1git branch -D [本地分支名]; github 界面操作给别的仓库提交代码修改或者建议 首先fork别人的仓库 把别人的仓库克隆一份一模一样的，放到自己的账号下，变成自己的仓库（我们平时可以修改自己仓库中的源码） fork的仓库和别人的原始仓库会默认建立一些关系，我们可以把自己仓库中的和别人仓库中不一样的地方，提交给别人（pull-request） 把自己fork的仓库，克隆到本地 以后有一些新的代码心得，可以自己尝试去修改，然后同步到自己的fork的仓库中 在github中发送new pull request github 还可以发布飞后台项目 gitHub只提供了web站点的发布，后台项目没有提供必要的环境 [把整个仓库作为一个项目发布]这种模式不常用 [master 是项目代码 gh-pages分支下存储的是项目预览页面的代码] 其他人克隆研究的是master分支下的代码 看介绍页面是gh-pages分支下的代码 创建一个仓库 把仓库源码克隆到本地 把源码传到master分支上 在本地仓库中常见gh-pages分支 把介绍页面放在gh-pages分支下 把介绍页面的内容上传到github的gh-pages分支下 访问页面：https://用户名.github.io/仓库名/页面名.html(如果页面是index可以忽略不写)]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
