<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端性能优化 网络层面 构建层面 服务端层面 浏览器渲染层面 深入理解http请求的过程是前端性能优化的核心 资源的合并和压缩 减少http请求数量 减少请求资源的大小 压缩实现 html压缩 css压缩 js的压缩和混乱 合并 文件与文件之间有插入的上行请求，增加了N-1个网络延迟受 丢包问题影响更严重 经过代理服务器时可能会被断开 浏览器对于同域名下的静态资源加载数量为5个 文件合并存在的问题： 首屏渲染问题 缓存失效问题 解决办法： 公共库合并 不同页面的合并 见机行事，随机应变 图片相关的优化的核心概念文件大小、色彩丰富程度的权衡 JPG-有损压缩 png8-256色+支持透明 png24-2^24色+不支持透明 png32-2^24色+支持透明 每种图片格式都有自己的特点，针对不同的业务场景选择不同的图片格式很重要 不同格式图片常见的业务场景特点： jpg有损压缩，压缩率高，不支持透明 png支持透明，浏览器兼容好 webp压缩程度更好，在ios webview有兼容性问题 svg矢量图，代码内嵌，相对较小，图片样式相对简单的场景 场景： jpg —— 大部分不需要透明图片的业务场景 png —— 大部分需要透明图片的业务场景 webp —— 安卓全部 svg矢量图 —— 图片样式相对简单的业务场景 进行图片压缩 针对真实图片情况，舍弃一些相对无关紧要的色彩信息 css雪碧图 Image inline(base64) CSS雪碧图 把你的网站上用到的一些图片整合到一张单独的图片中 优点：减少你的网站的HTTP请求数量 缺点：整合图片比较大时，一次加载比较慢 Image inline 将图片的内容内嵌到html当中 减少你的网站的HTTP请求数量 使用矢量图 使用SVG进行矢量图的绘制 使用iconfont解决icon问题 在安卓下使用webpWebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。 使用webp\ 标签 \是HTML5中的一个新标签，类似它也可以指定多个格式的资源，由浏览器选择自己支持的格式进行加载。12345678&lt;picture class="picture"&gt;&lt;source type="image/webp" srcset="image.webp"&gt;&lt;img class="image" src="image.jpg"&gt;&lt;/picture&gt; 如果浏览器支持WebP格式，就会加载Image.webp，否则会加载Image.jpg。 即使浏览器不支持标签，图片仍然会正常显示，只是CSS可能无法正确选取到Picture元素。比如在IE8中，下面的CSS就不会起作用：1.picture img &#123; width: 100px; height: 100px;&#125; 但是可以这样来给图片写样式：1.image &#123; width: 100px; height: 100px;&#125; 即使浏览器使用的是WebP格式的图片，最终还是会应用img元素的样式。 不过只要使用了，使旧的浏览器支持这个标签，CSS选择器就可以正常使用了。这种方法是最简单的，但是不能作用于CSS中的图片（如背景） webp的格式:http://www.a.jpg_.webp 图片压缩:https://tinypng.com/css和js加载与执行一个网站在浏览器端是如何进行渲染的呢？html页面渲染的过程 特点 顺序执行、并发加载 是否阻塞 依赖关系 引入方式 顺序执行、并发加载 词法分析 并发加载 并发上限 css阻塞 css head中阻塞页面的渲染、link标签加载完才渲染 css阻塞js的执行 css不阻塞外部脚本的加载 js可能修改dom,有可能涉及到css修改，是基于前面执行的css来修改 js阻塞 直接引入的js阻塞页面的渲染 js不阻塞资源的加载 js顺序执行，阻塞后续js逻辑的执行 依赖关系 页面渲染依赖于css的加载 js的执行顺序的依赖关系 js逻辑对于dom节点的依赖关系 js引入方式 直接引入 defer async 异步动态引入js 加载和执行的一些优化点 css 样式表置顶 用 link 代替 import js 脚本置底 合理使用 js 的异步加载能力 懒加载 图片进入可视区域之后请求图片资源 对于电商等图片很多，页面很长的业务场景适用 减少无效资源的加载 并发加载的资源过多会阻塞js的加载，影响网站的正常使用 12345678&lt;img src="" data-origin="" /&gt;&lt;script&gt;var vierHeight=document.documentElement.clientHeight//可是区域的高度react=item.getBoundingClientReact() 是否在可视区&lt;/script&gt;&lt;!-- img要设置高度 --&gt; 预加载 图片等静态资源在使用之前的提前请求 资源使用到的时能缓存中加载，提升用户体验 页面展示的依赖关系维护 预加载方式 html标签 1&lt;img src="http://xxx/jpg" style="display:none" /&gt; 使用Image对象 12var image=new Image()image.src="http://xxx.jpg" 使用XMLHttpRequest对象请求 preload.js 重绘和回流css性能让javascript变慢 css:UI渲染单独的进程 js:javascript解析的进程 UI渲染与javascript解析是互斥的执行的 频繁触发重绘与回流，会导致UI频繁渲染，最终导致js变慢 回流 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow) 当页面布局和几何属性改变时就需要回流 重绘当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 注意： 回流必将引起重绘 而重绘不一定会引起回流 触发页面冲布局的属性 盒子模型相关属性会触发重布局 定位属性及浮动也会触发重布局 改变节点内部文字结构也会触发重布局 只触发重绘的属性 新建DOM的过程 获取DOM后分割为多个图层 对每个图层的节点计算样式结果（Recalculate style–样式重计算） 为每个节点生成图形和位置（Layout–回流和重布局） 将每个节点绘制填充到图层位图中（Paint Setup和Paint–重绘） 图层作为纹理上传至GPU 符合多个图层到页面上生成最终屏幕图像（Composite Layers–图层重组） 注意： 将频繁重绘回流的DOM元素单独作为一个独立图层，那么这个DOM元素的重绘和回流的影响只会在这个图层中。 因为合并图层的时候,也就是Composite Layers，会消耗大量的时间，所以尽量少建立图层，除非该图层影响页面性能大的时候。 如何将DOM元素变成新的独立图层？Chrome创建图层的条件 3D或透视变换（perspective transform）CSS属性 使用加速视频解码的&lt;video>节点 拥有3D（WebGL）上下文或加速的2D上下文的&lt;canvas>节点 混合插件（如Flash） 对自己的opacity做CSS动画或使用一个动画webkit变换的元素 拥有加速CSS过滤器的元素 元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里） 元素有一个z-index较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染） 代码实现12345/* 两个都可以*/*&#123; transfrom:translateZ(0); will-change:transform;&#125; 开启Layers 开启paint(渲染视图) 用例：gif可以使用创建图层，因为gif图会频繁的重绘,但是img标签本身不会创建图层，所以需要我们去创建 优化方案 避免使用触发重绘、回流的css属性 将重绘、回流的影响范围限制在单独的图层之内 图层不能被滥用 实战优化点 用translate替代top改变 用opacity替代visibility 不要一条一条地修改 DOM 的样式，预先定义好 class，然后修改 DOM 的 className 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次Reflow回流)，然后你修改100次，然后再把它显示出来 不要把 DOM 结点的属性值 (offsetHeight)放在一个循环里当成循环里的变量 不要使用table布局，可能很小的一个小改动会造成整个table的重新布局 动画实现的速度的选择 对于动画新建图层 启用GPU硬件加速 GPU加速(WebGL、3d) GPU是并行运算的,对于并行运算的纹理绘制，会非常快 因为数据在cpu上,如果GPU加速，要把数据从cpu传输到GPU上，如果数据过多，要慎重考虑 浏览器储存Cookie 因为HTTP请求无状态，所以需要cookie去维持客户端状态 cookie的生成方式 用于浏览器端和服务器端的交互 客户端自身数据的存储 http response header中的set-cookie js中可以通过document.cookie可以读写cookie 过期时间expire 仅仅作为浏览器存储（大小4KB左右，能力被localstorage替代） httponly不支持js的读写 cookie中在相关域名下面 —— cdn的流量损耗 cdn的域名和主站的域名要分开 LocalStorage HTML5设计出来专门用于浏览器存储的 大小为5M左右 仅在客户端使用，不和服务端进行通信 接口封装较好 浏览器本地缓存方案 SessionStorage 会话级别的浏览器存储 大小为5M左右 仅在客户端使用，不和服务端进行通信 接口封装较好 对于表单信息的维护 IndexedDB IndexedDB 是一种低级API，用于客户端存储大量结构化数据。该API使用索引来实现对该数据的高性能搜索。虽然Web Storage对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案。 为应用创建离线版本 PWAPWA (Progressive Web Apps) 是一种 Web App 新模型，并不是具体指某一种前沿的技术或者某一个单一的知识点，我们从英文缩写来看就能看出来，这是一个渐进式的 Web App，是通过一系列新的 Web 特性，配合优秀的 UI 交互设计，逐步的增强 Web App 的用户体验。 特点 可靠：在没有网络的环境中也能提供基本的页面访问，而不会出现“未连接到互联网”的页面。 快速：针对网页渲染及网络数据访问有较好优化。 融入（Engaging）：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性 检测PWA的支持度 lighthouse Service Worker Service Worker是一个脚本，浏览器独立于当前网页，将其在后台运行,为实现一些不依赖页面或者用户交互的特性打开了一扇大门。在未来这些特性将包括推送消息,背景后台同步， geofencing（地理围栏定位），但它将推出的第一个首要特性，就是拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。 特点 使用拦截和处理网络请求的能力，去实现一个离线应用 使用service Worker在后台运行同时能和页面通信的能力，去实现大规模后台数据的处理 应用 chrome://serviceworker-internals/ chrome://inspect/#service-workers 测试页面12345678910111213141516171819202122232425// 当前页(function () &#123; if (navigator.serviceWorker) &#123; var msgIpt = document.getElementById('ipt'), showArea = document.getElementById('show'), sendBtn = document.getElementById('sendBtn'); navigator.serviceWorker.register('service-worker3.js'); navigator.serviceWorker.addEventListener('message', function (event) &#123; showArea.innerHTML = showArea.innerHTML + ('&lt;li&gt;' + event.data.message + '&lt;/li&gt;'); &#125;); sendBtn.addEventListener('click', function () &#123; // 发送数据 navigator.serviceWorker.controller.postMessage(msgIpt.value); msgIpt.value = ''; &#125;); &#125;&#125;)(); 123456789101112131415161718192021222324252627282930313233//servers-workself.addEventListener('message', function(event) &#123; var promise = self.clients.matchAll() .then(function(clientList) &#123; var senderID = event.source ? event.source.id : 'unknown'; if (!event.source) &#123; console.log('event.source is null; we don\'t know the sender of the ' + 'message'); &#125; clientList.forEach(function(client) &#123; if (client.id === senderID) &#123; return; &#125; client.postMessage(&#123; client: senderID, message: event.data &#125;); &#125;); &#125;); if (event.waitUntil) &#123; event.waitUntil(promise); &#125;&#125;);self.addEventListener('activate', function(event) &#123; event.waitUntil(self.clients.claim());&#125;); 缓存 httpHeader response request max-age s-max-age private public no-cache no-store max-age cache-control最大过期时间,优先级更高http1.1 expireshttp1.0 过期时间 优先级低 返回200 s-maxage 优先级比max-age高 只能指定public设备的缓存，就是定义cdn的缓存时间 private缓存设备指代浏览器，只能当前用户访问的缓存设备 public缓存设备例如cdn缓存设备，可以支持多用户访问缓存信息 no-cahce 不会像max-age一样，不往服务器发请求，而直接读取本地缓存 会让浏览器发请求到服务器，让服务器判断当前缓存是否可用，和last-modified配合使用 no-store配置no-store就不使用任何缓存策略 Expires 缓存过期时间,用来指定资源到期的时间，是服务器端的具体时间点 告诉浏览器在过期时间前浏览器可以直接从浏览器缓存中读取数据，而无需再次请求 协商缓存（客户端和服务端协商的结果）（缓存304，没匹配上缓存200）Last-Modifed/IF-Modified-Since 基于客户端和服务器端协商的缓存机制 last-modified—-response header if-modified-since—-request header 需要与cache-control共同使用,max-age没有过期先走max-age ####### last-modified有什么缺点？ 某些服务端不能获取精确的修改时间 文件修改时间改了，但是文件内容却没有变 毫秒级别的修改不能区分 Etag/If-None-Match 文件内容的hash值 etag–response header if-none-match—request header 需要与cache-control共同使用 如果同时有etag和last-modified存在，在发送请求的时候会一次性的发送给服务器，没有优先级，服务器会比较这两个信息（在具体实现上，大多数做法针对这种情况只会比对etag）。服务器在输出上，如果输出了etag就没有必要再输出last-modified（实际上大多数情况会都输出）。 分级缓存策略浏览器输入 url 之后敲下回车，刷新 F5 与强制刷新(Ctrl + F5)，又有什么区别？实际上浏览器输入url之后敲下回车就是先看本地cache-control、expires的情况，刷新(F5)就是忽略先看本地cache-control、expires的情况，带上条件If-None-Match、If-Modified-Since，强制刷新(Ctrl + F5)就是不带条件的访问。 值得注意的是，如果是 浏览器输入url之后敲下回车 你在network里面看到的状态往往是200，但是大小是0。这是因为这个200是上次访问资源返回的状态码。 如果你是一位开发者，还是建议在 Chrome 里面开启Disable Cache. 查看缓存: http://qqbrowser://view-http-cache/ chrome://about/ 服务端性能优化 vue渲染面临的问题 首屏加载问题 下载vue.js 执行vue.js 生成html页面 以前没有前端框架时 用jsp/php在服务器端进行数据的填充 发送给客户端就是已经填充好数据的html 使用Juqery异步加载数据 使用React和Vue前端框架 vue性能进行提升方案 构建层模板编译 数据无关的prerender的方式 服务端渲染]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染]]></title>
    <url>%2F2018%2F09%2F05%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[Get Started有这样几个问题，我们来思考一下： 我们平常浏览的网页是否是应用 在操作系统中的应用是如何运行的 浏览器究竟是什么 webkit和浏览器的关系 浏览器是如何呈现页面的 经典问题：从浏览器的地址输入一个网址直到网页内容呈现完毕，发生了哪些事情 基本概念浏览器浏览器是用户访问互联网最重要的接口 本质上,浏览器是方便一般互联网用户通过界面解析和发送HTTP协议的软件 浏览器历史 1991年，第一个浏览器WorldWideWeb(后改为Nexus),功能简单，不支持图片 1993年，Mosaic浏览器出现，可以显示图片，为了区分浏览器是否显示图片，出现了UserAgent 1994年，Mozilla浏览器出现,也就是后面大名鼎鼎的网景浏览器Netscape,它的UserAgent为Mozilla/1.0 1995年，IE浏览器出现，为了抢夺市场，UserAgent为Mozilla/1.22 1998年，网景浏览器失利，成立Mozilla组织 2003年，网景公司解散，Mozilla基金会成立，这个组织推进了后来的Firefox Mozilla开发了Geoko,变成了Firefox，他的UserAgentMozilla/5.0 群雄并起，众多公司的浏览器的UserAgent上都带有Mozilla chrome和safari出现，占有了很大的份额 问题： 最初的浏览器做了哪些事情 创建一个TCP连接 发送一个文本协议(请求头) 解析页面的操作(不解析图片) User-Agent的起初意义 告诉服务器,当前浏览器的版本，系统 起初为了区分浏览器是否支持图片 查看用户代理 打开chrome浏览器的控制台 在控制台输入navigator.userAgent 会发现类似的字符串Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36 用户代理的作用 判断浏览器类型，采用兼容方案 判断是否为移动端 标识H5容器，方便调用H5容器特定接口 要注意userAgent伪装成本很低，不要过于依赖 内核对于操作系统来说，内核是操作系统的核心，是第一层基于硬件的软件扩充，提供最核心最基础的服务 应用程序通过内核进行系统调用来使用计算机的硬件，内核代码简介高效,并且基本没有bug,由于是最底层的服务，一点微小的错误也会造成整个系统的崩溃。好处当然也显而易见，基于一个稳定的内核，开发者可以构建适合不同场景的操作系统和应用软件 对于浏览器来说，同样存在浏览器内核，与操作系统内核相似，浏览器内核需要提供API给浏览器开发者使用，同时提供最核心的功能，如加载和渲染网页，调用操作系统所提供的服务 对于浏览器厂商来说，高效使用和开发浏览器内核是核心问题。对于web开发者来说，理解浏览器内核的基本机制，才能开发出高性能的web应用 浏览器内核知识浏览器内核定义我们可以初步认为浏览器中负责将表示页面的字符串转变成可视化的图像的模块就是浏览器内核 回到”从输入URL…”的问题我们将输入URL到远程内容返回之前的阶段略过，从Response开始：使用Node.js的TCP模块来获取，远程主机究竟给我们返回了什么：12345678910111213141516171819202122232425262728const net = require('net')const fs = require('fs')const path = require('path')const desPort = 80const desHost = '123.57.205.204'let allBuffer = nullconst client = net.createConnection(desPort, desHost, function () &#123; console.log('connected to server!') client.write(`GET / HTTP/1.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.9\r\nCache-Control: no-cache\r\nConnection: keep-alive\r\nCookie: __cfduid=dcc794c22f91c478f5c0e21bd2a4dc4a71535945679; __root_domain_v=.zhufengpeixun.cn; _qddaz=QD.54jl6y.ec9qho.jllqeote; pgv_pvi=4490024960; tencentSig=320538624; IESESSION=alive; pgv_si=s8736718848; Hm_lvt_418b1c90fa35dc210dd5d2284d9f9f29=1535945692,1535963228,1536047064,1536110767; Hm_lvt_5ca1e1efc366a109d783a085499d59d9=1535964808,1536111794; Hm_lpvt_5ca1e1efc366a109d783a085499d59d9=1536111794; Hm_lpvt_418b1c90fa35dc210dd5d2284d9f9f29=1536140224; _qdda=3-1.1; _qddab=3-vgg4fx.jloy87b0; _qddamta_2852156370=3-0\r\nHost: www.zhufengpeixun.cn\r\nPragma: no-cache\r\n Upgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36\r\n\r\n`)&#125;)client.on('data', function (data) &#123; if (!allBuffer) &#123; allBuffer = data &#125; else &#123; allBuffer = Buffer.concat([allBuffer, data]) &#125;&#125;)client.on('error', function (err) &#123; console.log(err)&#125;)client.on('end', function () &#123; const htmlContent = allBuffer.toString() const ws = fs.createWriteStream( path.join(__dirname, 'zhufeng.html') ) ws.write(htmlContent)&#125;) 几个问题: 以上这段代码的逻辑 返回的字符串该如何解析 想让返回的字符串呈现为图像，怎么做 远程主机响应HTTP协议请求报文格式： 起始行:[方法][空格][请求URL][空格][HTTP版本][换行符] 首部:[首部名称][;][可选空格][首部内容][换行符] 首部结束:[换行符] 实体 响应报文格式: 起始行：[HTTP版本][空格][状态码][空格][原因短语][换行符] 首部:[首部名称][;][可选空格][首部内容][换行符] 首部结束:[换行符] 实体 换行符:\r\n 响应组成响应内容解析如下：1234567891011HTTP/1.0 302 FoundLocation: https://www.baidu.com/error.htmlServer: bfeDate: Wed, 05 Sep 2018 10:10:32 GMTContent-Length: 0Content-Type: text/plain; charset=utf-8# 实体内容 当前为html&lt;!DOCTYPE html&gt;&lt;HTML&gt;....&lt;/HTML&gt; 网页内容的组成 doctype:提供浏览器html版本信息，html解析器用那个版本解析 head:html头部 meta:元数据信息 charset:此特性声明当前文档所使用的字符编码 http-equiv:客户端行为，如渲染模式，缓存等 name[keywords]:搜索引擎使用 name[description]:搜索引擎使用 name[viewport]:浏览器视口设置 link script:需要在body前完成加载或运行的脚本 body:html实体 script:需要在body解析时加载或运行的脚本 问题:X-UA-Compatible是什么X-UA-Compatible是针对IE8新加的一个设置，对于IE8之前的浏览器是不识别的，这个区别与content=&quot;IE=7&quot;在无论页面是否包含&lt;!DOCTYPE&gt;指令，都像是使用了 Windows Internet Explorer 7的标准模式。而content=&quot;IE=EmulateIE7&quot;模式遵循&lt;!DOCTYPE&gt;指令。对于多数网站来说，它是首选的兼容性模式。 为了避免制作出的页面在IE8下面出现错误，建议直接将IE8使用IE7进行渲染。也就是直接在页面的header的meta标签中加入如下代码：1&lt;meta http-equiv="X-UA-Compatible" content="IE=7" /&gt; 渲染需要做的工作 上图表示了渲染引擎的一般渲染过程，虚线表示该阶段所依赖的外部模块（不属于渲染引擎） 重要组件 html解释器:解释HTML文本解释器，html文本-&gt;DOM树 css解释器：遇到级联样式时,需要使用级联样式表解释器，为DOM对象计算出样式信息 Javascript引擎:遇到js代码时,需要使用Javascript解释器，并使得js代码有调用DOM接口和CSSOM接口的能力 布局:结合CSS,计算出每个DOM对象的大小位置信息 绘图:将经过布局计算的DOM节点绘制成图像 以上重要组件组成了渲染引擎： 思考几个问题： 通过响应的内容，我们可以看到内容中还存在许多外联资源，浏览器是如何处理的？ 著名的优化:”css放在头部，js放在尾部”,为什么？ 浏览器在渲染之前或者之后还需要做那些事情 移动端的浏览器和pc端的浏览器是否相同 浏览器内核架构回答上一节 不同的外联资源，webkit中有不同的资源加载器。当浏览器解析到URL地址时，调用特定的资源加载器，如果不是特殊资源，加载过程不会阻碍渲染过程 一般来说css资源不会阻碍渲染过程，但Javascript资源在的浏览器中，会阻碍渲染过程的进行。如果放置在头部，渲染过程会暂停,造成”白屏”.但现代浏览器的优化已经做的很好了，preload，所以当渲染被阻塞时，浏览器会开启新的线程继续渲染。 渲染之前需要加载资源，渲染之后在DOM或者css变化后，重新进行布局计算和重渲染操作 功能基本相同，但所运用的操作系统不同，渲染机制有差异 内核架构根据上面的问题回答我们会发现，webkit仅仅包含渲染功能是不够的，因为它需要获取网络资源，支持不同的浏览器，支持不用的操作系统，同样还要包含调试工具。 所以我们应该给出一张更全的webkit架构图:虚线框表示该部分模块在不同浏览器使用webkit的实现是不一样的，实线框是基本一致的。 Chromium架构基于webkit内核就可以构建浏览器应用，了解著名的chromium浏览器对我们的web开发也有很多启发 几个问题 除去webkit内核完成的功能，浏览器的工作有哪些？ 进程是什么？ IPC是什么？ 线程是什么？ 线程同步是什么？ 现代浏览器的工作？ 资源管理 多页面管理：也就是多个标签页的管理 插件和扩展：如flash,油猴，chrome扩展程序 账户和同步 安全机制 多系统支持 进程和线程 进程：对CPU,主存，IO设备的抽象，操作系统对一个正在进行的程序的抽象 线程：组成进程的执行单元 进程通信：进程间传输数据（交换信息） 线程同步 进程通讯的方式线程同步的方式 Chromium的多进程架构chromium的模块：主要进程介绍： Browser进程：主进程,负责浏览器页面，页面管理等 render进程：渲染进程 NPAPI插件进程 GPU进程：当GPU硬件加速打开时才会创建 多进程架构的目的所在： 职责分离，故障范围小 隔离性 性能 javascript中的进程和线程 单线程 浏览器渲染原理总共分两步： 加载：加载渲染所必须的html代码 渲染：将html代码绘制成图像结果 加载资源加载机制资源加载器分为三类： 特定资源加载器：针对每种资源类型的特定加载器，仅加载某一种资源。对应设计模式中 的单例模式 缓存资源加载器：与常规的缓存逻辑相同，特定加载器先通过缓存资源加载器来查找是否有缓存资源，如果在资源缓存池中存在缓存资源，则取出以便使用；若不存在，发送请求给网络模块 通用资源加载器：由于加载资源大多属于网络请求，而网络请求的逻辑是可以被特定资源加载器所共享的，所以通用资源加载器只能负责通过网路获得目标资源的数据，但不负责进一步解析 资源缓存 page Cache：页面缓存 Memory Cache：内存缓存 Disk Cache:磁盘缓存 流程网络栈 确定请求类型，协议 判断是否需要建立网络连接 建立HTTP事务 建立TCP socket连接 套接字连接 预先加载 DNS预取 dns-prefetch 资源的预取 TCP preconnect TCP 相关请参考之前的网络课程 如何提高加载速度 合并请求：nginx模块，sprite雪碧图 移动端TCP请求建立慢 缓存:from cache(memory,disk),localstorage，本地缓存策略，HTTP头(结合业务) tcp 网络连接优化：tcp调优，HTTP/2,keep-alive 硬件：加大带宽，使用cdn(对象存储) 资源大小：gzip,webp，image压缩，cookie体积 预加载： dns预取 、多个cdn域名Chrome在同域名下读资源只能读5个 、异步读取js 渲染HTML 解释器解释过程资源的变换 字节流 字符流 Tokens 节点 DOM数 流程： 词法分析 XSSAuditor 语法分析 生成DOM数 词法分析通过HTMLTokenizer来进行词法分析 词法分析的任务是对输入字节流进行逐字扫描，根据构词规则识别单词和符号，分词 词法分析器的主要接口是nextToken()函数，调用者只需要将字符串传入，就会得到一个词语 注意，在这里并不涉及标签类型信息，这是之后语法分析的工作 CSS解释器Javascript引擎执行流程： 源代码 抽象语法数 字节码 解释器 JIT 本地代码 渲染 renderObject RenderLayer 布局计算 绘图无关上下文]]></content>
      <tags>
        <tag>浏览器渲染</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode插件]]></title>
    <url>%2F2018%2F08%2F29%2Fvscode%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Setting Sync 可同步包含的所有扩展和完整的用户文件夹 设置文件 快捷键设置文件 Launch File Snippets Folder VSCode 扩展设置 工作空间 为什么需要Settings Sync一开始不知道怎么备份vscode的配置,傻乎乎的把要用的插件抄下来,还有用户settings拷贝出来.每次换了电脑或者重装系统什么的都要重新备份.虽然来回调整的概率很低,但是突然哪天需要同步设置什么的就很麻烦了~至少我是在初期经常鼓捣这个编辑器,而且办公在家和公司是不同的设备~所以觉得还是很有必要的~ 步骤如下 安装插件并重启VSCODE就不用说了(安装VSCODE Settings Sync后重新加载) 重启后按快捷键 alt+shift+u (这里假设你第一次用) 它会弹出一个窗口对应的是github上面的创建个人gist的页面,如果未登录请先登录github.(github创建gist来存储设置) 保存后会生成一个key(请牢记token id,后面将会用到) 切回到vscode,他会有个输入区,就是存放刚才生成的key(输入刚才生成的key) 然后理论上他就开始对你本机的配置进行一个扫描上传了,上传完成后,他会弹出控制台提示备份(上传)插件成功 上传完成后会生成一个ID，要记下来ID和token key不同 接下来我们到另一台电脑上了下载配置.同样的先安装Settings Sync插件,并重新加载. 然后按快捷键alt+shift+d,就应该会弹出一个输入框,请在这里输入之前保存下来的token key 和 (GIST ID),回车后将会自动下载之前上传的配置. 那么下载完成后,你这台电脑修改了相关配置再次上传就好了.是不是感觉方便多了~ 其他的说明,如果在输入gist id写错了,读取不到的情况下,大概需要重置设置,按F1,输入sync,这里有重置选项.试试看~ (重置sync的gist配置信息等) 如果忘记token可以到一下地址查看token Win下：C:\Users\Administrator\AppData\Roaming\Code\User Mac下：~/Library/Application Support/Code/User/syncLocalSettings.json Linux下：~/.config/Code/User/syncLocalSettings.json进入目录后，找到 syncLocalSettings.json这个文件，查找token，并替换后面复制的值，就可以顺利进行同步配置信息了。 如果忘记gist id,可以到设置查看id 注意：(ID和key都要记下来)(恢复)插件需要用到 很重要!!! 建议上传到网盘 或者 笔记软件上 如果token无效，要在github上重新生成，先在原平台修改并生成新的gist-id，再到新平台做上述操作。https://gist.github.com/用户名/token值或gist-id值 可以查看相关数据； 还有些其他的功能例如自动上传下载等等,不是很常用,大家可以自行看看官方文档,基本的使用方法就是这样了,我写的如果有问题或者哪里不明白的可以留言- -. 插件地址：https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync]]></content>
      <tags>
        <tag>vscode</tag>
        <tag>vscode插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP]]></title>
    <url>%2F2018%2F08%2F08%2FTCP%2F</url>
    <content type="text"><![CDATA[深入理TCP/IP模型 网络模型最初是由各个互联网公司自己制定的，由于当时不规范，严重阻碍了互联网的发展，为了解决这个问题，国际标准化组织(OSI)制定了OSI模型,定义了互联网通信的标准,是设计和描述计算机网络通信的基本框架。]]></content>
      <tags>
        <tag>tcp</tag>
        <tag>http</tag>
        <tag>网路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel]]></title>
    <url>%2F2018%2F07%2F25%2Fbabel%2F</url>
    <content type="text"><![CDATA[Babel 是一个广泛使用的 ES6转码器，可以将 ES6 代码转为 ES5 代码 配置文件.babelrcpresets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。1234567891011121314# ES2015转码规则$ npm install --save-dev babel-preset-es2015# react转码规则$ npm install --save-dev babel-preset-react### 最新的规则npm install --save-dev babel-preset-stage 0-3# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 Plugin/Preset 排序 Plugin 会运行在 Preset 之前。 Plugin 会从第一个开始顺序执行。 Preset 的顺序则刚好相反(从最后一个逆序执行)。 babel-core如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块,一般在node代码中使用12345678var es6Code = 'let x = n =&gt; n + 1';var es5Code = require('babel-core') .transform(es6Code, &#123; presets: ['es2015'] &#125;) .code;// '"use strict";\n\nvar x = function x(n) &#123;\n return n + 1;\n&#125;;' babel-cliBabel提供babel-cli工具，用于命令行转码1234567891011121314151617# 转码结果输出到标准输出$ babel example.js# 转码结果写入一个文件# --out-file 或 -o 参数指定输出文件$ babel example.js --out-file compiled.js# 或者$ babel example.js -o compiled.js# 整个目录转码# --out-dir 或 -d 参数指定输出目录$ babel src --out-dir lib# 或者$ babel src -d lib# -s 参数生成source map文件$ babel src -d lib -s babel-nodebabel-cli工具自带一个babel-node命令，提供一个支持ES6的REPL环境。它支持Node的REPL环境的所有功能，而且可以直接运行ES6代码。1$ babel-node es6.js babel-registerbabel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。12require("babel-register");require("./index.js"); 需要注意的是，babel-register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。 babel-polyfill和runtime TransformBabel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy`、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign`）都不会转码。 函数和方法 Generator Set Map Array.from Array.prototype.includes polyfill 全局垫片(会污染全局变量) 为开发应用准备(平常项目) 包含core-js 和regenerate-runtime (提供async 语法编译后的运行时环境) 12npm install babel-polyfill --saveimport "babel-polyfill" runtime Transform 局部垫片(不会污染全局变量) 为开发框架准备(例如vue) 12npm install babel-plugin-transform-runtime --Save-devnpm install babel-runtime --save .babelrc的配置123456789101112&#123; "presets": [ ["@babel/preset-env",&#123; "targets":&#123; "browsers":["&gt; 1%"] &#125; &#125;] ], "plugins": [ "@babel/transform-runtime" ]&#125; 异同对于以下代码执行时1234const key='babel'const obj=&#123; [key]='foo'&#125; babel默认会编译成以下代码1234567891011function _defineProperty(obj, key, value) &#123; if (key in obj) &#123; Object.defineProperty(obj, key, &#123; value: value, enumerable: true, configurable: true, writable: true &#125;); &#125; else &#123; obj[key] = value; &#125; return obj;&#125;var key = 'babel';var obj = _defineProperty(&#123;&#125;, key, Object.assign(&#123;&#125;, &#123; key: 'foo' &#125;)); _defineProperty的帮助函数，但是这个帮助函数仅仅在当前模块中生效，因此其他模块中如果用到了同样的语法，编译后就会出现大量的重复代码。 babel-polyfillbabel-polyfill 是直接在原型链上增加方法,所以会污染全局变量和内置的对象原型 babel-runtimeBabel为了解决这个问题，提供了单独的包 babel-runtime 供编译模块复用工具函数。启用插件babel-plugin-transform-runtime 后，Babel 就会使用babel-runtime 下的工具函数，转译代码如下12345678910'use strict';var _defineProperty2 = require('babel-runtime/helpers/defineProperty');var _defineProperty3 = _interopRequireDefault(_defineProperty2);function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;var key = 'babel';var obj = (0, _defineProperty3.default)(&#123;&#125;, key, 'foo'); 但是 babel-runtime 不能转码实例方法，比如这样的代码：12'!!!'.repeat(3);'hello'.includes('h'); babel-preset-env babel-preset-latest： 支持现有所有ECMAScript版本的新特性，包括处于stage 4里的特性（已经确定的规范，将被添加到下个年度的）。 babel-preset-env 功能类似 babel-preset-latest，优点是它会根据目标环境选择不支持的新特性来转译。 实验性的属性（babel-preset-latest不支持的）需要手动安装配置相应的plugins或者presets。这样你再不需要 es20xx presets了。 问题： 为什么需要env? 大部分现代浏览器已经支持ES6的generators了，但是如果你设置了babel-preset-es2015，generator函数还是会被转译成复杂的ES5代码。其他配置 modules(string, 默认值: &quot;commonjs&quot;) 将ES6模块语法转换为另一种模块类型，可选值: 各种流行的模块化规范：”amd”、 “commonjs”、 “systemjs”、 “umd” 禁止转译：false include, exclude (Array of strings, 默认值: []) include 必须要转译的功能 (比如 覆盖有故障的本地功能)。跟单独启用相应插件是一样的。 exclude 禁止转译的功能 debug (boolean, default: false) 以下内容都会用console.log输出 : 目标环境 启用的transforms 启用的plugins 启用的polyfills useBuiltIns (boolean, 默认值: false) babel-preset-env可以实现基于特定环境引入需要的polyfill core-js， 根据需要引入ES5，ES6+标准方法的实现 安装 polyfill: npm install core-js –save 引入 polyfill: import “core-js”; babel-polyfill 包含core-js 和regenerate-runtime(提供 async语法编译后的运行时环境)。 安装 polyfill: npm install babel-polyfill –save 引入 polyfill: import “babel-polyfill”; 两种方法最终都会根据环境转译成特定的polyfill。 比如:12345import "core-js/modules/es7.string.pad-start";import "core-js/modules/es7.string.pad-end";import "core-js/modules/web.timers";import "core-js/modules/web.immediate";import "core-js/modules/web.dom.iterable"; note:在整个应用里只能引入一次polyfill，可以在 “main” 模块里一次引入。useBuiltIns 会使浏览器下载的代码变少 (最终打包的文件大小变小了)。但是不会节约内存， 因为polyfill本身只会安装缺少的部分。 基于TC39不同阶段的提案的Presets (stage-0，1，2，3等) 也是去除的候选，因为在这些statges中的标准是不断变化的。提案可以在2个月内改变。因此，直接引用一些实验性的plugins会是更好的选择。 stage 0 transform-do-expressions transform-function-bind stage 1 transform-class-constructor-call (启用) transform-export-extensions stage 2 syntax-dynamic-import transform-class-properties transform-decorators – 在提案更新中被禁用 (可以同时使用 legacy 转换,babel7默认添加到stage0中) stage 3 transform-object-rest-spread transform-async-generator-functions]]></content>
      <tags>
        <tag>babel</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mobx]]></title>
    <url>%2F2018%2F07%2F25%2Fmobx%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[promise详解]]></title>
    <url>%2F2018%2F07%2F23%2Fpromise%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[异步与同步 异步：所谓”异步”，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段,比如，在我们烧水时可以干很多事情,当水烧开后在用水洗脸。这种不连续的执行，就叫做异步。 同步:连续的执行,例如在烧水的过程中我们一直等待水烧开而不去干别的事情。 异步发展历史 callback Promise gengrator函数 async-await 高阶函数了解异步时，我们先了解一下高阶函数这个概念 高阶函数： 接收一个或者多个函数作为参数 输出一个函数 1234//判断数据类型 isTypefunction isType(type,content)&#123;return Object.prototype.toString.call(content)===`[object $&#123;type&#125;]`&#125; 偏函数–&gt; 预置参数1234567function isType(type)&#123; return function(content)&#123; return Object.prototype.toString.call(content)===`[object $&#123;type&#125;]` &#125;&#125;let isString=isType('String')isString('哈哈') 预置函数作为参数12345678910111213// loadsh _.afterfunction(times,callback)&#123; return function(--times==0)&#123; callback() &#125;&#125;let eat=after(3,function()&#123; console.log('饱了')&#125;)// 当函数执行三次之后，调用回调函数eat()eat()eat() callback123456789function read(callback)&#123; setTimeout(function()&#123; let result = 'zpfx'; callback(result); &#125;)&#125;read(function(data)&#123; console.log(data);&#125;); promise虽然callbake可以解决异步调用的问题,但是它也有诸多毛病 异步不支持try/catch,回调函数是在下一事件环中取出,所以一般在回调函数的第一个参数预置错误对象 回调地狱问题,异步多级依赖的情况下嵌套非常深，代码难以阅读的维护 多个异步在某一时刻获取所有异步的结果 结果不能通过return返回 为了解决回调地狱问题，提出了Promise对象，并且后来加入了ES6标准。Promise本意是承诺，在程序中的意思就是承诺我过一段时间后会给你一个结果 Promise的三种状态 Pending Promise对象实例创建时候的初始状态 Fulfilled 可以理解为成功的状态 Rejected 可以理解为失败的状态 先用promise解决第一个问题”回调地狱”12345678910111213// 1.txt =&gt; 2.txt// 2.txt =&gt; 我很帅let fs = require('fs');function read()&#123; fs.readFile('./1.txt','utf8',function(err,data)&#123; if(err) return console.log(err); fs.readFile(data,'utf8',function(err,data)&#123; if(err) return console.log(err); console.log(data); // 我很帅 &#125;) &#125;)&#125;read(); promise实现就轻松多了12345678910111213141516let fs = require('fs');function read(file)&#123; return new Promise(function(resolve,reject)&#123; fs.readFile(file,'utf8',function(err,data)&#123; if(err) return reject(err); resolve(data); &#125;) &#125;)&#125;read('./1.txt').then(function(data)&#123; return read(data);&#125;).then(function(data)&#123; console.log(data)&#125;).catch(function(err)&#123; console.log(err)&#125;); 当第一个then中返回一个promise，会将返回的promise的结果,传递到下一个then中。这就是比较著名的链式调用了 解决同步异步的返回结果，按照顺序 我们将多个异步请求的结果在同一时间进行汇总 1234567891011121314151617181920212223242526let fs=require('fs');let path=require("path")function after(time,callback)&#123;//可以缓存函数 当达到条件时执行 let arr=[]; return function(data)&#123; arr.push(data) if(--time===0)&#123; callback(arr); &#125; &#125;&#125;let out=after(3,function(arr)&#123; console.log(arr)&#125;)let resolve=(dir)=&gt;path.resolve(__dirname,dir)fs.readFile(resolve("1.txt"),"utf8",(err,data)=&gt;&#123;out(data)&#125;)fs.readFile(resolve("2.txt"),"utf8",(err,data)=&gt;&#123;out(data)&#125;)fs.readFile(resolve("3.txt"),"utf8",(err,data)=&gt;&#123; out(data)&#125;) 使用promise实现12345678910111213let fs = require('fs');function read(file)&#123; return new Promise(function(resolve,reject)&#123; fs.readFile(file,'utf8',function(err,data)&#123; if(err) return reject(err); resolve(data); &#125;) &#125;)&#125;Promise.all([read('1.txt'),read('2.txt')]).then(([template,data])=&gt;&#123; console.log(&#123;template,data&#125;)&#125;);// 不管两个promise谁先完成，Promise.all 方法会按照数组里面的顺序将结果返回 promise API 详解Promise.race 接受一个数组，数组内都是Promise实例,返回一个Promise实例，这个Promise实例的状态转移取决于参数的Promise实例的状态变化。当参数中任何一个实例处于resolve状态时，返回的Promise实例会变为resolve状态。如果参数中任意一个实例处于reject状态，返回的Promise实例变为reject状态。 12345Promise.race([read('1.txt'),read('2.txt')]).then(data=&gt;&#123; console.log(&#123;template,data&#125;)&#125;,(err)=&gt;&#123; console.log(err)&#125;); Promise.resolve返回一个Promise实例，这个实例处于resolve状态123Promise.resolve('成功').then(data=&gt;&#123; console.log(data);&#125;); Promise.reject返回一个Promise实例，这个实例处于reject状态12345Promise.reject('失败').then(data=&gt;&#123; console.log(data); &#125;,err=&gt;&#123; console.log(err); &#125;) Generator我们发现Promise已经可以解决了异步编程问题,但是仍然不够优雅,我们更希望编写异步代码能够像同步代码一样简洁。 genrator 函数要用* 来比标识，yield(暂停产出 ) 他会将函数分割出好多个部分，调用一次next就会向下继续执行 返回结果是一个迭代器，迭代器有一个next方法 123456789101112131415161718192021// 迭代器的实现// 迭代器 就是有next方法的，每次调用后都会返回一个done和value的属性function read(arrs)&#123; let index=0;//默认先迭代第一项 let len=arrs.length; return &#123; next()&#123; return&#123; value:arrs[index], done:index++===len?true:false &#125; &#125; &#125;&#125;let it=read(['react','vue','angular']);let flag=true;do&#123;let &#123;done,value&#125;=it.next();flag=done;console.log(value)&#125;while(!flag) generator的用法123456789101112function* read()&#123; console.log(1); let a=2* (yiled '222') console.log(a) let b=yiled 9; console.log(b) return b;&#125;let it=read()console.log(it.next('213'))//1console.log(it.next('100'))//200console.log(it.next('100'))//100 yield 后面跟着的是value的值 yield 等号前面的是我们当前调用next传进来的值 第一次next传值是无效的 1234567891011// 异步 generator 主要和promise搭配使用let bluebird=require("bluebird")let fs=require("fs")let path=require("path");let resolve=(dir)=&gt;path.resolve(__dirname,dir)let read=bluebird.promisify(fs.readFile)function *r()&#123; let content1=yield read(resolve("./1.txt"),"utf8"); let content2=yield read(resolve(content1),"utf8") return content2;&#125; 不使用co这类的迭代库实现1234567//迭代库let it=r();it.next().value.then(function(data)&#123;//2.txt it.next(data).value.then(function(data)&#123; console.log(it.next(data).value) &#125;)&#125;) co有node大神tj写的co库，可以自动的将generator进行迭代1234let co=require("co");co(r()).then((data)=&gt;&#123; console.log(data)&#125;) 手写co库123456789101112131415161718function co(it)&#123;//it是迭代器//返回promisereturn new Promise(function(resolve,reject)&#123; // 考虑到是异步调用，一般用递归实现，while实现的是同步调用 function next(d)&#123; let &#123;value,done&#125;=it.next(d); if(!done)&#123; value.then(function(data)&#123; next(data) &#125;,reject)//如果抛出异常，就立马抛出 &#125;else&#123; resolve(value) &#125; &#125; next()&#125;)&#125; async/await - 异步的终极实现 async和await就是generator和co的语法糖,使用async关键字，你可以轻松地达成之前使用生成器和co函数所做到的工作 用async来修饰函数 async 需要陪await await只能跟promise 123456789101112131415async function r()&#123; try&#123; let contetn1=await read(resolve("1000.txt"),"utf8") let contetn2=await read(resolve(contetn1),"utf8") &#125;catch(e)&#123;//如果出错会catch console.log('e',e) &#125; return 1000;&#125;//async函数返回的是promise r().then((data)=&gt;&#123; console.log(data)&#125;).catch(err=&gt;&#123; console.log(err)&#125;) async/await解决的问题有哪些 回调地狱 2.并发执行异步，在同一时刻同步返回结果 promise.all 3.解决了返回值的问题 4.可以实现try/catch Q库 我们发现无论是generator还是async/await都离不开promise,我们在介绍几个有关promise的库。 12345678910111213141516//需要下载npm install qlet Promise=require("./Promise")let Q=require("q")function read(url)&#123;return new Promise(function(resolve,reject)&#123; require("fs").readFile(url,'utf8',function(err,data)&#123; if(err)reject(err); resolve(data) &#125;)&#125;)&#125;Q.fcall(function()&#123; return 100&#125;).then(function(data)&#123; console.log(data)&#125;) blueBird blueBird中有两个常用的方法一个叫promisify另一个叫promisifyAll1234567891011function promisify(fn)&#123;//promise化 将回调函数在内部进行处理return function(...arg)&#123; return new Promise(function(resolve,reject)&#123; fn(...arg,function(err,data)&#123; if(err)reject(err) resolve(data) &#125;) &#125;)&#125;&#125;promisify(fs.readFile)(url,"utf8").then() promisifyAll(fs)将所有的方法全部增加一个promise化123456789function(obj)&#123; Object.keys(obj).forEach(function(value)&#123; if(typeof obj[key]==='function')&#123; obj[`$&#123;key&#125;Async`]=promisify(obj[key]) &#125; &#125;)&#125;promisifyAll(fs)fs.readAsync(url,"utf8").then() 实现Promise Promise是一个类,需要传递一个函数,这个函数我们称之为执行函数,函数中有两个参数resolve和reject他们也是函数，调用resolve表示成功，调用reject表示失败 pending（进行中）、fulfilled（成功）、rejected（失败) 成功就不会再调用失败,默认状态是等待状态 then是原型上的一个方法接收两个参数分别是成功的回调和失败的回调 调用resolve后会执行成功的回调，调用reject后会执行失败的回调1234567891011121314151617181920212223242526272829303132333435function Promise(excutor)&#123;//excutor是执行函数 this.status='pending'//初始状态是pending this.value=undefined;//存储成功的值 this.reason=undefined;//存储失败原因 function resolve(value)&#123;// 只有再pending才能转换成功态 if(this.status==='pending')&#123; this.value=value; this.status="fulfilled"; &#125; &#125; function reject(err)&#123; // 只有再pending才能转换失败态 if(this.status==='pending')&#123; this.reason=err; this.status="rejected"; &#125; &#125; try&#123; excutor(resolve,reject)// executor中需要传入resolve和reject &#125;catch(e)&#123; // 如果executor执行发生异常，表示当前的promise是失败态 reject(e) &#125; &#125;Promise.prototype.then(function(onFufilled,onRejected)&#123; if(this.status==='fulfilled')&#123; //成功调用回调函数 onFufilled(this.value) &#125; if(this.status==='rejected')&#123; //失败调用回调函数 onRejected(this.reason) &#125;&#125;) 异步Promise在new Promise时内部可以写异步代码,并且产生的实例可以then多次,我们可以先将then中的成功的回调和失败的回调存到数组内，当成功时调用成功的数组即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function Promise(excutor)&#123;//excutor是执行函数 this.status='pending'//初始状态是pending this.value=undefined;//存储成功的值 this.reason=undefined;//存储失败原因+ this.onFulfilledcallback=[];///存放成功的回调+ this.onRejectedCallback = []; //存放then失败的回调 function resolve(value)&#123;// 只有再pending才能转换成功态 if(this.status==='pending')&#123; this.value=value; this.status="fulfilled"; // 依次执行成功的回调+ this.onFulfilledcallback.forEach((value)=&gt;&#123;+ value()+ &#125;) &#125; &#125; function reject(err)&#123; // 只有再pending才能转换失败态 if(this.status==='pending')&#123; this.reason=err; this.status="rejected";+ this.onRejectedCallback.forEach((value)=&gt;&#123;+ value()+ &#125;) &#125; &#125; try&#123; excutor(resolve,reject)// executor中需要传入resolve和reject &#125;catch(e)&#123; // 如果executor执行发生异常，表示当前的promise是失败态 reject(e) &#125; &#125;Promise.prototype.then(function(onFufilled,onRejected)&#123; if(this.status==='fulfilled')&#123; //成功调用回调函数 onFufilled(this.value) &#125; if(this.status==='rejected')&#123; //失败调用回调函数 onRejected(this.reason) &#125; if(this.status==="pending")&#123; // 如果是等待态,就将成功和失败的回调放到数组中 //成功调用回调函数 + this.onFulfilledcallback.push(()=&gt;&#123;+ onFufilled(this.value)+ &#125;) //失败调用回调函数 + this.onRejectedCallback.push(()=&gt;&#123;+ onRejected(this.reason)+ &#125;) &#125;&#125;) Promise链式调用promise实现链式调用,返回的并不是this而是一个新的promise,因为:如果当前promise已经进入成功了的回调，回调中发生了异常如果返回的仍是当前的promise那么状态无法更改到失败态！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function Promise(excutor)&#123;//excutor是执行函数 this.status='pending'//初始状态是pending this.value=undefined;//存储成功的值 this.reason=undefined;//存储失败原因 this.onFulfilledcallback=[];///存放成功的回调 this.onRejectedCallback = []; //存放then失败的回调 function resolve(value)&#123;// 只有再pending才能转换成功态 if(this.status==='pending')&#123; this.value=value; this.status="fulfilled"; // 依次执行成功的回调 this.onFulfilledcallback.forEach((value)=&gt;&#123; value() &#125;) &#125; &#125; function reject(err)&#123; // 只有再pending才能转换失败态 if(this.status==='pending')&#123; this.reason=err; this.status="rejected"; this.onRejectedCallback.forEach((value)=&gt;&#123; value() &#125;) &#125; &#125; try&#123; excutor(resolve,reject)// executor中需要传入resolve和reject &#125;catch(e)&#123; // 如果executor执行发生异常，表示当前的promise是失败态 reject(e) &#125; &#125;Promise.prototype.then(function(onFufilled,onRejected)&#123;+ let promise2; // promise2为then调用后返回的新promise if(this.status==='fulfilled')&#123; //成功调用回调函数 + promise2=new Promise(function(resolve,reject)&#123;+ onFufilled(this.value)+ &#125;) &#125; if(this.status==='rejected')&#123; //失败调用回调函数 + promise2=new Promise(function(resolve,reject)&#123;+ onRejected(this.reason)+ &#125;) &#125; if(this.status==="pending")&#123; // 如果是等待态,就将成功和失败的回调放到数组中 //成功调用回调函数 + new Promise((resolve,reject)=&gt;&#123; this.onFulfilledcallback.push(()=&gt;&#123; onFufilled(this.value) &#125;) //失败调用回调函数 this.onRejectedCallback.push(()=&gt;&#123; onRejected(this.reason) &#125;) &#125;) + &#125;+ return promise2&#125;) resolvePromisethen返回的结果可能是promise和value或者object123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107function Promise(excutor)&#123;//excutor是执行函数 this.status='pending'//初始状态是pending this.value=undefined;//存储成功的值 this.reason=undefined;//存储失败原因 this.onFulfilledcallback=[];///存放成功的回调 this.onRejectedCallback = []; //存放then失败的回调 function resolve(value)&#123;// 只有再pending才能转换成功态 if(this.status==='pending')&#123; this.value=value; this.status="fulfilled"; // 依次执行成功的回调 this.onFulfilledcallback.forEach((value)=&gt;&#123; value() &#125;) &#125; &#125; function reject(err)&#123; // 只有再pending才能转换失败态 if(this.status==='pending')&#123; this.reason=err; this.status="rejected"; this.onRejectedCallback.forEach((value)=&gt;&#123; value() &#125;) &#125; &#125; try&#123; excutor(resolve,reject)// executor中需要传入resolve和reject &#125;catch(e)&#123; // 如果executor执行发生异常，表示当前的promise是失败态 reject(e) &#125; &#125;Promise.prototype.then(function(onFufilled,onRejected)&#123; let promise2; // promise2为then调用后返回的新promise if(this.status==='fulfilled')&#123; //成功调用回调函数 promise2=new Promise(function(resolve,reject)&#123; // x是then返回的结果 let x = onFufilled(this.value) resolvePromise(promise2,x,resolve,reject) &#125;) &#125; if(this.status==='rejected')&#123; //失败调用回调函数 promise2=new Promise(function(resolve,reject)&#123; let x= onRejected(this.reason) resolvePromise(promise2,x,resolve,reject) &#125;) &#125; if(this.status==="pending")&#123; // 如果是等待态,就将成功和失败的回调放到数组中 //成功调用回调函数 new Promise((resolve,reject)=&gt;&#123; this.onFulfilledcallback.push(()=&gt;&#123; let x=onFufilled(this.value) resolvePromise(promise2,x,resolve,reject) &#125;) //失败调用回调函数 this.onRejectedCallback.push(()=&gt;&#123; let x= onRejected(this.reason) resolvePromise(promise2,x,resolve,reject) &#125;) &#125;) &#125; return promise2&#125;)function resolvePromise(p2,x,resolve,reject)&#123; // 处理结果时,尽可能完善一些 //如果then返回的值和p2是同一个值，规范要求抛出一个类型异常 if(p2===x)&#123; return reject(new TypeError("循环引用")) &#125; let called;//表示是否调用成功或者失败 // 可能是一个thenable(带有then方法)对象 if(x!==null &amp;&amp; (typeof x === 'object' || typeof x==='function'))&#123; // x可能是promise try&#123;// 如果用defineProperty定义的then方法获取时可能会有异常 let then=x.then; // 如果then是函数,说明是promise,我们要让promse执行 if(typeof then==='function')&#123; then.call(x,function(y)&#123; if(called) return; called=true; //y可能还是一个Promise，再去解析知道返回的是一个普通值 resolvePromise(promise2,y,resolve,reject) &#125;,function(err)&#123; if(called) return; called=true; //失败的回调 reject(err) &#125;) &#125;else&#123; // 不是函数,x就是一个普通的对象,直接成功即可 resolve(x); &#125; &#125;catch(e)&#123; if(called) return; called=true; reject(e) &#125; &#125;else&#123; // 是普通值直接调用成功 resolve(x); &#125;&#125; then中的方法异步执行为了保证程序执行的一致性,规范中要求then中的方法必须在下一队列中执行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071Promise.prototype.then(function(onFufilled,onRejected)&#123; let promise2; // promise2为then调用后返回的新promise if(this.status==='fulfilled')&#123; //成功调用回调函数 promise2=new Promise(function(resolve,reject)&#123; // x是then返回的结果 setTimeout(()=&gt;&#123; try&#123; let x = onFufilled(this.value) resolvePromise(promise2,x,resolve,reject) &#125;catch(e)&#123; reject(e); &#125; &#125;) &#125; &#125;) &#125; if(this.status==='rejected')&#123; //失败调用回调函数 promise2=new Promise(function(resolve,reject)&#123; setTimeout(()=&gt;&#123; try&#123; let x= onRejected(this.reason) resolvePromise(promise2,x,resolve,reject) &#125;catch(e)&#123; reject(e); &#125; &#125;) &#125;) &#125; if(this.status==="pending")&#123; // 如果是等待态,就将成功和失败的回调放到数组中 //成功调用回调函数 new Promise((resolve,reject)=&gt;&#123; this.onFulfilledcallback.push(()=&gt;&#123; setTimeout(()=&gt;&#123; try&#123; let x = onFufilled(this.value) resolvePromise(promise2,x,resolve,reject) &#125;catch(e)&#123; reject(e); &#125; &#125;) &#125;) //失败调用回调函数 this.onRejectedCallback.push(()=&gt;&#123; setTimeout(()=&gt;&#123; try&#123; let x = onRejected(this.value) resolvePromise(promise2,x,resolve,reject) &#125;catch(e)&#123; reject(e); &#125; &#125;) &#125;) &#125;) &#125; return promise2&#125;) 值的穿透在规范中定义then函数可以不传参,不传参默认会将成功的结果和失败的结果继续向下传递1234567Promise.prototype.then = function (onFufilled, onRejected) &#123;+ onFufilled = typeof onFufilled === 'function'?onFufilled:function(value)&#123;+ return value+ &#125;+ onRejected = typeof onRejected === 'function'?onRejected:function(err)&#123;+ throw err+ &#125; resolve接收promise12345678function resolve(value) &#123; // 调用resolve 会传入为什么成功+ if (value !== null &amp;&amp; (typeof value === 'object' || typeof value === 'function')) &#123;+ if(typeof value.then === 'function')&#123;+ // 将当前promise成功的结果再次传回resolve函数中+ return value.then(resolve,reject);+ &#125;+ &#125; if (self.status === 'pending') &#123; Promise.all1234567891011121314151617Promise.all=function(promises)&#123; let arrs=[];//返回的结果 let ind=0;//表示成功了几次 return new Promise(function(resolve,reject)&#123; function processDate(index,y)&#123; arr[index]=y; if(++ind===promises.length)&#123; resolve(arrs) &#125; &#125; for(let i=0;i&lt;len;i++)&#123; promises[i].then(function(y)&#123; processDate(i,y) &#125;,reject) &#125; &#125;)&#125; Promose.race12345Promise.race=function(promises)&#123; for(let i=0;i&lt;promises.length;i++)&#123; promises[i].then(resolve,reject) &#125;&#125; Promise.resolve12345Promise.resolve=function(data)&#123; return new Promise(function(resolve,reject)&#123; resolve(data) &#125;)&#125; Promise.reject12345Promise.reject = function(reason)&#123; return new Promise(function(resolve,reject)&#123; reject(reason); &#125;);&#125; catch123Promise.prototype.catch=function(fn)&#123; return this.then(null,fn)&#125;]]></content>
      <tags>
        <tag>promise</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css工程化]]></title>
    <url>%2F2018%2F07%2F10%2Fcss%E5%B7%A5%E7%A8%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[关注点 组织 优化 构建 维护 postcss postcss本身只有解析能力–可以检测css代码是否正确 各种神奇的特性全靠插件 目前至少有200多个插件 插件 import 模块合并 autoprefixier 自动加前缀 cssnano 压缩代码 cssnext 使用css新特性 precss 变量、mixin、循环等 BrowsersList cssnext precss 变量 条件 循环 mixin Extend import 属性值引用 postcss支持的构建工具 cli 命令行工具 webpack post-loader Gulp gulp-postcss Grunt grunt-postcss Rollup rollup-postcss … webpack js是整个应用的核心入口 一切资源均有js管理依赖 一切资源均有webpack打包 webpack和css css-loader 将css变成js style-loader将js样式插入head extractTextPlugin 将css从js中提取出来 css modules 解决css命名冲突的问题 less-loader sass-loader 各类预处理器 postcss-loader Postcss处理 问题 如何解决css模块化的问题 Less Sass等css预处理器 Postcss插件（postcss-import/press等） webpack处理css(css-loader+style-loader) postcss可以做什么？ 取决于插件可以做什么 autoprefixer cssnext precss 等 兼容性处理 import模块合并 css语法检查 兼容性检查 压缩文件 css modules是做什么的，如何使用 解决类名冲突问题 使用postcss或者webpack等构建工具进行编译 在HTML模板中使用编译过程产生的类名 为什么使用js来引用、加载css js作为入口、管理资源有天然的优势 将组件结构、样式、行为封装到一起，增加内聚 可以做更多处理（webpack）]]></content>
      <tags>
        <tag>css</tag>
        <tag>css工程化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css效果]]></title>
    <url>%2F2018%2F07%2F10%2Fcss%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[效果属性 这个效果怎么实现？ css最出彩的部分 box-shadow text-shadow border-radius background clip-path box-shadow 营造层次感(立体感) 充当没有宽度的边框 特殊效果 相当于元素的复制,可以制作一个div画出炫酷的效果text-shadow 立体感 印刷品质感 border-radius 圆角矩形 圆形 半圆/扇形 一些奇怪的角角 background 纹理、图案 渐变 雪碧图动画 背景图尺寸适应 clip-path 按路径对容器进行裁剪 常见几何图形 自定义路径 原容器的大小不变,可以做容器内动画 3d 变换 变换 transform 在3d空间中进行变换 问题 如何用一个div画xxx box-shadow无限投影 ::before ::after 如何产生不占空间的边框 outline box-shadow 如何实现圆形元素(头像) border-radius:50%; 如何实现ios图标的圆角 clip-path:(svg) 如何实现半圆、扇形等图形 border-radius 组合： 有无边框 边框粗细 圆角半径 如何实现背景图居中显示/不重复/改变大小 background-position background-repeat background-size(cover/contain) 如何平移/放大一个元素 transform:translateX(100px) transform:scale(2) 如何实现3D效果 perspective:500px; transform-style:preserve-3d transform:translate rotate…]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
        <tag>css效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css动画]]></title>
    <url>%2F2018%2F07%2F09%2Fcss%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[动画的原理 视觉暂留作用 画面逐渐变化 动画的作用 愉悦感 引起注意 反馈 掩饰 css中的动画类型 transition补间动画 keyframe关键帧动画 逐帧动画 补间动画 位置- 平移（left/right/margin/transform） 方位-旋转(transform) 大小-缩放（transform） 透明度（opacity） 其他-线性变换（transform） timing(easing) 定义动画进度和时间的关系 关键帧动画 相当于多个补间动画 与元素状态的变化无关 定义更加灵活 逐帧动画 适用于无法补间计算的动画 资源较大 使用steps() 指定关键帧之间有多少个动画 问题 css的动画实现方式有几种？ transition keyframes(animation) 过渡动画和关键帧动画的区别 过渡动画需要有状态的变化 关键帧动画不需要状态的变化 关键帧动画能控制更精细 如何实现逐帧动画 使用关键帧动画 去掉补间(steps) css动画的性能 性能不坏 部分情况下优于JS 但是JS可以做到更好 部分高危属性 box-shadow等]]></content>
      <tags>
        <tag>css</tag>
        <tag>css动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML汇总]]></title>
    <url>%2F2018%2F07%2F09%2FHTML%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[HTML常见元素head区的元素(页面相关资源、信息描述) meta title style link script base body区的元素 div/section/article/aside/header/footer p span/em/strong table/thead/tbody/tr/td ul/ol/li/dl/dt/dd a form/input/select/textarea/button 重要元素123456&lt;!-- 页面字符集 --&gt; &lt;meta charset="utf-8"&gt; &lt;!-- 以iphone为例，如果不指定viewport的话，视图（viewport）的默认宽度为980px,加viewport来适配移动端 --&gt; &lt;meta name="viewport" content="width=device-width,iniial-scale=1.0,maximum-scale=1.0,user-scalable=no"&gt; &lt;!-- 指定基础路径 页面中路径会以该路径为基准计算 --&gt; &lt;base href="/"&gt; viewport实例 重要属性 a[href,target] img[src,alt] table td[colspan,rowspan] form[target,method.enctype] input[type,value] button[type] select&gt;option[value] label[for] 如何理解html html”文档” 描述文档的”结构” 有区块和大纲 html版本 HTML4/4.0.1(SGML) XHTML(XML) HTML5 检查页面是否符合标准 HTML5新增内容 新区块标签 section article nav aside 表单增强 日期、时间、搜索 表单验证 Placeholder 自动聚焦 新增语义 header/footer头尾 section/article区域 nav 导航 aside 不重要内容 em/strong强调 i–&gt;icon HTML元素分类 按默认样式分 块级 block 行内 inline inline-block 按内容分 HTML元素嵌套关系 块级元素可以包含行内元素 块级元素不一定能包含块级元素,例如p “行内元素一般不能不含块级元素”,例如a 为什么a&gt;div是合法的？ 嵌套关系来自于内容分类和Content module 不一定合法，根据html5文档a标签包裹块级元素时，会将a元素变成透明的，看包裹a元素的标签是块级元素还是行内元素，例如： 123456&lt;body&gt;&lt;!-- 合法，应为body包裹a元素，是块级元素 --&gt;&lt;a&gt;&lt;div&gt;2121221&lt;/div&gt;&lt;/a&gt;&lt;!-- 不合法 --&gt;&lt;p&gt;&lt;a&gt;&lt;div&gt;2121221&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;&lt;/body&gt; HTML元素默认样式 默认样式的意义 默认样式带来的问题 css Reset 问题？ doctype的意义是什么？ 让浏览器以标准模式渲染 让浏览器知道元素的合法性 HTML XHTML HTML5的关系 HTML属于SGML XHTML属于XML,是HTML进行XML严格化的结果 HTML5不属于SGML或XML,比XHTML宽松 HTML5有什么变化 新的语义化元素 表单增强 新的API(离线、音视频、图形、实时通信、本地存储、设备能力) 分类和嵌套变更 em和i有什么区别？ em是语义化的标签，表强调 i 是纯样式的标签，表斜体 HTML5中i不推荐使用，一般用作图标 语义化的意义是什么？ 开发者容易理解 机器容易理解结构（搜索、读屏软件） 有助于SEO semantic microdata 那些元素可以自闭合 表单元素input 图片 img br、hr meta、link HTML和DOM的关系 HTML是”死”的 DOM是由HTML解析而来的，是活的 JS可以维护DOM property和attribute的区别 attribute是“死”的 property是“活”的 attribute的改变不会影响property，反之相同1234567&lt;!-- attribute --&gt;&lt;input type="text" value="1"&gt; //&lt;script&gt;$0.value="1"//property$0.setAttribute("value",'23')$0.value //1&lt;/script&gt; form的作用有哪些？ 直接提交表单 使用submit/reset按钮 便于浏览器保存表单 第三方库可以整体提取值 第三库可以进行表单验证]]></content>
      <tags>
        <tag>HTML</tag>
        <tag>HTML汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架中的css]]></title>
    <url>%2F2018%2F07%2F06%2F%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84css%2F</url>
    <content type="text"><![CDATA[Angular Vue React 三大框架 Angular Vue 内置样式集成 React 一些业界实践 Angular Angular.js(1.x) 没有样式集成能力 Angular (2+) 提供了样式封装能力 与组件深度集成 ShadowDOM 逻辑上一个DOM 结构上存在子集结构 Scoped css 限定了范围的css 无法影响外部元素 外部样式一般不影响内部 可以通过/deep/或&gt;&gt;&gt;穿透 模拟scoped css (兼容性差) 方案1：随机选择器(不支持) 方案2：随机属性 &lt;div abcdefg&gt; div[abcdefg]{} vue中模拟Scoped css 随机选择器 css modules 随机属性 &lt;div abcdefg&gt; div[abcdefg]{} react 官方没有集成方案 社区方案众多 css modules (babel)react-css-modules styled components styled jsx]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
        <tag>框架中的css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css框架bootstarp]]></title>
    <url>%2F2018%2F07%2F06%2Fcss%E6%A1%86%E6%9E%B6bootstarp%2F</url>
    <content type="text"><![CDATA[什么是bootstrap? 一个css框架 twitter出品 提供通用基础样式 Bootstrap 4 兼容IE10+ 使用flexbox布局 抛弃Nomalize.css 提供布局和reboot版本 Bootstrap主要做什么？ 基础样式 常用组件 js插件 Bootstrap js组件 用于组件交互 dropdown(下拉) modle(弹框) … 基于jQuery poper.js bootstrap.js 使用方式： 基于data-*属性 基于js-api bootstrap响应式布局bootstrap在不同的分辨率下有不同的分配 bootstrap的优缺点 优点：css代码结构合理 现成的样式可以直接用 缺点：定制较为繁琐 体积大 boostrap如何实现响应式布局 原理：通过media query设置不同分辨率的class 使用：为不同分辨率选择不同的网格class bootstrap 定制方法 使用css同名类覆盖 修改源码重新构建 引用scss源文件 –&gt; 修改变量 (可以按需加载,对bootstrap的结构要了解)]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css预处理器]]></title>
    <url>%2F2018%2F07%2F05%2Fcss%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[什么是预处理器 基于css的另一种语言 通过工具编译成css 添加了很多css不具备的特性 能提升css文件的组织 常见的css预处理器 less(Node.js) sass (Ruby有Node版本)(node-sass 是c++写的 安装有点复杂) 预处理器的作用 帮助更好地组织css代码 提高代码的复用率 提升可维护性 提供的功能 嵌套– 反映层级和约束 变量和计算–减少重复代码 extend和Mixin— 代码片段 循环– 适用于复杂的有规则的样式 import– css文件模块化 css预处理器框架 sass - Compass less -Lesshat/EST 提供现成的mixin 类似js类库 封装常用功能 预处理其的有缺点 优点： 提高代码的复用率和可维护性 缺点： 需要引入编译过程和学习成本高 EST est 提供了一系列方便快捷的 mixin 问题：现阶段是否推荐使用预处理器 除了预处理器，css工程化已经发展起来了，对于css的提升可以有其他手段]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
        <tag>预处理器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node深研]]></title>
    <url>%2F2018%2F06%2F26%2Fnode%E6%B7%B1%E7%A0%94%2F</url>
    <content type="text"><![CDATA[node概念node工作原理 非node多线程服务器工作原理 node主线程工作原理 Node 解决了什么Node 的首要目标是提供一种简单的，用于创建高性能服务器的开发工具 Web 服务器的瓶颈在于并发的用户量，对比 Java 和 Php 的实现方式Node在处理高并发，I/O 密集场景有明显的性能优势 高并发,是指在同一时间并发访问服务器 I/O 密集指的是文件操作、网络操作、数据库,相对的有 CPU 密集,CPU 密集指的是逻辑处理运算、压缩、解压、加密、解密 Web 主要场景就是接收客户端的请求读取静态资源和渲染界面,所以 Node 非常适合 Web 应用的开发。 线程进程是操作系统分配资源和调度任务的基本单位，线程是建立在进程上的一次程序运行单位，一个进程上可以有多个线程。 js线程、ui线程这两个线程是互斥的,目的就是为了保证不产生冲突 ui线程会把更改放到队列中，当js线程空闲下来，ui线程在继续渲染 webworker 多线程 他和js主线程不是平级的，主线程可以控制webworker,webworker不能操作dom,document,window123456789101112131415&lt;!-- 文件1 --&gt;onmessage=function(e)&#123;let sum=0;for(let i=0;i&lt;e.data;i++)&#123; sum+=i;&#125;postMessage(sum)&#125;&lt;!-- 页面主线程 --&gt;let worker=new Worker('./worker.js')//把内容发给 工作线程，工作线程可以把结果丢回来worker.postMessage(100)worker.onmessage=function(e)&#123; console.log(e.data)&#125; global 在浏览器端 全局作用域我们通过window访问 我们可以直接在node中访问global1234567// 在浏览器端var a=1;window.a//1// 在服务器端var a=1;global.a//undefined 原因：node在执行的时候,为了实现模块增加了一个闭包 控制台 在Node.js中，使用console对象代表控制台(在操作系统中表现为一个操作系统指定的字符界面，比如 Window中的命令提示窗口)。 123456// 标准输出console.log('log')console.info('info')// 错误输出console.error('error')console.warn('warn') 当我们执行以下语句时,1.log文件中仅仅只有标准输出1node node1.js&gt; 1.log 只有我们执行以下语句时,才能将错误输出添加到1.log中。标准输出用1表示,错误输出用2表示1node node1.js &gt; 1.log 2&gt;&amp;1 默认有些属性是隐藏的12console.dir(Array.prototype)//[]console.dir(Array.prototype,&#123;showHidden:true&#125;)//可以显示隐藏属性 time和timeEnd中的内容是一对,名字相同时才能打印出两端时间的间隔12345console.time('label')for(var i=0;i&lt;10000;i++)&#123;&#125;console.timeEnd('label') 断言 断言有错误抛出一个AssertionError 单元测试mocha,kamra 断言库 chai, TDD, BDD, DDD持续继承,测试覆盖率 node 提供一个模块 asset1console.assert((1+1)===2,'error') 其他属性 process进程 argv后续执行时可能会传递参数 http-server --port 3000 pid 进程id 端口占用的情况 任务管理器 lsof -i :8080,kill -9 id号 chdir change directory 工作目录 cwd current working directory 当前工作目录 nextTick 微任务 stdout: [Getter], stderr: [Getter], stdin: [Getter], Buffer 存储文件内容 二进制 setImmediate 设置立即 setInterval setTimeout process.cwd与_dirname的区别 process.cwd表示当前工作目录,就是代码执行目录 __dirname 这个属性不是global上的，指代的是当前文件所在的文件夹,不会更改 Event Loop详解要探究Event Loop，就要先明白两个概念 JS是单线程的JavaScript语言最大特点就是单线程，但是这里的单线程指的是主线程是单线程的。那为什么js要单线程呢？因为，JS主要用于操作DOM，如果是有两个线程，一个在DOM上添加内容，一个在DOM上删除内容，此时浏览器该以哪个为准呢？所以为了避免复杂性，JavaScript从诞生起就是单线程的。 同步和异步 &amp;&amp; 阻塞非阻塞 阻塞和非阻塞指的是调用者的状态 同步和异步指的是被调用者是如何通知的 堆、栈、队列 堆（heap）是指程序运行时申请的动态内存，在JS运行时用来存放对象。 栈（stack）遵循的原则是“先进后出”，JS中的基本数据类型与指向对象的地址存放在栈内存中，此外还有一块栈内存用来执行JS主线程–执行栈（execution context stack），此文章中的栈只考虑执行栈。我们可以通过console.trace()查看栈的执行顺序 队列（queue）遵循的原则是“先进先出”，JS中除了主线程之外还存在一个“任务队列”（其实有两个，后面再详细说明）。 任务队列因为JavaScript是单线程的。就意味着所有任务都需要排队，前一个任务结束，后一个任务才能执行。前一个任务耗时很长，后一个任务也得一直等着。但是IO设备（比如ajax网络请求）很慢，CPU一直初一显得状态，这样就很不合理了。所以，其实主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。于是有了同步任务和异步任务。 同步任务是指在主线程上执行的任务，只有前一个任务执行完毕，下一个任务才能执行。 异步任务是指不进入主线程，而是进入任务队列（task queue）的任务，只有主线程任务执行完毕，任务队列的任务才会进入主线程执行。 浏览器中 Event Loop 主线程运行的时候产生堆（heap）和栈（stack） 栈中的代码调用各种外部API，它们在&quot;任务队列&quot;中加入各种事件（click，load，done） 只要栈中的代码执行完毕，主线程就会去读取&quot;任务队列&quot;，将队列中的事件放到执行栈中依次执行。 主线程继续执行，当再调用外部API时又加入到任务队列中，等主线程执行完毕又会接着将任务队列中的事件放到主线程中。 上面整个过程是循环不断的。 node 中的 Event Loop node是异步 、非阻塞i/o的，是用libuv(通过多线程和阻塞的i/o)实现的。 我们写的js代码会交给v8引擎进行处理 代码中可能会调用nodeApi,node会交给libuv库处理 libuv通过阻塞i/o和多线程实现了异步io 通过事件驱动的方式,将结果放到事件队列中,最终交给我们的应用。 除了setTimeout和setInterval这两个方法，Node.js还提供了另外两个与”任务队列”有关的方法：process.nextTick和setImmediate。 微任务 &amp;&amp; 宏任务（队列） 微任务 process.nextTick, 原生 Promise (有些实现的promise 将 then 方法放到了宏任务中，浏览器默认放到了微任务), Object.observe (已废弃), MutationObserver（不兼容） MessageChannel（vue中 nextClick 实现原理） 12345678910111213141516&lt;!-- MutationObserver的用法 --&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;!-- 当dom加载完毕后 来一句渲染完成 --&gt; &lt;script&gt; let observe=new MutationObserver(function()&#123; console.log('渲染完成') &#125;); observe.observe(app,&#123; childList:true,//节点列表 characterData:true,//节点里的数据 &#125;) for(var i=0;i&lt;100;i++)&#123; let p= document.createElement('p') app.appendChild(p); &#125; &lt;/script&gt; 12345678910 //管道的消息流动console.log(1) let channel=new MessageChannel(); let port1=channel.port1 let port2=channel.port2; port1.onmessage=function(e)&#123; console.log(e.data) &#125; console.log(2); ports.postMessage(100) 宏任务 setTimeout、setInterval、setImmediate、I/o 执行顺序 在浏览器中，先执行当前栈，执行完走微任务，然后走事件队列里的内容,拿出一个放到当前栈中执行,再去执行微任务-在 Node环境中，Event Loop 分为 6 个阶段，每一个阶段对应着一个宏任务队列。 timers: 这个是定时器阶段，处理setTimeout()和setInterval()的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。 I/O callbacks 除了以下操作的回调函数，其他的回调函数都在这个阶段执行。 setTimeout()和setInterval()的回调函数 setImmediate()的回调函数 用于关闭请求的回调函数，比如socket.on(‘close’, …) idle, prepare 该阶段只供 libuv 内部调用，这里可以忽略。 Poll: 这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。 这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。 check:该阶段执行setImmediate()的回调函数。 close callbacks:该阶段执行关闭请求的回调函数，比如socket.on(‘close’, …)。 栗子事件循环的示例猜猜以执行步奏1234567891011121314151617const fs = require('fs');const timeoutScheduled = Date.now();// 异步任务一：100ms 后执行的定时器setTimeout(() =&gt; &#123; const delay = Date.now() - timeoutScheduled; console.log(`$&#123;delay&#125;ms`);&#125;, 100);// 异步任务二：文件读取后，有一个 200ms 的回调函数fs.readFile('test.js', () =&gt; &#123; const startCallback = Date.now(); while (Date.now() - startCallback &lt; 200) &#123; // 什么也不做 &#125;&#125;); 脚本进入第一轮事件循环以后，没有到期的定时器，也没有已经可以执行的 I/O 回调函数，所以会进入 Poll 阶段，等待内核返回文件读取的结果。由于读取小文件一般不会超过 100ms，所以在定时器到期之前，Poll 阶段就会得到结果，因此就会继续往下执行。 第二轮事件循环，依然没有到期的定时器，但是已经有了可以执行的 I/O 回调函数，所以会进入 I/O callbacks 阶段，执行fs.readFile的回调函数。这个回调函数需要 200ms，也就是说，在它执行到一半的时候，100ms 的定时器就会到期。但是，必须等到这个回调函数执行完，才会离开这个阶段。 第三轮事件循环，已经有了到期的定时器，所以会在 timers 阶段执行定时器。最后输出结果大概是200多毫秒 setTimeout 和 setImmediate由于setTimeout在timers 阶段执行，而setImmediate在 check阶段执行。所以，setTimeout会早于setImmediate完成。12setTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2)); 上面代码应该先输出1，再输出2，但是实际执行的时候，结果却是不确定，有时还会先输出2，再输出1。 这是因为setTimeout的第二个参数默认为0。但是实际上，Node 做不到0毫秒，最少也需要1毫秒，根据官方文档，第二个参数的取值范围在1毫秒到2147483647毫秒之间。也就是说，setTimeout(f, 0)等同于setTimeout(f, 1)。 实际执行的时候，进入事件循环以后，有可能到了1毫秒，也可能还没到1毫秒，取决于系统当时的状况。如果没到1毫秒，那么 timers 阶段就会跳过，进入check 阶段，先执行setImmediate的回调函数。 但是下面的代码一定是先输出2，再输出1。123456const fs = require('fs');fs.readFile('test.js', () =&gt; &#123; setTimeout(() =&gt; console.log(1)); setImmediate(() =&gt; console.log(2));&#125;); promise.nextTick的用途12345678910111213function Fn()&#123; this.arrs; process.nextTick(function()&#123; this.arrs(); &#125;)&#125;Fn.prototype.then=function(d)&#123; this.arrs=function()&#123; console.log(1) &#125;&#125;let Fn = new Fn()Fn.then() nextTick不要写递归,可以放一些比settimeout优先执行的任务1234567//机器会卡死function nextTick()&#123; process.nextTick(function()&#123; nextTick() &#125;)&#125;settimeout(function()&#123;&#125;) 注意: 当触发回调函数时，才会将回调函数放到队列中,例如setTimeout只有在时间到的情况下才会将回调函数，放入队列中 settimeout在不写时间或者时间为0的时候,因为浏览器工作原理,默认4ms process.nextTick比then快]]></content>
      <tags>
        <tag>node</tag>
        <tag>global</tag>
        <tag>Event Loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML补充知识]]></title>
    <url>%2F2018%2F06%2F24%2FHTML%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[全局属性 accesskey &amp; tabindex 与键盘按键相关。 12345678&lt;p&gt; &lt;input type="text" accesskey="i" placeholder="Press Ctrl+Alt+I"&gt;&lt;/p&gt;&lt;p&gt; &lt;a href="http://www.baidu.com" accesskey="e" tabindex="-1"&gt;press &lt;kbd&gt;Ctrl+Alt+E&lt;/kbd&gt; &lt;/a&gt;&lt;/p&gt; id保证唯一性，class多用在css，style指定内联样式。 contenteditable 页面的内容可以被编辑。spellcheck拼写检查 12345678&lt;!--contenteditable：使页面可编辑--&gt; &lt;section contenteditable spellcheck="true"&gt; &lt;p&gt;计算机基础&lt;/p&gt; &lt;p&gt;了解浏览器的渲染原理、开发调试工具以及各种调试技巧。了解 Web 协议栈，学习掌握 HTTP 协议基础， 理解网络、浏览器性能和安全相关的问题以及常用的优化技巧，掌握专业的前端性能优化能力。 学习 UI 常用动画效果的算法原理和基础，掌握通过 JavaScript、CSS3、SVG 实现高性能动画的技巧。 学习其他前端相关的数学知识、数据结构和常用算法。&lt;/p&gt; &lt;/section&gt; 语言 lang 指定页面的语言；dir 指定语言书写的方向。 12345&lt;div lang="zh-CN"&gt; &lt;p&gt;哈哈哈&lt;/p&gt;&lt;/div&gt;&lt;!-- 阿拉伯语 右对齐 --&gt;&lt;p dir="rtl" lang="ar"&gt;sasdasda&lt;/p&gt; title 属性 1&lt;abbr title="你好"&gt;hello&lt;/abbr&gt; hidden属性。隐藏元素。可用性好 1&lt;p hidden&gt;你看不见我&lt;/p&gt; 无障碍性 或可访问性，Accessibility。 确保任何人都有办法获取放在网页上的媒体内容。 不让身体、心理或技术上的问题成为获取信息的障碍 Web开发者应该做的事情 WCAG(Web Content Accessibility Guidelines) 2.0 ARIA(Accessible Rich Internet Applications)123456&lt;!-- ARIA 属性,告诉读屏软件该标签充当什么角色 --&gt;&lt;ol role="tablist"&gt; &lt;li role="tab"&gt;&lt;a href="#ch1"&gt;Chapter 1&lt;/a&gt;&lt;/li&gt; &lt;li role="tab"&gt;&lt;a href="#ch2"&gt;Chapter 2&lt;/a&gt;&lt;/li&gt; &lt;li role="tab"&gt;&lt;a href="#ch3"&gt;Chapter 3&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt; 提升无障碍性 为 img 提供 alt 属性。 noscript 当浏览器不支持脚本script时的替代性方案。 input 和 label 相对应。 图形验证码与语音验证码`。 文字和背景有足够对比度。 键盘可操作。 语义化 HTML中的元素、属性及属性值都拥有某些含义 开发者应该遵循语义来编写HTML 为什么语义化很重要？ 提升代码可读性、可维护性 搜索引擎优化 提升无障碍性 扩展HTML meta 如：如何编码、页面关键词、页面介绍、页面缩放、电话号码自动识别、360浏览器指定内核、指定IE渲染模式 123456789101112131415161718192021&lt;!--编码--&gt;&lt;meta charset="UTF-8"&gt;&lt;!--指定 HTTP Header--&gt;&lt;meta http-equiv="content-security-policy" content="script-src 'self'"&gt;&lt;!--SEO 搜索引擎优化--&gt;&lt;meta name="keywords" content="关键词"&gt;&lt;meta name="description" content="页面介绍"&gt;&lt;!--移动设备 Viewport--&gt;&lt;meta name="viewport" content="initial-scale=1"&gt;&lt;!--关闭 ios 电话号码自动识别--&gt;&lt;meta name="format-detection" content="telphone=no"&gt;&lt;!--360 浏览器指定内核--&gt;&lt;meta name="renderer" content="webkit"&gt;&lt;!--指定 IE 渲染模式--&gt;&lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt; data-*:dataset属性是一个map，其中存放data-*东西。 12345&lt;ul&gt; &lt;li data-id="1"&gt;水果1&lt;/li&gt; &lt;li data-id="2"&gt;水果2&lt;/li&gt; &lt;li data-id="3"&gt;水果3&lt;/li&gt;&lt;/ul&gt; microdata HTML5中的一个规范 itemscope 属性描述的是：在此标签内的东西是一个实体。itemtype=&quot; &quot;属性描述的是：再次标签内的东西的实体类型。itemprop=&quot; &quot;属性描述的是：该实体内的具体属性是啥。 在HTML 中 通过属性嵌入格式化数据 提供给搜索引擎、浏览器（插件）使用1234567891011121314151617181920 &lt;h2&gt;microdata&lt;/h2&gt;&lt;section itemscope itemtype="http://schema.org/Person"&gt; Hello, my name is &lt;span itemprop="name"&gt;Xiao Xiao&lt;/span&gt; I am a &lt;span itemprop="jobTitle"&gt;Graduate Student&lt;/span&gt; at the &lt;span itemprop="University"&gt;UESTC&lt;/span&gt; My friends call me &lt;span itemprop="additionalName"&gt;Xiao&lt;/span&gt; You can visit my homepage at &lt;a href="http://blog.csdn.net/sunxiaofre" itemprop="url"&gt;blog&lt;/a&gt; &lt;section itemprop="address" itemscopt itemtype="http://schema.org/PostalAddress"&gt; I live at &lt;span itemprop="addressCountry"&gt;China&lt;/span&gt; &lt;span itemprop="addressLocality"&gt;SiChuan&lt;/span&gt; &lt;span itemprop="addressStreet"&gt;XiJie&lt;/span&gt; &lt;/section&gt;&lt;/section&gt; RDFa JSON-LD json类型的数据组织形式12345678910111213141516171819&lt;h2&gt;JSON-LD&lt;/h2&gt; &lt;script type="application/ld+json"&gt; &#123; "@context": "http://schema.org", "@type": "Person", "name": "Xiao Xiao", "jobTitle": "Graduate Student", "University": "UESTC", "additionalName": "Xiao", "url": "http://blog.csdn.net/sunxiaofre", "address": &#123; "@type": "PostalAddress", "addressCountry": "China", "addressLocality": "SiChuan", "addressStreet": "XiJie" &#125; &#125; &lt;/script&gt; 参考 Google Schemas Schema.org HTML编程规范 Google Coding Style W3C Validator 工具 Emmet markdown]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单]]></title>
    <url>%2F2018%2F06%2F21%2F%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[使用form获取让用户提供数据12345&lt;form action="/echo" method="post"&gt; &lt;p&gt;USER: &lt;input type="text" name="uesename"&gt;&lt;/p&gt; &lt;p&gt;PASSWORD: &lt;input type="password" name="password"&gt;&lt;/p&gt; &lt;p&gt;&lt;button type="submit"&gt;LOGIN&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; GET与POST 获取还是修改 get：从服务器获取东西； post：向服务器提交东西。 数据传输方式的区别： get：把字段数据放到url中提交，一次性将数据发送给服务器； post：不会把数据放到路径url中，而是将数据以某种形式进行编码，将编码后的内容放到HTTP的body中提交。需要分两次才能发送给服务器。HTTP分两次发送，第一次发送head，第二次发送body。 发送的位置不同而已，都没有做加密解密的操作。只不过get方式放在url中在浏览器的url中可以看到,而post看不到。 URL Encode（URL编码） 空格 =&gt; %20 （空格会默认替换为加号+） ! =&gt; %21 &quot; =&gt; %22 # =&gt; %23 $ =&gt; %24 % =&gt; %25 ’ =&gt; %27 + =&gt; %2B HTTP method GET POST HEAD：只返回head中的东西。 PUT :放置 DELETE：删除。 OPTIONS：返回http有哪些headers的选项。如查看是否允许跨域。 单行多行文本框 name就是发送数据到服务器的key。value给用户一个默认值。 placeholder提示词 autofocus 聚焦 password 密码1&lt;input type="text" placeholder="提示文字" autofocus&gt; 多行文本框12&lt;textarea cols="30" rows="7"&gt;&lt;/textarea&gt; 输入验证 尽早提示用户错误输入。required表示此项必须填写， minlength,maxlength pattern正则表达式。1234567891011121314&lt;form action="/echo"&gt; &lt;p&gt; &lt;input required minlength="3" maxlength="12" placeholder="3-12位"&gt; &lt;/p&gt; &lt;p&gt; &lt;input pattern="1\d&#123;10&#125;" placeholder="输入手机号"&gt; &lt;/p&gt; &lt;p&gt; &lt;button type="submit"&gt;确认&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; type 在可用性上做一些辅助 对手机上键盘的布局有影响 对输入自行进行验证，提高可用性 type=”search” type=”email” type=”url” type=”submit” novalidate 去掉系统自带的验证。根据自己的业务需要用JavaScript自己实现一个验证。1&lt;form action="" novalidate&gt;&lt;/form&gt; radio 单选框 从一组数据中选择其中一个12345678910&lt;form action=""&gt; &lt;p&gt;你最喜欢的水果是？&lt;/p&gt; &lt;p&gt; &lt;input type="radio" name="fruit" value="barries"&gt; 草莓 &lt;input type="radio" name="fruit" value="banana"&gt; 香蕉 &lt;input type="radio" name="fruit" value="mango"&gt; 芒果 &lt;input type="radio" name="fruit" value="dragon"&gt; 火龙果 &lt;/p&gt; &lt;p&gt;&lt;button&gt;提交&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; checkbox 复选框12345678910&lt;form action=""&gt; &lt;p&gt;你最喜欢的水果是？&lt;/p&gt; &lt;p&gt; &lt;input type="checkbox" name="fruit" value="barries"&gt; 草莓 &lt;input type="checkbox" name="fruit" value="banana"&gt; 香蕉 &lt;input type="checkbox" name="fruit" value="mango"&gt; 芒果 &lt;input type="checkbox" name="fruit" value="dragon"&gt; 火龙果 &lt;/p&gt; &lt;p&gt;&lt;button&gt;提交&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; label标签 可用性提升 在使用 radio 和 checkbox 时，点击文字也可以进行选择，而不是只能点击框才能选择。12345678910111213&lt;form action=""&gt; &lt;p&gt;你最喜欢的水果是？&lt;/p&gt; &lt;p&gt; &lt;label for="barries"&gt;&lt;input type="checkbox" name="fruit" value="barries" id="barries"&gt; 草莓&lt;/label&gt; &lt;input type="checkbox" name="fruit" value="banana" id="banana"&gt;&lt;label for="banana"&gt; 香蕉&lt;/label&gt; &lt;input type="checkbox" name="fruit" value="mango" id="mango"&gt;&lt;label for="mango"&gt; 芒果&lt;/label&gt; &lt;input type="checkbox" name="fruit" value="dragon" id="dragon"&gt;&lt;label for="dragon"&gt; 火龙果&lt;/label&gt; &lt;/p&gt; &lt;!-- 关联input 支持读屏软件 --&gt; &lt;label for="name"&gt;请输入你的名字：&lt;/label&gt; &lt;p&gt;&lt;input id="name"/&gt;&lt;/p&gt; &lt;p&gt;&lt;button&gt;提交&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; select标签 当选项特别特别多时，可用下拉框来表示选项，使页面简洁。 1234567&lt;select&gt;&lt;option&gt;&lt;/option&gt;&lt;/select&gt;&lt;!-- 可以多选 --&gt;&lt;select mutiple&gt;&lt;/select&gt; &lt;!-- 当前显示在页面中的选项的个数 --&gt;&lt;select size="3"&gt;&lt;/select&gt; &lt;!-- 分组 --&gt;&lt;optgroup&gt;&lt;option&gt;&lt;/option&gt;&lt;/optgroup&gt; 多选 1234567891011121314151617181920212223&lt;form action=""&gt; &lt;label for=""&gt;想去的城市：&lt;/label&gt; &lt;select name="city"&gt; &lt;optgroup label="1-4"&gt; &lt;option value="1"&gt;1&lt;/option&gt; &lt;option value="2"&gt;2&lt;/option&gt; &lt;option value="3"&gt;3&lt;/option&gt; &lt;option value="4"&gt;4&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label="5-8"&gt; &lt;option value="5"&gt;5&lt;/option&gt; &lt;option value="6"&gt;6&lt;/option&gt; &lt;option value="7"&gt;7&lt;/option&gt; &lt;option value="8"&gt;8&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label="9-12"&gt; &lt;option value="9"&gt;9&lt;/option&gt; &lt;option value="10"&gt;10&lt;/option&gt; &lt;option value="11"&gt;11&lt;/option&gt; &lt;option value="12"&gt;12&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt;&lt;/form&gt; hidden 某些数据需要从页面上提交，但是不希望在页面上展示出来，此时用hidden。 1&lt;input type="hidden" name="secret" value="1"&gt; 文件选择 enctype=&quot;multipart/form-data&quot;属性、multipart将文件分段传输 mutiple ：可以同时选择多文件 accept=&quot;image/*&quot;只支持图片上传1234567891011121314&lt;!-- 文件选择框 --&gt;&lt;form action="" method="post" enctype="multipart/form-data"&gt; &lt;p&gt; &lt;label for=""&gt;您的姓名： &lt;/label&gt; &lt;input name="fullname"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=""&gt;请上传简历&lt;/label&gt; &lt;input type="file" multiple name="resume"&gt; &lt;/p&gt; &lt;p&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; date &amp; time1234567&lt;form action=""&gt; &lt;p&gt;date: &lt;input type="date"&gt;&lt;/p&gt; &lt;p&gt;datetime-local: &lt;input type="datetime-local"&gt;&lt;/p&gt; &lt;p&gt;month: &lt;input type="month"&gt;&lt;/p&gt; &lt;p&gt;week: &lt;input type="week"&gt;&lt;/p&gt; &lt;p&gt;time: &lt;input type="time"&gt;&lt;/p&gt;&lt;/form&gt; number &amp; range12345678910111213141516171819202122232425262728293031323334&lt;!--number &amp; range--&gt;&lt;form action="" id="heightAndWeight"&gt; &lt;p&gt; &lt;label&gt;身高(m)：&lt;/label&gt; &lt;input type="number" min="0.5" max="2.5" step="0.01" name="height" value="1.7"&gt; &lt;!-- html数据的展示 --&gt; &lt;output for="height"&gt;&lt;/output&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;体重(kg)：&lt;/label&gt; &lt;input type="range" min="10" max="200" step="0.1" name="weight" value="50"&gt; &lt;output for="weight"&gt;&lt;/output&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;BMI&lt;/label&gt; &lt;output for="weight height"&gt;&lt;/output&gt; &lt;/p&gt;&lt;/form&gt;&lt;script&gt; var form = document.querySelector('#heightAndWeight'); form.addEventListener('input', update); update(); function update() &#123; var data = new FormData(form); var height = parseFloat(data.get('height')); var weight = parseFloat(data.get('weight')); document.querySelector('[for="weight"]').value = weight; document.querySelector('[for="weight height"]').value = getBMI(height, weight); &#125; function getBMI(height, weight) &#123; return(weight/Math.pow(height, 2)).toFixed(2); &#125; color1&lt;input type="color"&gt; button123456789&lt;!--button--&gt;&lt;form action=""&gt; &lt;p&gt; &lt;!-- 默认事type="submit" --&gt; &lt;button type="submit"&gt;默认submit提交表单数据&lt;/button&gt; &lt;button type="button"&gt;button点击这种行为，不提交&lt;/button&gt; &lt;button type="reset"&gt;reset重置表单&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 回车提交123456789&lt;!--回车提交 自动触发type="submit" 的click事件 --&gt;&lt;form&gt; &lt;p&gt;Name: &lt;/p&gt; &lt;p&gt;&lt;input type="text" name="fullname" value="abc"&gt;&lt;/p&gt; &lt;p&gt; &lt;button onclick="alert(1)"&gt;不指定type&lt;/button&gt; &lt;button onclick="alert(2)" type="button"&gt;button&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 实际用途：尽量不取消回车提交的功能,一般将submit事件定义到form上 12345678910111213&lt;form&gt; &lt;input type="text" name="ana" id=""&gt; &lt;p&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/p&gt; &lt;/form&gt; &lt;script&gt; var from = document.querySelector("form") from.onsubmit = function (e) &#123; e.preventDefault(); alert('1') &#125; &lt;/script&gt; 控件状态 readonly：会提交到服务器上，但页面上无法进行修改。 disabled：不会提交到服务器上 表单设计 帮助用户不出错，能选不填，给出提示 尽早提示错误 扩大选择／点击区域 控件较多时要分组 分清主要动作和次要动作]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表格]]></title>
    <url>%2F2018%2F06%2F21%2F%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[基本格式 th不仅可以出现在thead中，也可以出现在tbody中，只要认为此单元格是表头性质的，就可以用th。tr表示行，td表示列。 部分错误的嵌套，浏览器会尽可能补全缺失的部分123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;表格&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border="1"&gt; &lt;caption&gt;浏览器及其引擎&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;浏览器&lt;/th&gt; &lt;th&gt;渲染引擎&lt;/th&gt; &lt;th&gt;JavaScript 引擎&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;Chrome&lt;/th&gt; &lt;td&gt;Blink&lt;/td&gt; &lt;td&gt;V8&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Opera&lt;/th&gt; &lt;td&gt;Blink&lt;/td&gt; &lt;td&gt;V8&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Firefox&lt;/th&gt; &lt;td&gt;Gecko&lt;/td&gt; &lt;td&gt;SpiderMonkey&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 合并单元格 合并行 rowspan：一个单元行占几行。 合并列 colspan：一个单元格占几列。123456789101112131415161718192021222324252627&lt;!--合并行--&gt;&lt;table border="2"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;浏览器&lt;/th&gt; &lt;th&gt;渲染引擎&lt;/th&gt; &lt;th&gt;JavaScript 引擎&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;Chrome&lt;/th&gt; &lt;td rowspan="2"&gt;Blink&lt;/td&gt; &lt;td rowspan="2"&gt;V8&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Opera&lt;/th&gt; &lt;!--&lt;td&gt;Blink&lt;/td&gt;--&gt; &lt;!--&lt;td&gt;V8&lt;/td&gt;--&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Firefox&lt;/th&gt; &lt;td colspan="2" align="center"&gt;Gecko&lt;/td&gt; &lt;!--&lt;td&gt;SpiderMonkey&lt;/td&gt;--&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 表格说明 表头caption必须是table的第一个元素。 列组 colgroup12345678910111213141516171819202122232425262728293031&lt;table border="2"&gt; &lt;caption&gt;浏览器及其引擎&lt;/caption&gt; &lt;colgroup&gt; &lt;col class="browser" style="background: #a7c7dc;"&gt; &lt;col class="engine" span="2" style="background: #f0ad4e;"&gt; &lt;/colgroup&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;浏览器&lt;/th&gt; &lt;th&gt;渲染引擎&lt;/th&gt; &lt;th&gt;JavaScript 引擎&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;Chrome&lt;/th&gt; &lt;td rowspan="2"&gt;Blink&lt;/td&gt; &lt;td rowspan="2"&gt;V8&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Opera&lt;/th&gt; &lt;!--&lt;td&gt;Blink&lt;/td&gt;--&gt; &lt;!--&lt;td&gt;V8&lt;/td&gt;--&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Firefox&lt;/th&gt; &lt;td colspan="2" align="center"&gt;Gecko&lt;/td&gt; &lt;!--&lt;td&gt;SpiderMonkey&lt;/td&gt;--&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连接与图片]]></title>
    <url>%2F2018%2F06%2F21%2F%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[链接 省略协议 12&lt;!-- 根据当前页面的协议 --&gt;&lt;a href="//www.baidu.com"&gt;&lt;/a&gt; 省略协议和host 12&lt;!-- 根据当前页面的协议和host --&gt;&lt;a href="/index.html"&gt;&lt;/a&gt; 相对路径与绝对路径 12345678&lt;!-- 开发时一般用省略协议和host的绝对路径 --&gt;&lt;!-- 相对路径 --&gt;&lt;a href="a/index.html"&gt;&lt;/a&gt;&lt;!-- 相对路径 --&gt;&lt;a href="../../index.html"&gt;&lt;/a&gt;&lt;!-- 绝对路径 --&gt;&lt;a href="/a/index.html"&gt;&lt;/a&gt; 页面内跳转：锚点 12&lt;a href="#idName"&gt;连接到本页面id=idName的元素所在处&lt;/a&gt;&lt;a href="#"&gt;链接到本页面顶部&lt;/a&gt; 链接目标 target:_self 当前窗口 target:_blank 新窗口 target:abc 随意一个值,指定同一个值会共用同一个页面 图片12&lt;img src="" alt="替代文字" width="300" height="200"&gt;&lt;figcaption&gt;图片说明&lt;/figcaption&gt; 指定图片宽高： 不指定宽高：原图大小显示 指定宽度：按比例缩放到指定宽度 指定高度：按比例缩放到指定高度 指定宽高：强制按指定宽高显示 常用图片格式： jpg：照片，色彩丰富的图片（常用） png：色彩较少时使用，png24可以半透明（常用） gif：色彩较少时使用，gjf无法半透明，可以多帧做动画（较少用） webp：有些浏览器不支持]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html简述与文本]]></title>
    <url>%2F2018%2F06%2F21%2Fhtml%E7%AE%80%E8%BF%B0%E4%B8%8E%E6%96%87%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[HTML是什么 HyperText Markup Language 使用标签来描述页面的内容和结构 HTML的产生 1989年,TimBerners-Lee 共享文档需要 还发明了浏览器、服务器和HTTP Doctype的作用 指定HTML页面使用的标准和版本 浏览器根据doctype决定使用哪种渲染模式 渲染模式 Quirks Mode 怪异模式 —-(html4之前) Almost Standard Mode 准标准模式—-(有些标签大小写不严格) Standard Mode 标准模式—(标签大小写严格标准) 123456789&lt;!-- html5 --&gt;&lt;!DOCTYPE html&gt;&lt;!-- 准标准模式 --&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;!-- 标准模式 --&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;!-- 当 doctype 缺失的时候，浏览器会选择 Quirks Mode --&gt; HTML 版本 HTML 1.0,1991 HTML 2.0,1994,IETE HTML 3.2, 1997,W3C Netscape引入私有标签 HTML 3.0失败 W3C接管HTML标准化 HTML 4.01,1998 样式与内容分离,CSS支持 Doctype XHTML 1.0,2000 用XML语法重新定义HTML 语法严格要求 XHTML 2.0 不兼容历史 去除样式类标签 去除img、a标签 彻底修改Form 开发者不欢迎,浏览器不支持 HTML5 2004年,WHATWG继续发展HTML 2008年,W3C HTML5草案发布 HTML5 设计思想 兼容已有内容 避免不必要的复杂性 解决现实的问题 优雅降级 尊重事实标准 用户的需求–&gt;开发者的需求–&gt;浏览器厂商的需求–&gt;标准的制定者的需求–&gt;理论完美 HTML5 中的变化 doctype、meta 新增语义化标签和属性 去掉纯展示性标签 canvas、video、audio、离线、本地存储、拖拽等 HTML5语法 标签不区分大小写,推荐小些 空标签可以不闭合,如&lt;input&gt; &lt;meta&gt; 属性不必引号,推荐双引号 某些属性值可以省略,如required、readonly 文本标签 p h1~h6 hr 段落级别的话题切换（效果：一条横线） 列表： 有序列表 ol、li 无序列表 ul、li 自定义列表dl、dt、dd 1234567891011&lt;h3&gt;霸王别姬&lt;/h3&gt;&lt;dl&gt; &lt;dt&gt;导演：&lt;/dt&gt; &lt;dd&gt;陈凯歌&lt;/dd&gt; &lt;dt&gt;主演：&lt;/dt&gt; &lt;dd&gt;张国荣&lt;/dd&gt; &lt;dd&gt;巩俐&lt;/dd&gt; &lt;dd&gt;张丰毅&lt;/dd&gt; &lt;dt&gt;上映日期：&lt;/dt&gt; &lt;dd&gt;1993-01-01&lt;/dd&gt;&lt;/dl&gt; 列表是可以嵌套的（列表中有列表,自动默认有缩紧）。 嵌套规则：内外不要混搭 引用 长段落引用块标签 1&lt;blockquote cite="myURL"&gt;长段落引用块标签&lt;/blockquote&gt; 短引用 1&lt;cite&gt;短引用说来源，如书名、标题&lt;/cite&gt; 引用内容 1&lt;q&gt;引用的内容，如引用一句话&lt;/q&gt; 预格式化文本 pre保留空格和换行 代码段code 插图figure 可以包裹图片或代码段12345678910&lt;figure&gt; &lt;figcaption&gt;定义一个函数&lt;/figcaption&gt; &lt;pre&gt; &lt;code&gt; function add(x,y)&#123; return x+y &#125; &lt;/code&gt; &lt;/pre&gt;&lt;/figure&gt; 网页总体结构html5 Doctor header 页头 footer 页尾 main 正文(网页想要表达的主要内容) aside 侧边栏(和正文内容无关) article 文章 section 文档中的节，一段1234567891011&lt;article&gt; &lt;header&gt; &lt;h1&gt;字体排版&lt;/h1&gt; &lt;p&gt;作者：XXX&lt;/p&gt; &lt;/header&gt; &lt;section&gt; &lt;h2&gt;语言及范围&lt;/h2&gt; &lt;p&gt;在当代，。。。。。&lt;/p&gt; &lt;p&gt;字体排版。。。&lt;/p&gt; &lt;/section&gt;&lt;/article&gt; 强调： strong：重要性、严重性、紧急性 em：从一句话中突出某个词语 b：仅为了将词语从视觉上和其他部分区分，比如一篇论文摘要中的关键词。（不推荐） i：换一种语调去说一句话时，比如其他语言翻译，对话中的旁白。（不推荐） 定义与缩写：12&lt;dfn&gt;定义&lt;/dfn&gt; &lt;abbr title="对缩写的解释"&gt;缩写&lt;/abbr&gt; 代码1234&lt;code&gt;代码段&lt;/code&gt; &lt;var&gt;变量&lt;/var&gt; &lt;kbd&gt;键盘按键 F12&lt;/kbd&gt;&lt;samp&gt;举个例子&lt;/samp&gt; 上标和下标12&lt;sub&gt;&lt;/sub&gt; &lt;sup&gt;&lt;/sup&gt; mark 和用户当前行为相关的突出，比如在搜索结果中匹配到的词 一部分内容需要在后面引用时。 插入和删除1234&lt;ins&gt;更新&lt;/ins&gt; &lt;del&gt;删除&lt;/del&gt;&lt;!-- 用途 --&gt;&lt;del&gt;原价：199&lt;/del&gt;&lt;ins&gt;双十一：100&lt;/ins&gt; 换行控制（尽量避免）123&lt;br&gt; &lt;!-- 用途 --&gt;&lt;p&gt;https://blog.csdn.net/sunxiaofre/&lt;wbr&gt;article/&lt;wbr&gt;details&lt;wbr&gt;/695002&lt;/p&gt; div 和 span 实在找不到其他更符合语义的标签时使用 实体（Entity）字符 &amp;&nbsp;&gt; &copy;&yen;&#9775; &amp;amp;&amp;nbsp;&amp;gt;&amp;copy;&amp;yen;&amp;#9775;]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[text-size-adjust使用汇总]]></title>
    <url>%2F2018%2F06%2F21%2Ftext-size-adjust%E4%BD%BF%E7%94%A8%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[-webkit-text-size-adjust 的本职是用于mobile的，见规范 CSS Mobile Text Size Adjustment Module Level 1 和 apple 的 Safari Web Content Guide。之所以现在的桌面版webkit浏览器支持他，是因为实际上这是一下bug。Bug 56543 – CSS property “-webkit-text-size-adjust” means different things in Safari and iOS这个bug在最新版的 WebKit Nightly Builds 里已经被修复了。 这属性现在的一般用处是防止iPhone在坚屏转向横屏时放大文字（注意，就算viewport设置了maximum-scale=1.0 文字还是会放大的）。 而且iPhone和iPad的默认设定是不一样的iPhone默认设定 -webkit-text-size-adjust: auto; iPad默认设定-webkit-text-size-adjust: none;所以iPad默认是不调节的。 此属性还支持百分比，这在当前的桌面版的webkit浏览器是不支持的，所以如果不想让iPhone横坚屏切换的时候调节文字，用-webkit-text-size-adjust: 100%;绝对不能用-webkit-text-size-adjust: none;这会导致仍然支持 -webkit-text-size-adjust: none;的桌面版的webkit浏览器无法人为放大文字大小，严重影响可用性。 关于如何在chrome里实现小于12px的文字。当然文字缩小到12px以下本来就一定程度影响到可用性了，建议无视chrome的这个特性。硬要实现的话，我想到的一个变通方法是先用js判断是否为chrome （至今还没听说有区分safari 和 chrome 的 css hack ） 1var isChrome = !!window.chrome; 再用-webkit-transform: scale( ) 缩小到合适值。如果你非得要font-size:10px(使用em单位时方便计算)，你会发现在chrome里最小还是12px，就算你设置了font-size: 10px;-webkit-text-size-adjust: 100%;(或-webkit-text-size-adjust: none;)也没用。原因如下： 123div&#123; -webkit-text-size-adjust: 100%|none;&#125; 只对chrome27.0 版本以下有效，27.0以上版本无效； 只对英文才有效，对中文无效。 在新版的chrome中，已经禁止了改属性,建议使用CSS3中的方法:transform:scale(0.875);当使用transform:scale(0.875)时; 不仅是文字变小了，整个文字所在的容器也同时会变小。 123综上所述：采用-webkit-text-size-adjust: 100%;必须要用小于12px字体时，用-webkit-transform: scale( ) 缩小到合适值。]]></content>
  </entry>
  <entry>
    <title><![CDATA[工程化]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%B7%A5%E7%A8%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[工程化目的 提供一致、合理的开发基础 应对变化 提升效率 文件结构 CSS reset 设置HTMl标签的默认样式 使其在各个浏览器表现基本一致 让默认样式归零注意：reset normalize.css 设置HTML标签的默认演示 使其在各个浏览器表现基本一致 保留标签的默认样式注意：normalize CSS模块 可复用的CSS代码段 与模块在HTML中的位置无关 一般与使用的HTML标签无关 CSS模块原则面向对象（OOCSS） 结构和皮肤分离 .btn, .btn-primary, .btn-info, .btn-danger 容器和内容分离123456789101112131415161718192021/* 不推荐这样写 */.header .btn&#123; background:#f66; color:#fff;&#125;/* 推荐如下 */.btn&#123;display:inline-block;padding:0.36em 0.8em;margin-right:0.5em;border:none;border-radius:0.3em;cursor:pointer;&#125;.btn--primary&#123; background:#09c; color:#fff;&#125; /* html */&lt;button class="btn"&gt;按钮&lt;/button&gt;&lt;button class="btn btn--primary"&gt;按钮&lt;/button&gt; Media Object结构 .media .media__image .media__object .media__body .media__tile .media__description 1234567891011&lt;div class="media media--left"&gt; &lt;a class="media__image"&gt; &lt;img src="//placehold.it/100*100" alt="" class="media__object"&gt; &lt;/a&gt; &lt;div class="media__body"&gt; &lt;h3 class="media__tile"&gt;Title&lt;/h3&gt; &lt;p class="media__description"&gt; A paragraph about the media &lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415.media,.media__body&#123; overflow:hidden;&#125;.media__body:first-child&#123; margin-top:0;&#125;.media--left .media__image&#123; float:left; margin-right:1em;&#125;.media--right .media__image&#123; float:right; margin-left:1em;&#125; 单一职责原则（SRP） 尽可能细地拆分可独立复用的组件 通过组合方式使用多个组件 比如将布局和其他样式拆分123456789101112.btn&#123;display:inline-block;padding:0.36em 0.8em;margin-right:0.5em;border:none;border-radius:0.3em;cursor:pointer;&#125;.btn--primary&#123; background:#09c; color:#fff;&#125; 开闭原则 对扩展开放 对修改关闭123456789101112.box&#123; display:block; padding:10px;&#125;/* bad explame */.content .box&#123; padding:20px;&#125;/* better example */.box--large&#123; padding:20px;&#125; Don’t Repeat Yourself（DRY）1234567891011/* bad example */.selector&#123; border-top:1px solid #fcc; border-left:1px solid #fcc; border-bottom:1px solid #fcc;&#125;/* better example */.selector&#123; border:1px solid #fcc; boder-right:none;&#125; 命名 Naming 基于功能 它是用来干什么的？ .botton/ .form/ .list/ .external-link/ .tab-item/ .nav 基于内容 元素里面放的是什么内容？ .news/ .user-info/ .help/ .contact-me 基于视觉 看起来是什么样的？ .round-image/ .nowrap 命名原则 优先使用基于功能的命名 样式与内容无关 中小型网站可以基于内容去命名（如个人简历、个人博客） 大型网站可以基于视觉去命名 不要使用太具体的样式 如：不要用#left, #right 用#main, #aside 功能VS视觉VS具体样式 .warning vs .orange .btn-primary vs .btn-blue .size-large vs .width-200 .form-inline .nav-stacked CSS命名规范-BEM Block：可以独立出来的一个个块 Element：Block里面的元素 Modifier：修饰，对抽象出来的基本样式的扩展 .block__element--modifier12345&lt;nav class="tabs tabs--stacked"&gt; &lt;a href="#" class="tabs__item tabs__item--active"&gt;Home&lt;/a&gt; &lt;a href="#" class="tabs__item"&gt;Javascript&lt;/a&gt; &lt;a href="#" class="tabs__item"&gt;Css&lt;/a&gt;&lt;/nav&gt; 编写简洁易维护的CSS-CSS预处理 less Sass Stylus PostCSS css新特性cssnext css变量 123456:root&#123; --primary-color:#f66;&#125;h1,h2,h3&#123; color:var(--primary-color)&#125; Nesting 嵌套 1234567.navbar&#123; display:table; &amp; .navbar__item&#123; display:table-cell; color:#fff; &#125;&#125; minxs 1234567891011:root&#123; --h-center&#123; margin-left:auto; margin-right:auto; &#125;&#125;.main&#123; @apply --h-center; max-width:100em; min-width:40em;&#125; 颜色相关函数 12345678910:root&#123; --primary-color:#666;&#125;.btn&#123; background:var(--primary-color); &amp;:hover&#123; /* 把颜色加暗20% */ background: color(var(--primary-color) blackness(20%)); &#125;&#125; import (http请求数量大) 12345/* app.css */@import 'variables.css';@import 'common.css';@import 'modules/button.css';@import 'modules/form.css' Plugins AutoPrefixer StyleLint]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兼容性]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%85%BC%E5%AE%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[CSS中的兼容性问题 浏览器不支持该特性 某些特定条件下触发浏览器bug 浏览器特性支持 caniuse.com MDN CSS Reference Codrops CSS Reference QuirksMode.org CSS 你需要兼容哪些浏览器 根据用户群体决定 面向普通用户：IE8+、Chrome、Firefox 企业级产品：IE9+、Chrome、Firefox 了解浏览器市场份额 日志分析 百度统计、NetMarketShare 浏览器不支持时怎么办？ 如果低版本浏览器没有这个特性可以接受吗？ border-radius不支持时，没有圆角 box-shadow不支持时，没有阴影 可以使用效果稍微差一点的替代方案吗？ min-height:100vh用min-height:800px代替 可以使用一些替代方案吗？ opacity:0.5在IE下用filter:alpha(opacity=50) 可以使用JavaScript让浏览器支持吗？ 使用html5shim.js让IE6～8支持新标签 使用DD_belatePNG.js让IE6只吃半透明png图片 更换实现方式 不同浏览器使用不同的样式@supports123456789.contrainer&#123; display:flex;&#125;@supports(display:grid)&#123; .container&#123; display:grid; grid-template:repeat(4,1fr)/50px 100px; &#125;&#125; 浏览器hack原理-层叠 同一个属性，后面书写的值覆盖前面书写的值 12line-height:2;line-height:3; 对当前浏览器来说无效的属性和属性值会被忽略 1234p&#123; display:table; display:flex; &#125; 浏览器hack原理- 条件注释1234567891011&lt;!-- [if IE 7] &gt;&lt;p&gt;只能在 IE 7下看见我&lt;/p&gt;&lt;![endif] --&gt;&lt;!-- [if lt IE 8] &gt;&lt;p&gt;只能在小于 IE 8的浏览器下看见我&lt;/p&gt;&lt;![endif] --&gt;&lt;!--[if lt IE 7 ]&gt;&lt;html class="ie6" lang="zh-cn"&gt;&lt;![endif]--&gt;&lt;!--[if IE 7 ]&gt;&lt;html class="ie7" lang="zh-cn"&gt;&lt;![endif]--&gt;&lt;!--[if IE 8 ]&gt;&lt;html class="ie8" lang="zh-cn"&gt;&lt;![endif]--&gt;&lt;!--[if IE 9 ]&gt;&lt;html class="ie9" lang="zh-cn"&gt;&lt;![endif]--&gt;&lt;!--[if (gt IE 9)|!(IE)]&gt;&lt;!--&gt;&lt;html class="" lang="zh-cn"&gt;&lt;!--&lt;![endif]--&gt; 浏览器怪癖 iE6 IE 6 不支持两个或多个类选择器直接组合，只会解析最后一个。 只有iE6会忽略_123456789/* ie6不支持两个或多个类选择器直接组合 */.unsed-class.selector&#123; /* iE6 only css */&#125;.container&#123; height:100px; /* 只有iE6会忽略_ ,认为是height*/ _height:200px;&#125; iE7 只有IE6 和7 会忽略*12345.container&#123; height:100px; /* 只有IE6 和7 会忽略* */ *height:200px;&#125; ie8 IE6-8不支持 :root选择器 IE6-8 会忽略\9 :root选择器相当于html123456789/* IE6-8不支持 `:root`选择器 */:root .selector&#123; /* ie6-8 style */&#125;.selector&#123; color:#fff; /* ie6-8 会忽略\9 */ color:#fff\9;&#125; 小测试：123456.top&#123; background:blue; background:red\9; *background:block; _background:orange;&#125; css2选择器的兼容性（IE6-7）IE6不支持多个类直接组合 p.class-a.class-b被当作p.class-b 解决方法：处理好选择器优先级 IE 6 不支持父子选择器和兄弟选择器 E&gt; F、E+F和E~F选择器无效 解决办法：避免使用，用后代选择器替代 IE 6 不支持属性选择器 任何一种都不支持 解决办法：用class选择器替代 IE 6-7 不支持某些伪元素 不支持:before和:after 解决办法：改变实现方式、或在HTML中添加标签 IE 6 不支持某些伪类 非链接不能使用:hover, :active 解决办法：使用a嵌套需要hover的元素 IE6-7不支持：:focus伪类 解决办法：使用javascript IE 6 不支持first-child伪类 解决办法：给第一个元素添加class=&quot;first&quot; IE6不支持min/max-width/height min-height解决办法 1234div&#123; min-height:500px; _height:500px;&#125; max-width解决办法 123456789101112131415&lt;div&gt; &lt;div class="strut"&gt;&lt;/div&gt; &lt;!-- other content --&gt;&lt;/div&gt;&lt;style&gt;.container&#123; min-width:500px;&#125; /* IE6 */.container .strut&#123; height:1px; width:500px;&#125;&lt;/style&gt; max-width/height解决办法 使用javascript iE6不支持position:fixed123456789html,body&#123; height:100%;&#125;.go-top&#123; position:fixed; _position:absolute; bottom:0; right:0;&#125; ie6-7不支持块级元素inline-block 行级元素支持,而块级元素不支持 解决办法123456.selector&#123; display:inline-block; *display:inline; /* BFC可以设置上下padding和margin,width,height,块级盒子拥有的属性*/ *zoom:1;&#125; ie6-7 不支持display:table 请使用float或者inline-block布局 不要使用table布局 CSS3 选择器兼容性 CSS3中的大部分选择器，兼容性是IE 9+ 例如：:target, :empty, :nth-child, :nth-of-type, :checked, :disabled 无法在IE6-8用 移动端支持绝大多数CSS3选择器iE8 box-sizing outline ie8 不支持 background-size 推荐在IE8及以下使用固定宽度布局 border-radius box-shadow opacity filter:alpha(opacity=50) rgba、hsl、hlsa 一般场景下，使用相近的不透明颜色代替 Alpha可以通过增加额外元素，并设置透明度实现 rem/vh/vw/calc 降级为固定宽度 ie9 transition与animation 可以接受的降级 实在不能使用就用Javascript media query 基本的媒体(all/print/screen/speech)都支持 媒体特性（width/height/orientation、、、）IE9及其以上 还是建议IE8及其以下使用固定宽度 浏览器前缀 浏览器厂商为了实验新特性,在属性名前加前缀 Chrome/Safari/Opera：-webkit- Microsoft：-ms- Mozilla/Firefox：-moz- 注意：前缀 语义化的HTML5标签12345678&lt;!--[if lte IE 8]&gt; &lt;script src="html5shiv.js"&gt;&lt;/script&gt;&lt;![endif] --&gt;&lt;style&gt; article,main,nav,aside,section,header,footer,figure,figcaption&#123; display: block; &#125;&lt;/style&gt; html5shiv.js12345678(function()&#123; var tags='abbr,article,aside,audio,bdi,canvas,data,datalist,details,dialog,figcaption,figure,footer,header,hgroup,main,mark,meter,nav,output,picture,progress,section,summary,template,time,video'.split(','); console.log(tags) var i=tags.length; while(i--)&#123; document.createElement(tags[i]) &#125; &#125;)() 浏览器BUGIE6下半透明png显示不正确- [DD_belatedPNG.js](http://www.dillerdesign.com/experiment/DD_roundies/) - filter 123456789.select&#123; background:url(/path/to/img.png) no-repeat; _background:none; /* 图片URL必须是完整路径 */ _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader( src='/path/to/img.png', sizingMethod='crop' )&#125; IE6浮动双边距 浮动元素的与浮动同方向的边距加倍 12345.selector&#123; float:left; /* IE6下显示20px */ margin-left:10px;&#125; 解决办法 12345.selector&#123; float:left; margin-left:10px; _display:inline;&#125; hasLayout On Having Layout zoom:1 IE 模式 浏览器模式 Browser Mode 切换渲染引擎、JavaScript引擎和HTTP请求的UserAgent 兼容模式相当于使用IE7的引擎 对于IE浏览器可以用F12切换浏览器模式 文档模式 切换文档模式，即渲染引擎和JavaScript引擎 浏览器模式指定之后，会自动切换文档模式 控制IE模式（&lt;=10） DocType有无控制是否进入怪异模式 meta标签控制进入哪种文档模式12345&lt;!--使用IE7模式渲染--&gt;&lt;meta http-equiv="x-ua-compatible" content="IE=7"&gt;&lt;!--使用最新引擎--&gt;&lt;meta http-equiv="x-ua-compatible" content="IE=edge"&gt;&lt;title&gt;控制IE模式&lt;/title&gt; 测试兼容性 虚拟机 BrowserStack Polyfill 使用代码帮助浏览器实现它尚未支持的特性 使用（未来）标准写法 css Polyfills selectivizr CSS3 PIE box-sizing-polyfill flexibility cssSandpaper]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式设计]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[响应式页面设计 响应式设计：同一个页面可以适应不同屏幕大小设备的设计方案 viewport PC页面宽度：980px &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 响应式的图片 大图随容器自动缩放，保持高宽比 实现方式：给所有图片添加：max-width:100%123img&#123; max-width:100%;&#125; 背景图片 background-size:cover：图片会覆盖容器，铺满，图片可能被裁切掉， background-size:contain：若图片很重要，不希望被裁切，用这个，图片会完整显示 保持高宽比（做视频时常用小技巧） padding的百分比是相当于盒子的宽度的百分比 可以用于：保持高宽比12345div&#123; height:0; padding-top:50%; background:#f99;&#125; 两栏：自适应布局 float 与 BFC 绝对定位 模拟table flex布局 搜索12345678910111213141516171819202122&lt;form action=""&gt; &lt;input type="search"&gt; &lt;button&gt;搜索&lt;/button&gt;&lt;/form&gt; &lt;style&gt; form&#123; margin-right: 4em; position: relative; &#125; form input&#123; width: 100%; font-size: inherit; line-height: 1.4; &#125; form button&#123; position: absolute; left: 100%; top: 0; width: 4em; font-size: inherit; &#125; &lt;/style&gt; 网格布局，自动换行 inline-block + justify flex123456789101112131415161718192021222324252627&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt;&lt;/ul&gt;&lt;style&gt; ul&#123; margin: 0; padding: 0; text-align: justify; &#125; li&#123; display: inline-block; width: 30%; width: 4em; height: 0; padding-top: 20%; background: lightcyan; text-align: center; margin-bottom: 1em; &#125;&lt;/style&gt; media query 针对不同的屏幕，应用不同的样式1234567&lt;link rel="stylesheet" href="media.css" media="screen and (max-width: 480px)"&gt;&lt;style&gt;@media screen and (min-width: 480px)&#123; .selector&#123;...&#125; &#125;&lt;/style&gt; 可以查询的media width height device-width device-height device-pixel-ratio(屏幕分辨率,img上应用) orientation (横屏、竖屏)123456789101112131415161718192021222324252627282930313233&lt;nav&gt; &lt;a href="#"&gt;javascript&lt;/a&gt; &lt;a href="#"&gt;css&lt;/a&gt; &lt;a href="#"&gt;html&lt;/a&gt; &lt;style&gt; body&#123; margin:0; &#125; nav&#123; display: flex; width:100%; background:#00BCD4; &#125; nav a&#123; flex:1; text-decoration: none; color:#fff; padding: 0 1em; font:normal 14px/2 Helvetica,sans-serif; &#125; nav a:not(:first-child)&#123; border-left:1px solid rgba(255,255,255,0.7) &#125; @media screen and (max-width:480px)&#123; nav&#123; flex-direction: column; &#125; nav a:not(:first-child)&#123; border-left:none; border-top:1px solid rgba(255,255,255,0.7) &#125; &#125; &lt;/style&gt; 字体设置12345@media screen and (max-width:1000px)&#123;html&#123; font-size:14px;&#125;&#125; calc(计算)123html&#123; font-size:calc(10px + 1vw)&#125; 参考：更多]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级选择器]]></title>
    <url>%2F2018%2F06%2F20%2F%E9%AB%98%E7%BA%A7%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[伪类:target 伪类 表示元素被hash匹配时的状态 比如 URL 是/post/a#headTopic时，name 为headTopic的元素处于被target的状态 可以实现简单的内容的切换（高亮显示）123456789101112131415161718192021222324252627&lt;a href="#p1"&gt;One&lt;/a&gt;&lt;a href="#p2"&gt;Two&lt;/a&gt;&lt;a href="#p3"&gt;Three&lt;/a&gt;&lt;a href="#p4"&gt;Four&lt;/a&gt;&lt;p id="p1"&gt;此处是第一段&lt;/p&gt;&lt;p id="p2"&gt;此处是第二段&lt;/p&gt;&lt;p id="p3"&gt;此处是第三段&lt;/p&gt;&lt;p id="p4"&gt;此处是第四段&lt;/p&gt; &lt;style&gt; p:target&#123; background: red; color: #FFFFFF; &#125; a&#123; font-size: 24px; width: 20%; height: 40px; text-align: center; display: inline-block; text-decoration: none; color: #b6c1d3; background: #bee6b9; &#125; a:hover&#123; color: red; &#125; &lt;/style&gt; :lang 伪类 元素匹配上指定语言时的状态 浏览器通过lang属性获得语言信息1234567891011&lt;section lang="fr"&gt; &lt;p&gt;&lt;q&gt;C'est la vie&lt;/q&gt;,il parlait.&lt;/p&gt;&lt;/section&gt;&lt;style&gt; :lang(fr) q:before&#123; content:"《" &#125; :lang(fr) q:after&#123; content: "》" &#125;&lt;/style&gt; :nth-child() 结构性伪类（与元素出现的位置有关） 通过：:nth-child(an+b)选中某些子元素 例如：:nth-child(3n)选中第3、6、9 … 个子元素 其中a可以为负数 n是自然数,可以为01234567891011121314&lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;li&gt;Item 4&lt;/li&gt; &lt;li&gt;Item 5&lt;/li&gt; &lt;li&gt;Item 6&lt;/li&gt;&lt;/ul&gt;&lt;style&gt; li:nth-child(3n+1)&#123; /* 第一个和第四个 */ color:red; &#125;&lt;/style&gt; 隔行换色 123456789101112131415161718&lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;li&gt;Item 4&lt;/li&gt; &lt;li&gt;Item 5&lt;/li&gt; &lt;li&gt;Item 6&lt;/li&gt;&lt;/ul&gt;&lt;style&gt; li:nth-child(odd)&#123; /*奇数 */ color:red; &#125; li:nth-child(even)&#123; /* 偶数 */ color:green; &#125;&lt;/style&gt; :nth-of-type (第n个这种类型的) 同一种类型的元素nth-child() 与 nth-of-type 的区别 父级 :nth 123456789101112131415&lt;article&gt; &lt;h2&gt;这是标题&lt;/h2&gt; &lt;p&gt;Paragraph one&lt;/p&gt; &lt;p&gt;Paragraph two&lt;/p&gt; &lt;p&gt;Paragraph three&lt;/p&gt; &lt;p&gt;Paragraph four&lt;/p&gt;&lt;/article&gt;&lt;style&gt; article :nth-child(3n+1)&#123; color: #cc0804; &#125; article :nth-of-type(3n+1)&#123; text-decoration: line-through; &#125; &lt;/style&gt; 子集:nth 1234567891011121314151617&lt;article&gt; &lt;h2&gt;这是标题&lt;/h2&gt; &lt;p&gt;Paragraph one&lt;/p&gt; &lt;p&gt;Paragraph two&lt;/p&gt; &lt;p&gt;Paragraph three&lt;/p&gt; &lt;p&gt;Paragraph four&lt;/p&gt;&lt;/article&gt;&lt;style&gt; p:nth-child(2)&#123; /* &lt;p&gt;Paragraph one&lt;/p&gt; */ color: #cc0804; &#125; p:nth-of-type(2)&#123; /* &lt;p&gt;Paragraph two&lt;/p&gt; */ text-decoration: line-through; &#125; &lt;/style&gt; 更多区别 :first-child/:last-child 伪类:not() 伪类 排除匹配的元素 比如：img:not([alt])选择没有写alt属性的图片123button:not(:last-child)&#123; margin-right:2em;&#125; 其他选择器 伪类 :nth-last-child (对应nth-child) :nth-last-of-type(对应nth-of-type) :first-of-type (对应first-child) :last-of-type (对应last-child) :only-child (父母唯一的子元素) :only-of-type (父母唯一同一类型的子元素) :empty 伪类1234&lt;!-- 标签中没内容 --&gt;li:empty&#123; display:none;&#125; 伪元素伪类与伪元素的区别 伪类是在HTML中真实存在的元素 伪元素在HTML中是根本就没有的元素，是在CSS中虚拟出来的元素。 伪元素一般用两个冒号开头::。如：p::first-line{}。 ::first-line 伪元素选中第一行123p::first-line&#123; color:red;&#125; ::first-letter 伪元素选中第一个字母12345p::first-letter&#123; font-size:2em; float:left; color:red;&#125; 兄弟选择器 相邻兄弟选择器E+F 通用兄弟选择器E~F注意:这两种兄弟选择器选择的都是在其下面的兄弟，不管上面的兄弟。（只选弟弟）123456789101112&lt;p&gt;The first paragraph&lt;/p&gt;&lt;h2&gt;The h2 title&lt;/h2&gt;&lt;p&gt;The second paragraph&lt;/p&gt;&lt;p&gt;The third paragraph&lt;/p&gt;&lt;style&gt; h2 + p &#123; color: #e8c; &#125; h2 ~ p &#123; text-decoration: underline; &#125;&lt;/style&gt; :checked~F123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;div class="toggle"&gt; &lt;input type="checkbox" checked id='t'&gt; &lt;label for="t"&gt;&lt;/label&gt;&lt;/div&gt;&lt;style&gt; .toggle &#123; width: 80px; height: 26px; background: #333; margin: 20px auto; position: relative; border-radius: 50px; box-shadow: inset 0px 1px 1px 1px rgba(0, 0, 0, 0, 0.5), 0px 1px 0px rgba(255, 255, 255, 0.2); &#125; .toggle:after &#123; content: 'OFF'; color: #fff; position: absolute; right: 10px; z-index: 0; font: 12px/26px Arial, sans-serif; font-weight: bold; text-shadow: 1px 1px 0 rgba(255, 255, 255, .15) &#125; .toggle:before &#123; content: 'ON'; color: #f66; position: absolute; left: 10px; z-index: 0; font: 12px/26px Arial, sans-serif; font-weight: bold; &#125; .toggle label &#123; display: block; width: 34px; height: 20px; cursor: pointer; position: absolute; top: 3px; left: 3px; z-index: 1; background: #fcfff4; background: linear-gradient(top, #fcfff4 0%, #dfe5d7 40%, #b3bead 100%); border-radius: 50px; transition: all 0.4s ease; box-shadow: 0px 2px 5px 0px rgba(0, 0, 0, .3) &#125; .toggle input[type=checkbox] &#123; visibility: hidden; &#125; .toggle input:checked+label &#123; left: 43px; &#125;&lt;/style&gt;]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画]]></title>
    <url>%2F2018%2F06%2F19%2F%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[transform 变换 对元素进行平移、旋转、缩放 transform不会对其他元素布局产生影响,类似position:reltive 取值：none|&lt; transform-list&gt; translate translateX/translateY/translateZ translateZ 前后移动 负值向后移动 正值 向前移动rotate 单位：deg rotateX/rotateY/rotateZ scale 缩放 (原始大小的多少倍) scaleX/scaleY skew 斜切 单位：deg skewX/skewY 正值 拉 左上角 和 右下角 负值 拉 右上角 和 左下角 transform-origin 旋转原点 关键字: top bottom center left right; 具体的长度单位(em,rem,px…) transform-style(3d空间) transform-style: preserve-3d; / 保留子元素的3d变换， 3d空间/ perspective 视点 指定进行3D渲染时，人眼距离Z平面的距离 不会影响元素本身的渲染 只会影响子元素的3D效果 放在要变换的元素的父级身上 backface-visibility(隐藏背面) backface-visibility:hidden; 背面即和父级角度相对的面 是给每个子元素加backface-visibility:hidden; 重点: rotate、skew、scale默认都是围绕着元素的中心点进行变化的 transform 的执行循序后写的先执行 会受到原点影响的变换有：rotat、skew、scale translate 移动不会改变原点的位置 transform-origin: center center 0px;有3d，参数分别代表x,y,z; 默认值：center center 0px transform-style表示父级进行3d变化是第一子集是够保留3d变化.如果是第二子集,要在第一子集上写tansform-style ios设备下变换原点的z轴有问题会变大,和一些其他的bug。解决方法 子元素可以rotate(90deg) transformZ(50px)移动 ,但是还会变大：所以父元素transformZ(-50px); translation 过渡 指定一个样式状态到另一个状态时如何过渡，即两个状态之间的过渡 动画的意义：告诉用户发生了什么 指定过渡： 什么属性发生变化时需要过渡 过渡持续多长时间 速度变化是什么样 是否有延迟 transition transition-property transition-duration transition-timing-function transition-delay 可以给每个属性指定不同的transition12345678910.box&#123; height:100px; width:100px; background:orange; transition:width 1s ease 1s,height 1s ease;&#125;.box:hover&#123; width:200px; height:200px;&#125; transition-timing-function 时间与进度的关系参考:http://cubic-bezier.com/#.63,.47,.83,.67 animation 动画 animation可以实现更复杂的样式变化效果，多个状态的连续的变化 定义关键帧 指定动画行为123456789101112131415161718192021222324252627&lt;i class="scroll-down"&gt;↓ 喜欢我就点我吧！&lt;/i&gt; &lt;style&gt; @keyframes down&#123; from&#123; margin-top: 0; opacity: 1; /*opacity：透明度， 当opacity为1时就是完全不透明。*/ &#125; 50%&#123; margin-top: 0.5em; opacity: 0.3; &#125; to&#123; margin-top: 0; opacity: 1; &#125; &#125; .scroll-down&#123; position: fixed; top: 50%; left: 50%; margin-left: -0.5em; font: normal normal 36px/1 Helvetica; color: #f55; animation: down 1.5s ease infinite; &#125; &lt;/style&gt; 复杂动画效果：盛开的花朵123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;div class="box"&gt; &lt;div class="leaf"&gt;&lt;/div&gt; &lt;div class="leaf"&gt;&lt;/div&gt; &lt;div class="leaf"&gt;&lt;/div&gt; &lt;div class="leaf"&gt;&lt;/div&gt; &lt;div class="leaf"&gt;&lt;/div&gt; &lt;div class="leaf"&gt;&lt;/div&gt; &lt;div class="leaf"&gt;&lt;/div&gt; &lt;div class="leaf"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .box&#123; position: relative; height: 200px; width: 200px; margin: 2px 0 0 80px; &#125; .box .leaf&#123; position: absolute; &#125; .leaf&#123; margin-top: 200px; width: 100px; height: 150px; border-radius: 150px 0; background: linear-gradient( 45deg, rgb(255, 229, 229) 10%, rgb(255, 134, 161) 30%, rgb(255, 249, 24) 100% ); opacity: 0.5; transform: rotate(45deg); transform-origin: top right; &#125; .leaf:nth-child(2)&#123; animation: show-2 6s ease-in-out 1; &#125; .leaf:nth-child(3)&#123; animation: show-3 6s ease-in-out 1; &#125; .leaf:nth-child(4)&#123; animation: show-4 6s ease-in-out 1; &#125; .leaf:nth-child(5)&#123; animation: show-5 6s ease-in-out 1; &#125; .leaf:nth-child(6)&#123; animation: show-6 6s ease-in-out 1; &#125; .leaf:nth-child(7)&#123; animation: show-7 6s ease-in-out 1; &#125; .leaf:nth-child(8)&#123; animation: show-8 6s ease-in-out 1; &#125; @keyframes show-2&#123; 0%&#123; transform: rotate(45deg); &#125; 100%&#123; transform: rotate(71deg); &#125; &#125; @keyframes show-3&#123; 0%&#123; transform: rotate(45deg); &#125; 100%&#123; transform: rotate(96deg); &#125; &#125; @keyframes show-4&#123; 0%&#123; transform: rotate(45deg); &#125; 100%&#123; transform: rotate(123deg); &#125; &#125; @keyframes show-5&#123; 0%&#123; transform: rotate(45deg); &#125; 100%&#123; transform: rotate(149deg); &#125; &#125; @keyframes show-6&#123; 0%&#123; transform: rotate(45deg); &#125; 100%&#123; transform: rotate(175deg); &#125; &#125; @keyframes show-7&#123; 0%&#123; transform: rotate(45deg); &#125; 100%&#123; transform: rotate(200deg); &#125; &#125; @keyframes show-8&#123; 0%&#123; transform: rotate(45deg); &#125; 100%&#123; transform: rotate(220deg); &#125; &#125; &lt;/style&gt;]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布局]]></title>
    <url>%2F2018%2F06%2F19%2F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[布局方法 float position inline-block table flex grid 水平居中 行级元素：text-align:center 块级元素：margin:auto auto是根据盒子的宽度和两边剩余的宽度决定的,如果盒子的左右边的间距没设置，他会根据剩余间距的一半来对其盒子，使盒子居中 垂直居中 单行文字:line-height 行级盒子：vertical-align:middle 绝对定位：top:50%;left:50%; 行级元素 12345678910111213141516171819&lt;p&gt;&lt;em&gt;共享&lt;/em&gt;未安装人群&lt;/p&gt;&lt;style&gt; p&#123; padding: 0 1em; background: #eee; line-height: 2; font-size: 16px; &#125; em&#123; font-size: 12px; background: #0c7dc5; display: inline-block; vertical-align: middle; line-height: 1.5; padding: 0 0.5em; font-style: normal; color: #fff; &#125;&lt;/style&gt; 块级元素(已知宽高) 12345678div&#123; width:20em; height:10em; left:50%; top:50%; margin-left:-10em; margin-right:-5em;&#125; float-based(两栏布局)1234567891011121314151617&lt;main&gt; &lt;aside&gt;aside&lt;/aside&gt; &lt;article&gt;3月20日，据北京市政一卡通公司消息，一卡通公司已经试点推出了“扫码乘公交”服务，用户无论持何种型号的智能手机，只要扫描二维码即可乘坐公交车&lt;/article&gt;&lt;/main&gt;&lt;style&gt; aside&#123; width: 10em; float:left; background:lightblue; min-height: 10em; &#125; article&#123; overflow: hidden; min-height: 10em; background:orange; &#125;&lt;/style&gt; float-based的缺点：后面的内容区域一定要BFC,aside和article的位置不能改变 updated（两栏布局）1234567891011121314151617181920212223242526272829&lt;main&gt; &lt;article&gt;3月20日，据北京市政一卡通公司消息，一卡通公司已经试点推出了“扫码乘公交”服务，用户无论持何种型号的智能手机，只要扫描二维码即可乘坐公交车&lt;/article&gt; &lt;aside&gt;aside&lt;/aside&gt; &lt;/main&gt; &lt;style&gt; main &#123; font-size: 14px; padding-left: 10em; &#125; article &#123; float: left; width: 100%; min-height: 10em; background: orange; &#125; aside &#123; width: 10em; float: left; background: lightblue; min-height: 10em; position: relative; /* 重要 */ margin-left: -10em; /* 重要 */ left:-100%; &#125; &lt;/style&gt; （伪）等高 在float布局的时候,我们通过padding-bottom和margin-bottom实现的,padding的效果是content的高度不变,但是把整个容器撑开了,但是margin如果是负值,他会把整个盒子的高度缩小。所以我们能看到背景颜色一直等高。其实就是padding撑开的。背景颜色实际就是padding。 12345678910111213141516171819202122232425262728293031&lt;main&gt; &lt;article&gt;3月20日，据北京市政一卡通公司消息，一卡通公司已经试点推出了“扫码乘公交”服务，用户无论持何种型号的智能手机，只要扫描二维码即可乘坐公交车&lt;/article&gt; &lt;aside&gt;aside&lt;/aside&gt; &lt;/main&gt; &lt;style&gt; main &#123; font-size: 14px; padding-left: 10em; overflow: hidden; &#125; article &#123; float: left; width: 100%; background: orange; /* 重要 */ padding-bottom:99em; margin-bottom: -99em; &#125; aside &#123; width: 10em; float: left; background: lightblue; position: relative; margin-left: -10em; left:-100%; /* 实现 */ padding-bottom:99em; margin-bottom: -99em; &#125; position(两栏布局)12345678910111213141516171819202122232425&lt;main&gt; &lt;article&gt;3月20日，据北京市政一卡通公司消息，一卡通公司已经试点推出了“扫码乘公交”服务，用户无论持何种型号的智能手机，只要扫描二维码即可乘坐公交车&lt;/article&gt; &lt;aside&gt;aside&lt;/aside&gt; &lt;/main&gt; &lt;style&gt; main &#123; font-size: 14px; position:relative; &#125; article &#123; background:coral; margin-left:10em; &#125; aside &#123; width: 10em; background: lightblue; position: absolute; left:0; top:0; /* 伪登高 */ bottom:0; &#125; &lt;/style&gt; table table会自适应table-layout:fixed是按th的比例,来平均分配单元格的宽度的 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;浏览器&lt;/th&gt; &lt;th&gt;Javascript 引擎&lt;/th&gt; &lt;th&gt;css 引擎&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;Chrome&lt;/th&gt; &lt;td&gt;V8&lt;/td&gt; &lt;td&gt;Blink&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Firefox&lt;/th&gt; &lt;td&gt;SpiderMonkey&lt;/td&gt; &lt;td&gt;Geocko&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;Edge&lt;/th&gt; &lt;td&gt;ChakraCore&lt;/td&gt; &lt;td&gt;Edgehtml&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;style&gt; table&#123; width: 100%; font-size: 14px; /* 合并单元格 */ border-collapse: collapse; &#125; tr&#123; text-align: center; &#125; td,th&#123; border:1px solid #666; padding: 1em; &#125; th&#123; width:8em; &#125; &lt;/style&gt; 注意:不要使用表格标签布局,用语义化标签 display:table(等高两栏布局)123456789div&#123;display:table; /* &lt;table&gt; */display:table-cell; /* &lt;td&gt; */display:table-row;/* &lt;tr&gt; */display:table-column; /* &lt;col&gt; */display:table-column-group; /* &lt;colgroup&gt; */display:table-footer-group; /* &lt;tfoot&gt; */display:table-header-group; /* &lt;thead&gt; */&#125; table布局没有指定宽度,就是自适应的 12345678910111213141516171819202122&lt;main&gt; &lt;article&gt;3月20日，据北京市政一卡通公司消息，一卡通公司已经试点推出了“扫码乘公交”服务，用户无论持何种型号的智能手机，只要扫描二维码即可乘坐公交车&lt;/article&gt; &lt;aside&gt;aside&lt;/aside&gt;&lt;/main&gt;&lt;style&gt; main &#123; display: table; width: 100%; font-size: 14px; &#125; article,aside &#123; display: table-cell; padding: 1em; &#125; article&#123; background:orange; &#125; aside&#123; background:lightblue; &#125;&lt;/style&gt; 导航条 123456789101112131415161718192021222324252627&lt;nav&gt; &lt;a href="#"&gt;HTML&lt;/a&gt; &lt;a href="#"&gt;CS&lt;/a&gt; &lt;a href="#"&gt;JAVASCRIPT&lt;/a&gt; &lt;a href="#"&gt;REACT&lt;/a&gt;&lt;/nav&gt; &lt;style&gt; nav&#123; width: 100%; display: table; border-collapse: collapse; font-size: 14px; line-height: 3; &#125; nav a&#123; display: table-cell; border: 1px solid white; background: hsl(160, 27%, 60%); color: rgba(255,255,255,0.9); text-align: center; text-decoration: none; &#125; nav a:hover&#123; background: hsl(181, 27%, 55%); color: #000; &#125; &lt;/style&gt; 垂直居中1234567891011&lt;div&gt;&lt;img src="https://p.pstatp.com/list/190x124/pgc-image/15290431498490a3c384181" alt=""&gt;&lt;/div&gt;&lt;style&gt;div&#123; width: 300px; height: 300px; text-align: center; vertical-align: middle; background: orange; display: table-cell;&#125;&lt;/style&gt; flexbox真正为解决布局问题而生的规范 Flexbox可控制子元素： 水平或垂直排成一行 控制子元素对齐方式 控制子元素的宽度／高度 控制子元素的显示顺序 控制子元素是否折行 display:flex 将元素变为Flexbox 子元素在容器内水平（默认）或垂直摆放 flex-direction 子元素排列方向 取值：row（默认按行排列）| row-reverse | column | column-reverse 主轴与侧轴 主轴永远是子元素流动、摆放的方向 flex-wrap 折行 元素在主轴方向摆放时，是否换行 取值：nowrap | wrap | wrap-reverse justify-content 主轴方向摆放 子元素沿主轴方向的摆放 取值：flex-start | flex-end | center | space-between | space-around align-items 侧轴方向摆放 在侧轴方向的对齐方式 取值：flex-start | flex-end | center | baseline | stretch 默认值：stretch align-content 多行内容在容器内侧轴方向的对齐 取值：flex-start|flex-end|center|space-between|space-around|stretch align-self在某个子元素上设置对齐方式。 flex-grow 弹性 定义每一个子元素在盒子内的弹性 拓展盒子剩余空间的能力 取值：数字,默认0 flex-shrink 收缩 元素收缩的能力 取值：数字，默认为1 flex-shrink:0;不收缩 order 指定摆放时的顺序，从小到大 取值：数字，默认为0 flexbox 语法变化12345678910111213141516div &#123; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-direction: normal; -webkit-box-orient: horizontal; -ms-flex-direction: row; flex-direction: row; -ms-flex-wrap: nowrap; flex-wrap: nowrap; -webkit-box-pack: start; -ms-flex-pack: start; justify-content: flex-start; -ms-flex-line-pack: stretch; align-content: stretch;&#125; Grid 兼容性]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-排版细节(7)]]></title>
    <url>%2F2018%2F06%2F15%2F%E6%8E%92%E7%89%88%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[行级格式化上下文（Inline Formatting Context） baseline基线;ascender line上线;descender line下线;mean line均线;cap line 大写字母的上线 line-height行高：两行的base-line间的间距 vertical-align 定义盒子所处的行盒（line box）的垂直对齐关系 取值：baseline | sub | super | top | text-top | middle | bottom | text-bottom |&lt; percentage&gt;|&lt; length&gt; 百分比相对于元素自身的行高 初始值baseline top和bottom的值,是由该行盒的最高点和最低点决定的,middle是text-top和text-bottom的中间位置 strut baseline是如何确立的呀?虽然p元素里面没有文字,但是他会默认的生成一个匿名的盒子,继承父级的font-size和font-family 123456789&lt;p&gt; &lt;img src="http://img0.utuku.china.com/400x0/news/20180615/1cea34c8-569f-4cd8-b0fe-dd05cd0ff077.jpg" alt=""&gt;&lt;/p&gt;&lt;style&gt;p&#123; padding: 0; background: red;&#125;&lt;/style&gt; 解决办法： font-size:0 将img元素转成块级元素 img设置vertical-align:middle vertical-align:起作用的元素 inline（行内元素） table-cell（单元格） inline-block（行内块元素） vertical-align:middle inline/inline-block元素： 元素的垂直中心点和父元素基线上1/2 x-height处对齐。 table-cell元素： 单元格填充盒子相对于外面的表格行居中对齐。 lists style 列表 display:list-item会生成两个盒子：Principle Block Box(li内容)和Marker Box(li的小圆点) Marker Box的内容和位置可以通过list-style系列属性指定list-style-position inside outside(默认) list-style-type none disc实心 circle空心 square方块 decimal数字 lower-roman罗马字符 upper-roman lower-greek希腊字符 lower-latin拉丁字符 upper-latin armenian georgian lower-alpha upper-alpha list-style-image list-style-image:url(http://…) list-style缩写 list-style-type、list-style-position和list-style-image三个属性的简写 background background-color background-image background-repeat background-position123body&#123; background: red url(path/to/img.png) no-repeat 0 0;&#125; background-sizebackground-size:宽度,高度;：调整背景图大小。或者：background-size:contain;。或者：background-size:cover; CSS Sprites 将小图片合并成一张图，从而减少页面请求的次数，加快页面的加载速度.background-position:50% 50%是将图片的50%和容器的50%对齐 border-radius border-radius:5px 可以指定四个方向 可以指定百分数123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div class="id1"&gt;1&lt;/div&gt; &lt;div class="id2"&gt;2&lt;/div&gt; &lt;div class="id3"&gt;3&lt;/div&gt; &lt;div class="id4"&gt;4&lt;/div&gt; &lt;div class="id5"&gt;5&lt;/div&gt; &lt;div class="id6"&gt;6&lt;/div&gt; &lt;div class="id7"&gt;7&lt;/div&gt; &lt;style&gt; .id1&#123;border-radius: 10px &#125; .id2&#123; border-radius: 10px; border:3px solid green; &#125; .id3&#123; border-radius: 5px 20px; &#125; .id4&#123; /* 控制两边的弧度 */ border-radius: 10px/30px; &#125; .id5&#123; border-radius: 30px/10px; &#125; .id6&#123; border-radius:50%; &#125; .id7&#123; width: 200px; border-radius: 50%; &#125; div&#123; background: #BADA55; width: 100px; height:100px; text-align: center; line-height: 100px; color: #000; font-size: 24px; font-family: Helvetical,sans-serif; float: left; margin: 1em; &#125; &lt;/style&gt; box-shadow none 无阴影 阴影水平偏移值,可负值 阴影垂直偏移值,可负值 设置对象的阴影模糊值,不允许负值 用来设置对象的阴影外延值,可负值 设置对象的阴影的颜色 inset:设置对象的阴影类型为内阴影,默认：外阴影 可以用一个元素创造出来各种各样的小图标 1234div&#123; /* 可以多个阴影并存,相当于可以复制多个图标 */ box-shadow:1px 1px 22px 0 rgba(0,0,0,0.6),1px 1px 22px 0 rgba(0,0,0,0.6)&#125; 实例：https://saeedalipoor.github.io/icono/]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-定位与堆叠(6)]]></title>
    <url>%2F2018%2F06%2F14%2F%E5%AE%9A%E4%BD%8D%E4%B8%8E%E5%A0%86%E5%8F%A0%2F</url>
    <content type="text"><![CDATA[定位模式（Positioning schemeschemes） 常规流（Normal Flow） 浮动（Float） 绝对定位（Absolute Positioning） position static：非定位，默认值 relative：相对定位 absolute：绝对定位，相对非static祖先元素定位 fixed：相对于视口绝对定位 relative 在常规流里面布局 相对于自己本应该在的位置进行偏移 使用top、left、bottom、right设置偏移长度 流内其他元素当它没有偏移一样布局,所以它不会对其他元素造成布局上的影响12345678910111213141516171819202122232425&lt;figure&gt; &lt;img src="http://ww4.sinaimg.cn/bmiddle/98e8fcd9jw1f2xkao7pcuj21kw11sdo8.jpg" alt="" width="512px"&gt; &lt;figcaption&gt;图片标题&lt;/figcaption&gt;&lt;/figure&gt;&lt;!-- 虽然figcaption元素向上移了28px,但是因为relative的特性,figcaption元素依旧占据位置 --&gt;&lt;p&gt;其他文本内容。&lt;/p&gt;&lt;style&gt; figure&#123; width: 512px; &#125; figure img&#123; display: block; &#125; figcaption&#123; position: relative; top: -28px; background: rgba(0,0,0,0.3); color: #FFFFFF; font-size: 14px; line-height: 2; /*因为font-size为14px，line-height为2，故figcaption占的高度是28px*/ padding: 0 1em; &#125; &lt;/style&gt; absolute 脱离正常流 相对于最近的非static祖先的padding box定位 不会对流内元素布局造成影响 可以有margin，但不会折叠12345678910111213141516171819202122232425&lt;figure&gt; &lt;img src="http://ww4.sinaimg.cn/bmiddle/98e8fcd9jw1f2xkao7pcuj21kw11sdo8.jpg" alt="" width="512px"&gt; &lt;figcaption&gt;图片标题&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;其他文本内容。&lt;/p&gt;&lt;style&gt; figure&#123; width: 512px; position:relative; &#125; figure img&#123; display: block; &#125; figcaption&#123; position: absolute; bottom:0; width:100%; background: rgba(0,0,0,0.3); color: #FFFFFF; font-size: 14px; line-height: 2; padding: 0 1em; &#125; &lt;/style&gt; 自动计算 这些值都可以不指定 top left right bottom width height 默认是auto,它会待在原本的位置(原常规流的位置),但是不影响其他元素的,可以通过margin-left等来实现位置的移动 fixed 相对于Viewport定位 不会随页面滚动发生位置变化 z-index堆叠层次 为定位元素(设置了position非static的元素)指定其在z轴的上下等级 用一个整数表示，数值越大，越靠近用户 初始值为auto，可以为负数、0、正数12345678910111213141516171819202122232425262728&lt;div class="box-a"&gt;Box a&lt;/div&gt;&lt;div class="box-b"&gt;Box b&lt;/div&gt;&lt;div class="box-c"&gt;Box c&lt;/div&gt; &lt;style&gt; [class^="box-"]&#123; position: absolute; width: 200px; /* 单行文字一般只设置line-height,不设置height */ line-height: 200px; text-align: center; color: #FFFFFF; &#125; .box-a&#123; background: #f44336; &#125; .box-b&#123; top: 100px; left: 100px; z-index: -1; background: #0097a7; &#125; .box-c&#123; top: 150px; left: 150px; z-index: 1; background: #4caf50; &#125; &lt;/style&gt; z-index大的一定在上面吗?不一定！要看堆叠上下文,不同的堆叠上下文的z-index大小不影响,先找到相同的堆叠上下文环境 堆叠上下文的生成 Root元素 z-index值不为auto的定位元素 设置了某些CSS3属性的元素，如opacity、transform、animation等。绘制顺序 在每一个堆叠上下文中，从下到上： 形成该上下文的元素的border和background z-index为负值的子堆叠上下文 常规流内的块级元素非浮动子元素 非定位的浮动元素 常规流内非定位行级元素 z-index为0的子元素或子堆叠上下文 z-index为正数的子堆叠上下文]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-盒模型(5)]]></title>
    <url>%2F2018%2F06%2F14%2F%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[box model width 指定的是content box的宽度,不包含padding、border、margin的宽度,仅仅包含content的宽度。 百分数是指相对于父容器（包含块）的content box的宽度。 height 指定content box高度。 百分数是相对于父容器（包含块）的content box的高度。 只有当包含块的高度不依赖该元素时,其实就是父元素的高度确定值不为auto,百分比高度才生效。 根元素是viewport,高度确定,所以只需将html元素的height设为100%,body才可以设置100%1234567891011121314151617181920&lt;div class="container"&gt; &lt;div class="child"&gt; 哈哈哈哈哈哈 &lt;/div&gt;&lt;/div&gt;&lt;style&gt; body &#123; margin: 0 &#125; .container &#123; background: #f00; height: 100vh; &#125; .child &#123; height: 100%; background: coral; &#125;&lt;/style&gt; padding 内边距：内容距离盒子的距离 padding-top、padding-right、padding-bottom、padding-left 缩写：padding:上 右 下 左 两个值：padding:上下 、左右 三个值：padding:上 、左右、下 margin 外边距：一个盒子距离另外一个盒子的距离，不能超过这个数 margin-top、margin-right、margin-bottom、margin-left 缩写：margin margin折叠：margin的真正含义是：在这个盒子外多远的距离内不能再摆放其他的盒子！ margin可以为负值吗?:可以的。负值意味着两个盒子有重叠，即允许这个盒子和其他的盒子重叠多少 box-sizing（CSS3新增） 改变盒模型的计算方式 取值：border-box (padding+content+border) | content-box 初始值：content-box123456789*&#123; box-sizing:inherit&#125;html&#123; box-sizing:border-box;&#125;.book&#123; box-sizing:content-box;&#125; border 边框的三个要素： border-width：&lt; length &gt; | thin | medium | thick border-style:none | solid | dashed | dotted | double border-color:&lt; color &gt; 边框的四个方向： border-top border-right border-bottom border-left 实战当width,height设置0时,我们可以实现各种三角形了12345678910111213&lt;div class="box"&gt;&lt;/div&gt;&lt;style&gt; .box&#123; border-width: 50px; border-style:solid; border-color:#f35 #259 #649 #fa0; width:200px; height:200px; transition:all 2s ease-in; margin: 1em auto; &#125;&lt;/style&gt; max-width &amp;&amp; max-width 可以通过设置article的min-width和max-width来做文字的排版,特别是响应式的布局时比较有用。1234article&#123; max-width:40em; min-width:20em;&#125; min-height &amp;&amp; max-height min-height可以在内容少的时候,把容器撑开 123456article&#123; max-width:40em; min-width:20em; max-height:10em; overflow:hidden;&#125; overflow 溢出控制 取值：visible | hidden | scroll |auto 初始值：visible 视觉格式化模版-浏览器是怎么排版的?视口（Viewport） 浏览器的可视区域 用户通过视口查看网页内容（透过窗户看风景） 块级元素（Block-level Elements） 会被格式化成块状的元素，一块一块的，另起一行。 例如：p、div、section等 将display设置为block、list-item、table使元素变为块状 行级元素／内联元素（Inline-level Elements） 不会为其内容生成块级框 让其内容分布在多行中 display设置为inline、inline-block、inline-table使元素变为行级元素 盒子的生成 元素与盒子是两个不同的概念,元素是HTML中一个个的标签;盒子是在排版的时候,浏览器在摆放的时候会生成一个一个的盒子,一个元素可能生成多个盒子。 每个块级元素生成一个主块级盒（principal block-level box）,用它来包含子级盒 每个行级元素生成一个行级盒子，行级盒分布于多行。 Box Model - revisited margin：行级盒的margin-top和margin-bottom不会产生效果。但是行级盒的margin-left和margin-right会有效果。 padding：行级盒的padding-top和padding-bottom不影响布局，不会影响元素的摆放。 块级盒子中的字盒子的生成 块级盒子中可以包含多个子块级盒子 也可以包含多个行级盒子 不在行级元素里面的盒子，会生成匿名行级盒。比如&lt;p&gt;Some&lt;em&gt;Text&lt;/em&gt;&lt;/p&gt; 块级盒子中不能同时包含块级和行级盒子。遇到这种会生成匿名块级盒子来包裹行级盒。比如&lt;div&gt;&lt;h1&gt;标题&lt;/h1&gt;&lt;span&gt;2018-12-12&lt;/span&gt;&lt;/div&gt;行级盒子内的子盒子的生成 行级盒子内可以包含行级盒子 行级盒子包含一个块级盒子时,会被块级盒子拆成两个行级盒子，这两个盒子又分别被匿名块级盒包含123456&lt;span&gt; &lt;em&gt;（行级元素中的行级元素）&lt;/em&gt; &lt;p&gt;（行级元素中的块级元素）陈坚与机组协商无果后，多名警察登机，强行将陈坚从其靠窗的座位上拽了出来。 拉拽过程中，陈坚一度大声呼叫，随后躺倒在地上被拖拽出去。&lt;/p&gt; &lt;strong&gt;（行级元素中的行级元素）&lt;/strong&gt;&lt;/span&gt; display属性 block生成块级盒 inline生成行级盒 inline-block生成行级盒（不会换行），为其内容生成块级盒（可以设置width、height、margin、border、padding） none在排版时将元素忽略（不展示此元素） visibility（相当于是透明的） 控制元素展示（明明在那里，但是对你不可见） 取值：visible | hidden | collapse 初始值为 visible Generated Content 控制元素。这个元素在CSS中多产生一个盒子，用来存放指定的内容 ::before和::after content 打印的时候可以使用123456789&lt;a href="http://www.baidu.com"&gt;点击访问&lt;/a&gt;&lt;style&gt; a::before&#123; content: '\1993' &#125; a:after&#123; content: '('attr(href)')'; &#125;&lt;/style&gt;]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-层叠、继承和css单位(4)]]></title>
    <url>%2F2018%2F06%2F14%2F%E5%B1%82%E5%8F%A0%E7%BB%A7%E6%89%BF%E5%92%8Ccss%E5%8D%95%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[css-层叠、继承和css单位选择器的特异度(Specificity) 选择器 内联？ id个数 (伪)类个数 标签个数 特异度 #nav.listlia:link 0 1 2 2 0122 .hd ul.links a 0 0 2 2 0022 122&gt;22所以第一个的特异度大,优先级高 简单选择器的特异度级别 Level 0: * Level 1: 标签选择器、伪元素(:before、:after) Level 2:类、伪类(:link、:first-child)、属性 Level 3:id Level 4:内联 !important优先级最高,慎用 css 样式的来源 页面开发者 用户设置 浏览器预设 用户样式 浏览器可以指定一个本地css文件,打开所有页面时自动加载 浏览器预设样式 Mozilla Firefox 预设样式 Google Chrome 预设样式 Internet Explorer 预设样式 那条声明起作用 找出匹配到的该属性所有声明 根据规则来源,优先级从低到高： 浏览器预览 用户设置 网页样式 同一来源中，按照特异度排序，越特殊优先级越高 特异度一样时，按照样式书写顺序，后面的优先级高 有!important 时的变化 找出匹配到的该属性所有声明 根据规则来源,优先级从低到高： 浏览器预览 用户设置 网页样式 含!important 的网页样式 含!important 的用户网页设置 同一来源中，按照特异度排序，越特殊优先级越高 特异度一样时，按照样式书写顺序，后面的优先级高 默认值策略 Defaulting继承 某些属性会自动继承其父元素的计算值,除非显式指定一个值 123456789&lt;p&gt;this is a &lt;em&gt;test&lt;/em&gt; of &lt;strong&gt;inherit&lt;/strong&gt;&lt;/p&gt;&lt;style&gt; p&#123; color:#666; &#125; em&#123; color:red; &#125;&lt;/style&gt; 显式继承 文字相关的css会自动继承，其他的一些不可以继承可以手动继承 123456789*&#123; box-sizing:inherit;&#125;html&#123; box-sizing:border-box;&#125;.some-widget&#123; box-sizing:content-box;&#125; 初始值 css中,每个属性都有一个初始值 background-color的初始值为transparent margin-left的初始值为0 可以显式重置为初始值，比如background-color:initial; css求值的过程 由 DOM树 &amp; 样式规则 filtering:对应用到该页面的规则用以下条件进行筛选：选择器匹配、属性有效、符合当前media等 声明值:Declared Values，一个元素的某属性可能由0到多个声明值。如：p{font-size:16px}和p.text{font-size:1.2em} cascading:按照来源、!important、选择器特异性、书写顺序等选出优先级最高的一个属性值 层叠值:Cascaded Value，在层叠过程中，赢得优先级比赛的那个值。如 1.2em defaulting:当层叠值为空时，使用继承或初始值 指定值:Specified Value，经过cascading和defaulting之后，保证指定值一定不为空 resolving:将一些相对值或者关键字转化成绝对值。如em转为px，相对路径转为绝对路径 计算值:Computed Value，一般来说是，浏览器会在不进行实际布局的情况下，所能得到的最具体的值。如60%。继承是继承的计算值） formatting:将计算值进一步转换。如关键字、百分比等都转为绝对值 使用值:Used Value，进行实际布局时使用的值，不会再有相对值或关键字。如400.2px constraining:将小数像素值转为整数 实际值:渲染时实际生效的值。如400px strong 元素font-size的求值过程12345678910111213141516171819&lt;article&gt; &lt;h1&gt;思维导图&lt;/h1&gt; &lt;p&gt;思维导图又叫&lt;strong&gt;心智导图&lt;/strong&gt;，是表达发散性思维的有效图形思维工具 ，它简单却又很有效，是一种革命性的思维工具&lt;/p&gt;&lt;/article&gt;&lt;style&gt; body&#123; color:#333;background:#f0f0f0; &#125; article&#123; font-size: 14px; line-height: 1.6; &#125; h1&#123; font-size: 2em; &#125; p&#123; font-size: 1.1em; &#125;&lt;/style&gt; 各种类型的值 关键值：font-size:inatial, box-sizing:inherit, color:red 字符串：content:”abc” URL：background-image:url(/resources/img/xiong.png) 长度：font-size:2em, height:100px, width:100px 百分比：width:50%, font-size:150% 整数：z-index:9 浮点数：line-height:1.8 颜色：color:#fff, color:rgb(0,0,100) 时间：transition-duration:0.3s 角度：transform:rorateX(deg) 函数：content:attr(title), height:calc(100vh-100px) 长度单位 绝对单位 px：像素，对应显示器的一个像素点 in：英寸 cm：厘米 mm：毫米 pt：磅（1pt=1/72英寸） pc：1pc=12pt 相对单位 em：相对于该元素的一个font-size大小的值。（常用） rem：相对于根元素root即html的font-size。（手机上用） vh：浏览器窗口高度的1%。（做全屏的布局时用） vw：浏览器窗口宽度的1%（做全屏的布局时用） vmin：vh和vw中的较小者 （手机横屏竖屏） vmax：vh和vw中的较大者 颜色 关键字：147种颜色的关键字。如red Hex：十六进制的指定方法，如#十六进制的数 RGB &amp; RGBA RGB：rgb(255,0,0)，从0到255的数值范围内。 RGBA比RGB增加了透明度。一个元素可以是半透明的，但是其中的元素不是半透明的。rgba(0,0,0,0.1),其中最后一位表示透明度，取值范围是0-1。 HSL Hue:色相是色彩的基本属性，就是平常所说的颜色的名称，如红色、黄色等。取值范围是0-360,按角度取值。一般固定 Saturation:饱和度是指色彩的纯度，值越高色彩越纯，越低则逐渐变灰。取值范围是0-100% Lightness:亮度，越高颜色越亮。取值范围是0-100%,三个数字来表示颜色。 例如：hsl(0,50%,50%,50%)、hsla(120,50%,30%,0.5)]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-浮动(3)]]></title>
    <url>%2F2018%2F06%2F13%2F%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[浮动定位模式 常规流( Normal Flow) 浮动 (Float) 绝对定位 (Absolute Positioning) 常规流 除根元素、浮动元素、绝对定位元素外，其他元素都在常规流之内(in-flow) 而根元素、浮动和绝对定位的元素会脱离常规流(out of flow) 常规流中的盒子，属于块级格式化上下文或行级格式化上下文 块级格式化上下文（Block Formatting Context） 盒子在容器(包含块)内从上到下一个接一个地放置 两个兄弟盒之间的竖直距离有margin属性决定 同一个BFC内垂直margin会合并 盒子的左外边缘挨着容器(包含块)的左边 行级格式化上下文（inline Formatting Context） 盒子一个接一个水平摆放 盒之间的水平margin，border和padding都有效 同一行的盒子所在的举行区域叫行盒(Line box) 当一个行盒放不下上下文内所有盒子时，会被分到多个垂直堆叠的行盒里 行盒内的水平分布有text-align属性决定 如果一个行级块无法分割(单词、inline-block),该元素会被作为一个整体决定分布在哪一个行盒 float 浮动元素从常规流中脱离，被漂浮在容器(包含块)左边或右边 浮动盒会一直漂到其外边缘挨到容器边缘或另外的浮动盒 浮动元素不会影响其后面的流内块级盒 但是浮动元素后面的行级盒子会变短以避开浮动元素1234567891011121314151617181920212223&lt;section&gt; &lt;img src="https://ubmcmm.baidustatic.com/media/v1/0f000csC0xlmAaJk3ffAt0.jpg" alt="house"&gt;&lt;p&gt; &lt;span&gt; 浮动元素从常规流中脱离,被漂浮在容器(包含块)左边或右边, 浮动盒会一直漂到其外边缘挨到容器边缘或另外的浮动盒, 浮动元素不会影响其后面的流内块级盒, 但是浮动元素后面的行级盒子会变短以避开浮动元素。 &lt;/span&gt;&lt;/p&gt;&lt;style&gt; img&#123; float: left; &#125; p&#123; border:1px solid red; font-size: 14px; line-height: 1.8; &#125; span&#123; border:1px solid green; &#125;&lt;/style&gt; clear 浮动元素会对后面的行级元素产生影响,clear:both可以清除浮动,使后面的块级元素永远处于浮动元素下面 指定元素那一边不能与之前的浮动框相邻 取值： left | right | both clearfix1234567.clearfix:after&#123; content:''; display:block; clear:both; height:0; overflow:hidden;&#125; 相当于在浮动元素父级后面添加了一个空div,并且cler:both 块级格式化上下文（BFC）的特性 BFC内的浮动元素不会影响到BFC外部的元素 BFC 的高度会包含其内的浮动元素 BFC 不会和浮动元素重叠 BFC 可以通过overflow:hidden等方法创建 BFC的创建 浮动框 绝对定位框 非块级的块容器(inline-block) overflow 属性非visible的块框 BFC的作用 清除浮动 防止margin折叠 双栏布局 外边距叠加 两个或多个毗邻的普通流中的块元素垂直方向上的 margin 会折叠 两个或多个:说明其数量必须是大于一个,又说明，折叠是元素与元素间相互的行为，不存在 A 和 B 折叠，B 没有和 A 折叠的现象。 毗邻:是指没有被非空内容、padding、border 或 clear 分隔开，说明其位置关系。注意：在没有被分隔开的情况下，一个元素的 margin-top 会和它普通流中的第一个子元素(非浮动元素等)的 margin-top 相邻;只有在一个元素的 height 是 “auto” 的情况下，它的 margin-bottom 才会和它普通流中的最后一个子元素(非浮动元素等)的 margin-bottom 相邻。 垂直方向:是指具体的方位，只有垂直方向的 margin 才会折叠，也就是说，水平方向的 margin 不会发生折叠的现象。 解决办法 浮动元素、inline-block元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠（注意这里指的是上下相邻的元素） 创建了BFC的元素和它的子元素不会发生margin折叠 触发BFC因素的子集(浮动元素、inline-block元素、绝对定位元素)，也就是说如果我为上下相邻的元素设置了overflow:hidden,虽然触发了BFC，但是上下元素的上下margin还是会发生折叠 可以给叠加父元素添加padding、border、clear来解决它与子元素发生margin折叠1234567891011121314151617181920212223&lt;section&gt; &lt;div&gt;hahahh&lt;/div&gt; &lt;h1&gt;this is h1&lt;/h1&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; section&#123; margin-top:10px; &#125; div&#123; /* 这里的inline-block可以,但是如果用overflow:hidden;却不可以 */ display: inline-block; margin-bottom:50px; outline: 1px solid red; &#125; h1&#123; margin-top:100px; outline: 1px solid red; &#125; &lt;/style&gt;&lt;/section&gt; 父元素添加padding、border、clear来解决它与子元素发生margin折叠1234567891011121314&lt;section&gt; &lt;div&gt;hahahh&lt;/div&gt; &lt;style&gt; section&#123; margin-top:10px; outline: 1px solid #000; border:1px solid #eee; &#125; div&#123; margin-top:50px; outline: 1px solid red; &#125; &lt;/style&gt;&lt;/section&gt;]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-文本样式(2)]]></title>
    <url>%2F2018%2F06%2F12%2F%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[css-文本样式字体注意：字体是可以向下继承的,但是所有的表单元素都是无法继承body的字体属性的， font-family 使用逗号分隔的字体族或者族类名称 初始值有浏览器设置决定,可继承 有两种类型的名称可用于分类字体： 字体族名称（family-name） 字体族名称（就是我们通常所说的“字体”）的例子包括“Arial”、“Times New Roman”、“宋体”、“黑体”等等。它们特点是代表着不同的粗细,字号大小 通用字体族（generic family） 一个通用字体族是一组具有统一外观的字体族。sans-serif就是一例，它代表一组没有“脚”的字体。 123h1&#123; font-family:Helvetica,sans-serif;&#125; 字体匹配算法 浏览器先获取一个系统字体列表 对于元素中每一个字符,使用font-family属性及其他属性进行匹配，如果能匹配就暂定改字体 如果步骤2没有匹配上，选择下一个可选的font-family执行步骤2 如果匹配到一个字体，但是字体中没有该字符，继续对下一个可选的font-family执行步骤2 如果没有匹配到字体，使用浏览器默认字体 font-family使用 英文字体放在中文字体前面 最后总是添加通用字体族 font-size 定义文字的大小,可使用px、百分比、em等做单位 取值 绝对值xx-small | x-small | small | medium | large | x-large | xx-large 相对值 larger | smaller 长度 百分数,相对于父元素计算值 初始值为medium(有浏览器设置决定，一般16px)，可继承 em 一般是相对于元素font-size的计算值 用在font-size属性上时,是相对于父元素的font-size计算值12345678910111213141516&lt;body&gt; &lt;div&gt; 哈哈 &lt;/div&gt; &lt;style&gt; body &#123; font-size: 16px; &#125; div&#123; /* 这里的1.5em等于24px */ font-size:1.5em; /* 这里的1em等于24px */ margin-left: 1em; &#125; &lt;/style&gt;&lt;/body&gt; font-style 定义文字以斜体还是正常方式显示 取值：normal | italic(字体族的斜体) | oblique(伪斜体,字体族中没有,一般算法弄斜,一般不用) 初始值为normal,可继承 font-weight 定义文字的粗细程度 取值：normal(400) | bold(700) | bolder(比继承值粗) | lighter(比继承值细) | 100 | 200 | … | 900 初始值为normal,可继承 line-height 元素所属的line box 所占高度 初始值为normal(具体值有浏览器决定),可继承 取值：&lt;长度&gt; | &lt;数字&gt; |&lt;百分比&gt;(相当于自身font-size的1.6倍) 段落文字一般取值1.4~1.8 12345678910111213141516&lt;section&gt; &lt;h1&gt;这是一个很长的标题&lt;/h1&gt; &lt;p&gt;这是正文&lt;/p&gt; &lt;/section&gt; &lt;style&gt; section&#123; width: 10em; font-size: 12px; line-height: 1.5em; &#125; h1&#123; font-size: 30px; /* 继承section中line-height的计算值为18px */ /* 相当于line-height:18px; */ &#125; &lt;/style&gt; 1234567891011121314151617&lt;section&gt; &lt;h1&gt;这是一个很长的标题&lt;/h1&gt; &lt;p&gt;这是正文&lt;/p&gt; &lt;/section&gt; &lt;style&gt; section&#123; width: 10em; font-size: 12px; /* 当line-height取值为数字的时候,子元素继承相对值 */ line-height: 1.5; &#125; h1&#123; font-size: 30px; /* 继承section中line-height的相对值1.5,等于1.5*30 */ /* 相当于line-height:45px; */ &#125; &lt;/style&gt; font缩写1234567891011&lt;h1&gt;this is Title&lt;/h1&gt;&lt;p&gt;this is Paragraph&lt;/p&gt;&lt;style&gt; h1&#123; /* 斜体 粗细 大小/行高 字体族 */ font:bold 14px/1.7 Helvetical,sans-serif &#125; p&#123; font:14px serif; &#125;&lt;/style&gt; web Fonts 字体的加载策略中我们可知，浏览器从本地把系统中安装的所有的字体列表列出来,然后一一去匹配，这时候假如我们想使用某一字体，但是不依赖用户的电脑，可以使用css3 web Font。web Font是指将字体文件放到服务器上,可以通过在css中去引用字体文件,让浏览器使用服务器上的字体,类似图片。 12345678910111213141516171819202122&lt;h1&gt; I like javscript and css &lt;/h1&gt;&lt;style&gt;@font-face&#123; /* 字体重命名 */ font-family: 'Lobster'; font-style:normal; font-weight: 400; src:local('Lobster'), /* 本地字体 */ local('Lobster-Regular'), /* 服务器上的字体 */ url(http://lib.baomitu.com/fonts/lobster/lobster-v18-latin-regular.woff2) /* 不同的浏览器对于web Font的支持度不一样,所以需要不同的字体格式 */ /*format： 字体的格式，主要用于浏览器识别等。 */ format('woff2'), url(http://lib.baomitu.com/fonts/lobster/lobster-v18-latin-regular.woff) format('woff');&#125;h1&#123; font-family: 'Lobster',cursive;&#125;&lt;/style&gt; 中文web Font 因为中文汉字的数量过多,如果中文也想使用字体的话，加载文件会超级大,解决办法是：将一些常用的字体进行裁剪，使用部分字体,可以减少字体库的大小 字体库CDN Google Fonts 75CDN font Spider text-align 定义文本在容器内的对齐方式 取值：left | right | center | justify 初始值有HTML的dir属性决定,可继承 dir文字从左到右还是从右到左的书写顺序text-align:justify最后一行不会两端对齐,所以当只有一行文字的时候,text-align:justify不起作用 letter-spacing 指定字符之间的间距 取值： normal | &lt; length &gt; 初始值为normal,可继承1234567&lt;h1&gt; Letter Spacing 字符间距&lt;/h1&gt;&lt;style&gt; h1&#123; /* 字体大小20%的字体间距 */ letter-spacing: 0.2rem; &#125;&lt;/style&gt; word-spcing 指定单词之间的间距 取值： normal | &lt; length &gt; 初始值为normal,可继承1234567&lt;h1&gt; word Spacing 字符间距&lt;/h1&gt;&lt;style&gt; h1&#123; /* 中文不能识别,因为不知道那个是单词 */ word-spacing: 0.2rem; &#125;&lt;/style&gt; text-indent 指定文本缩进 取值： normal | &lt;长度&gt; | &lt;百分比&gt; 初始值为0,可继承123p&#123; text-indent:2em;&#125; text-decoration 定义了文本的一些装饰效果，比如下划线、删除线等 初始值为none,可继承 其他值：underline | line-through | overline white-space html中的连续空格会合并成一个空格，遇到换行符时不换行,自动换行 指定空白符如何处理 取值：normal | nowrap(不换行) | pre(html怎么显示它就怎么显示) word-break 指定是否允许在单词中间换行 取值 normal | break-all(在所有的单词会折行) | keep-all(对于能放下的单词正常折行,对于长单词才折行)]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css概念与简单选择器(1)]]></title>
    <url>%2F2018%2F06%2F12%2Fcss%2F</url>
    <content type="text"><![CDATA[css概念与简单选择器css规则 代码风格1h1&#123;color:red;font-size:14px;&#125; 1234h1&#123; color:red; font-size:14px;&#125; 使用css123&lt;!-- 外链 --&gt;&lt;!-- rel 关系意思的缩写 --&gt;&lt;link rel='stylesheet' href="/path/t0/style.css"/&gt; 12345678910&lt;!-- 嵌入 --&gt;&lt;style&gt;li&#123; margin:0; list-style:none;&#125;p&#123; margin:1em 0;&#125;&lt;/style&gt; 12&lt;!-- 内联 --&gt;&lt;p style="margin:1em 0"&gt;你好&lt;/p&gt; 注释12345678910111213/* 设置按钮宽度 */.form button&#123; width:240px;&#125;/***设置默认样式*/body&#123; margin:0; /* font-size:12px; */ /* 原理是把//color整体当作属性去解析 */ //color:#333;&#125; 简单选择器 选择器用来从页面中选择元素，以给他们定义样式 通配选择器1234/* 匹配所有元素 */*&#123; box-sizing:inherit;&#125; 标签选择器1234/* 匹配所有p元素 */p&#123; margin:1em 0;&#125; id 选择器123456789101112&lt;p id="example"&gt;Hello world&lt;/p&gt;&lt;style type="text/css"&gt;/***匹配id为example的元素*注意：id值在一个HTML中必须唯一*/#example&#123; font-size:14px;&#125;&lt;/style&gt; 类选择器1234567891011&lt;!-- 可以给一个元素指定多个class,用空格隔开 --&gt;&lt;p class="warning icon"&gt;警告信息&lt;/p&gt;&lt;style type="text/css"&gt;.warning&#123; font-size:14px;&#125;.icon&#123; background:#f00;&#125;&lt;/style&gt; 属性选择器拥有某个属性123456789&lt;input name="username" value="zhao" disabled&gt;&lt;style&gt;input[disabled]&#123; background:#eee; /* 光标禁用 */ cursor:not-allowed;&#125;&lt;style&gt; 某个属性的值是password1234567&lt;input name="password" value=""&gt;&lt;style&gt;input[type="password"]&#123; background:red;&#125;&lt;style&gt; 属性的值包含height1234567891011121314151617181920212223242526 &lt;p&gt; &lt;label&gt; height: &lt;/label&gt; &lt;input type="text"&gt;22&lt;/input&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt; weight: &lt;/label&gt; &lt;input type="text"&gt;22&lt;/input&gt; &lt;/p&gt;&lt;p&gt; &lt;label&gt; BMI: &lt;/label&gt; &lt;!-- output与input对应，output是数据的展示，for属性代表值是从哪里获取的 --&gt; &lt;output for="weight height"&gt;22&lt;/output&gt; &lt;/p&gt;&lt;style&gt; [for~="height"]&#123; color:red; &#125;&lt;/style&gt; 属性的值以什么字段开头和结尾123456&lt;p&gt;&lt;a href="#top"&gt;回到顶部&lt;/a&gt;&lt;/p&gt;&lt;style&gt;a[href^="#"]&#123; color:red;&#125;&lt;/style&gt; 123456&lt;p&gt;你可以&lt;a href="a.jpg"&gt;查看原图&lt;/a&gt;&lt;/p&gt; &lt;style&gt; a[href$='.jpg']&#123; color:red; &#125; &lt;/style&gt; 属性的值在任意位置都可以用*123456&lt;i class="icon-user"&gt;用户&lt;/i&gt;&lt;style&gt; [class*="icon-"]&#123; color:coral; &#125;&lt;/style&gt; 伪类选择器基于DOM之外的信息去(比如根据用户和网页的交互状态)选择元素12345678910&lt;!-- 未访问过的连接 --&gt;a:link &#123; ... &#125; &lt;!-- 已访问过的连接 --&gt;a:visited &#123; ... &#125; &lt;!-- 鼠标移到连接上的样式 --&gt;a:hover &#123; ... &#125;&lt;!-- 鼠标在连接上按下时的样式 --&gt;a:active &#123; ... &#125;&lt;!-- 获得焦点时的样式 --&gt;a:focus &#123; ... &#125; 选择器组合直接组合 EF123456789&lt;p class="warning"&gt;警告&lt;/p&gt;&lt;div class="warning icon"&gt;警告2&lt;/div&gt;&lt;style&gt; p.warning&#123; color:orange; &#125;&lt;/style&gt; 组合形式(标签选择器在前) E[for=”bar”] E.warning E#myid #myid.warning .warning[foo=”bar”] 后代组合 E F12345678910111213&lt;article&gt; &lt;h1&gt;你好吗？&lt;/h1&gt;&lt;/article&gt;&lt;style&gt; /* 后代选择器 */ article p&#123; color:coral &#125; /* 亲子选择器 (直接子集)*/ article &gt; p&#123; color:aliceblue &#125;&lt;/style&gt; 同时为一组选择器定义样式 E,F,B1234body,h1,h2,h3&#123; margin:0; padding:0;&#125;]]></content>
      <tags>
        <tag>前端基础</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信直播]]></title>
    <url>%2F2018%2F06%2F12%2F%E5%BE%AE%E4%BF%A1%E7%9B%B4%E6%92%AD%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[小程序]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[小程序开发环境搭建 后台地址 文档地址 开发工具下载 小程序入门文件结构 App.json配置文件 wxml模板+wxss样式 js页面渲染，数据驱动页面 app.js 项目全局的入口 生命周期 全局getApp函数获取实例 全局唯一 app.json 项目全局的配置 pages window tabbar wxml+wxss 类html+css wxml类似html,数据驱动 wxss样式,新增单位rpx(宽度750rpx满屏,自适应) 配置文件,覆盖app.json里面的window比如修改title js 自带数据驱动功能 { {显示数据} } setData,数据驱动不用深究,可以用vue语法开发(mpvue) 自带组件和api api 框架提供很多api,方便调用微信原生的能力 wx.request发送请求 wx.previewImage预览图片 wx.setStorage本地存储 Location地理位置 scanCode扫码 showToast显示提示信息 获取导航条 获取用户信息 页面导航navigateTo,redirectTo,switchTab 动画、震动、截屏、亮度 音乐、视频、地图、文件 加速计、罗盘、wifi、nfc等等 组件 提供了一些基础组件，也可以自定义组件 视图 表单 媒体 原生小程序的缺点 不能使用npm，使用第三方包的方式太原始 需要为小程序单独开发代码，不能和web系统重用 开发效率和学习成本（小程序特有的语法） mpvue因为原生的小程序开发复杂,所以我们引用了mpvue(基于Vue.js的小程序开发框架.从底层支持 Vue.js 语法和构建工具体系) 使用vue开发小程序 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中 开源即热门 mpvue是什么使用vue语法开发，编译为小程序语法 一套vue程序h5+小程序 Vue组件规范，熟悉vuejs即可开发小程序 比wepy工具对vue语法支持度更高 mpvue的优点 彻底的Vue组件化开发能力：提高代码复用性 完整的vue开发体验 彻底的Vue组件化开发能力：提高代码复用性 快捷的 webpack 构建机制：开发阶段 hotReload 支持npm安装依赖 使用 Vue.js 命令行工具 vue-cli 快速初始化项目 H5 代码转换编译成小程序目标代码的能力 mpvue工作原理 mpvue对比 mpvue步骤 12vue init mpvue/mpvue-quickstart my-project npm run dev 模板语法，计算属性，条件列表渲染， vue语法+小程序自带组件+小程序api 目录结构 生命周期 vue生命周期+兼容小程序生命周期 Created 创建初始化 Vue不支持的 用小程序自己的 比如onPullDownRefresh 模板语法 computed+模板+熟悉的html 动态style和class 使用计算属性返回字符串 V-if和v-for用法不变 表单v-model全支持 事件处理 bind换成@ 使用vue的绑定语法 模板 除了动态渲染，别的都支持 .vue单文件组件 小程序自带组件也可以用 自带组件事件绑定也使用vue的，比如@click 小程序腾讯云后台小程序后台要求 购买域名+机器 购买https证书 使用pm2+nginx自己部署 腾讯小程序解决方案 Koa2+mysql+wafer-sdk（腾讯小程序解决方案） 集成微信开发工具一键上传部署 调试免费域名+环境(测试环境不要钱) 开通步骤 注册腾讯云 进入管理后台 下载nodejs demo，熟悉开发工具 开发设置 Project.config.json Npm install wafer2-client-sdk –save 腾讯云解决方案sdk 全局和局部样式 本地开发环境 本地安装mysql 指南 获取密钥和appid 配置server的config npm install –g nodemon 指node tools/initDb.js(记得mysql新建数据库) npm run dev 项目目录: https://github.com/zhangyapeng0222/weixin]]></content>
      <tags>
        <tag>node</tag>
        <tag>小程序</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6快速预览]]></title>
    <url>%2F2018%2F05%2F31%2Fes6%E5%BF%AB%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[es6快速预览let&amp;&amp;constvar的问题: var没有作用域 var不能定义常量 var可以重复定义因为这些问题,es6引入了let和const来解决它们。es6之前js的作用域只有函数作用域和全局作用域。 let块级作用域 1234if(true)&#123; let name='zyp'&#125;console.log(name)// ReferenceError: name is not defined 不能提升作用域 12345let name='zhangyapeng'if(true)&#123; console.log(name))// ReferenceError: name is not defined let name='haha'&#125; 不会污染全局变量 1234if(true)&#123; let name = 'zfpx';&#125;console.log(window.name);//undefined 闭包实现 1234567891011121314151617//es5"use strict";var _loop = function _loop(i) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000);&#125;;for (var i = 0; i &lt; 2; i++) &#123; _loop(i);&#125;//es6 的实现for(let i=0;i&lt;2;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,1000)&#125; const 定义常量，常量一旦定义就不能修改 定义值类型 12const a=1;a=2;//Assignment to constant variable 定义引用类型 123const a=[1,2,3]a=[2,3,4]//Assignment to constant variablea[0]=9//a=[9,2,3] 解构解构的意思就是分解一个对象,解构的时候，等号两边结构类似，右边还必须时以这真实的值。 解构数组 12let [name,age]=['zyp','18']console.log(name,age)//zyp,18 嵌套赋值 12let [x, [y], z] = [1, [2.1, 2.2]];console.log(x, y, z);//1,2.1,undefined 省略赋值 12let [, , x] = [1, 2, 3];console.log(x); 默认值(赋值和传参的时候可以使用默认值) 12let [a = "a", b = "b", c =new Error('C必须指定')] = [1, , 3];console.log(a, b, c);//"a","b",3 字符串模板字符串 模板字符串用反引号包含,其中的变量用${}括起来 12let name='zyp',age=18let dec=`$&#123;name&#125;is $&#123;age&#125;old!` 数组循环 12345678910111213141516171819202122/** * 实现 * &lt;ul&gt; * &lt;li&gt;zhangyapeng&lt;/li&gt; * &lt;li&gt;zuhong&lt;/li&gt; * &lt;/ul&gt;*/let arr= [&#123;name:"zhangyapeng"&#125;,&#123;name:"zuhong"&#125;]//map 映射，把老数组的每一个元素映射为新数组的每一个元素let newList=arr.map((user,index)=&gt;&#123; return ( ` &lt;li&gt;$&#123;user.name&#125;&lt;/li&gt; ` )&#125;).join('')let ul=( ` &lt;ul&gt;$&#123;newList&#125;&lt;/ul&gt; `) 自己实现模板引擎 12345678let name='zyp',age=18let dec="$&#123;name&#125;is $&#123;age&#125;old!"//replace函数function replace(dec)&#123;return dec.replace(/\$\&#123;([^&#125;]+)\&#125;/g,function(matched,key)&#123;return eval(key)&#125;)&#125; 带标签的模板字符串 12345var name = 'zyp',age = 18;function desc(strings,...values)&#123; console.log(strings,values);&#125;desc`$&#123;name&#125; is $&#123;age&#125; old!`; 可以在模板字符串的前面添加一个标签，这个标签可以去处理模板字符串,标签其实就是一个函数,因为我们有些时候希望有自己的拼接字符串逻辑,才有了这个标签的模板字符串.rest运算符,会把后面的所有参数全都放在一个数组里,rest其他运算符只能作为最后一个参数 API includes():返回布尔值，表示是否找到了参数字符串 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 repeat:返回一个新字符串，表示将原字符串重复n次12345678let s="https://www.baidu.com"s.includes("https")//trues.startsWith("https")//trues.endsWith("https")//true//还支持第二个参数，表示开始搜索的位置,endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束s.endsWith('p',4)//true//重复"x".repeat(3) 函数]]></content>
      <tags>
        <tag>es6</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp插件]]></title>
    <url>%2F2018%2F05%2F30%2Fgulp%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[gulp插件gulp-babeles5转成es612345678910const gulp = require('gulp');const babel = require('gulp-babel');gulp.task('default', () =&gt; gulp.src('src/app.js') .pipe(babel(&#123; presets: ['@babel/env'] &#125;)) .pipe(gulp.dest('dist'))); gulp-rev-appendgulp-rev-append给页面的引用添加版本号，清除页面引用缓存。通过正则(?:href|src)=”(.)[?]rev=(.)[“]查找并给指定链接填加版本号(默认根据文件MD5生成，因此文件未发生改变，此版本号将不会变)12345678910111213&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;link rel="stylesheet" href="css/style.css?rev=@@hash"&gt; &lt;script src="js/js-one.js?rev=@@hash"&gt;&lt;/script&gt; &lt;script src="js/js-two.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;hello, world!&lt;/div&gt; &lt;img src="img/test.jpg?rev=@@hash" alt="" /&gt; &lt;script src="js/js-three.js?rev=@@hash"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12345678var gulp = require('gulp'), rev = require('gulp-rev-append'); gulp.task('testRev', function () &#123; gulp.src('src/html/index.html') .pipe(rev()) .pipe(gulp.dest('dist/html'));&#125;); del在 gulpfile 中，我们希望在运行我们的编译任务之前，将 mobile 文件的内容先清理掉：123456789101112131415var gulp = require('gulp');var del = require('del');gulp.task('clean:mobile', function () &#123;//del时Promise return del([ 'dist/report.csv', // 这里我们使用一个通配模式来匹配 `mobile` 文件夹中的所有东西 'dist/mobile/**/*', // 我们不希望删掉这个文件，所以我们取反这个匹配模式 '!dist/mobile/deploy.json' ]);&#125;);gulp.task('default', ['clean:mobile']); gulp-load-plugins这个插件能自动帮你加载package.json文件里的gulp插件。 例如假设你的package.json文件里的依赖是这样的:12345"devDependencies": &#123; "gulp": "^3.9.0", "gulp-concat": "^2.6.0", "gulp-connect": "^2.2.0" &#125; 然后我们可以在gulpfile.js中使用gulp-load-plugins来帮我们加载插件12var gulp = require('gulp');var $ = require('gulp-load-plugins')(); 然后我们要使用gulp-concat和gulp-connect这两个插件的时候， 就可以使用$.concat和$.connect来代替了,也就是原始插件名去掉gulp-前缀，之后再转换为驼峰命名 gulp-concat这个插件可以把几个文件合并到一块12345678910var gulp = require('gulp');var concat = require('gulp-concat');gulp.task('concat',function()&#123; return gulp.src(['app/js/*.js','!app/js/*.tmp.js'])//指定要合并的文件glob .pipe(concat('app.js'))//进行合并并指定合并后的文件名 .pipe(gulp.dest('dist/js'));//输出到目标路径&#125;);gulp.task('default',['concat']); gulp-uglify合并后我们可以对JS文件进行压缩,最小化处理123456789101112var gulp = require('gulp');var concat = require('gulp-concat');var uglify = require('gulp-uglify')gulp.task('uglify',function()&#123; return gulp.src(['app/js/*.js','!app/js/*.tmp.js']) .pipe(concat('app.js')) //把多个JS文件合并成一个文件 .pipe(uglify()) //对合并后的app.js文件进行压缩 .pipe(gulp.dest('dist/js')); //输出到目的地&#125;);gulp.task('default',['uglify']); gulp-rename在把处理好的文件存放到指定的位置之前，我们可以先去重新命名一下它1234567891011121314var gulp = require('gulp');var concat = require('gulp-concat');var uglify = require('gulp-uglify');var rename = require('gulp-rename');gulp.task('uglify',function()&#123; return gulp.src(['app/js/*.js','!app/js/*.tmp.js'])//指定要处理的文件 .pipe(concat('app.js'))//合并成一个文件 .pipe(gulp.dest('dist/js'))//保存此文件 .pipe(uglify())//进行压缩 .pipe(rename('app.min.js'))//对此文件进行重命名 .pipe(gulp.dest('dist/js'));//再输出一次&#125;);gulp.task('default',['uglify']); gulp-minify-css压缩css1234567891011121314var gulp = require('gulp');var less = require('gulp-less');var minify = require('gulp-minify-css');//在文件的顶部去包含这个插件，起个名字，叫做 minifyvar rename = require('gulp-rename');gulp.task('minify',function()&#123; return gulp.src('app/less/page.less')//指定 less文件 .pipe(less())//把less编译成css .pipe(gulp.dest('dist/css'))//输出到目的地 .pipe(minify())//对 css再进行压缩 .pipe(rename('page.min.css'))//重命名 .pipe(gulp.dest('dist/css'));//输出到目的地&#125;);gulp.task('default',['less']); gulp-minify-html压缩html12345678var gulp = require('gulp'), minifyHtml = require("gulp-minify-html");gulp.task('minify-html', function () &#123; gulp.src('src/*.html') // 要压缩的html文件 .pipe(minifyHtml()) //压缩 .pipe(gulp.dest('dist/html'));//输出到目的地&#125;); gulp-imagemin如果要想在保证不改变图像质量的情况下，让图像文件的体积变得更小一点,我们可以使用gulp-imagemin12345678910var gulp = require('gulp');var imagemin = require('gulp-imagemin');gulp.task('copy-images',function()&#123; return gulp.src('app/imgs/**/*.&#123;jpg,png&#125;')//指定要压缩的图片 .pipe(imagemin()) //进行图片压缩 .pipe(gulp.dest('dist'));//输出目的地&#125;);gulp.task('default',['copy-images']); gulp-connect有些时候我们需要把文件放到本地服务器上去预览，gulp-connect可以帮我们创建一个本地服务器去运行我们的项目1234567891011var gulp = require('gulp');var connect = require('gulp-connect');gulp.task('server',function()&#123; connect.server(&#123; root:'dist',//服务器的根目录 port:8080 //服务器的地址，没有此配置项默认也是 8080 &#125;);&#125;);gulp.task('default',['server']); //运行此任务的时候会在8080上启动服务器 自动刷新我们希望当文件变化的时候浏览器可以自动刷新，这样我们就不需要文件修改后手动去刷新浏览器了123456789101112131415161718192021var gulp = require('gulp');var connect = require('gulp-connect');gulp.task('copy-html',function()&#123;gulp.src('app/index.html')//指定源文件 .pipe(gulp.dest('dist'))//拷贝到dist目录 .pipe(connect.reload());//通知浏览器重启&#125;);gulp.task('watch',function()&#123;gulp.watch('app/index.html',['copy-html']);//当index.html文件变化时执行copy-html任务&#125;);gulp.task('server',function()&#123;connect.server(&#123;root:'dist',//服务器的根目录port:8080, //服务器的地址，没有此配置项默认也是 8080livereload:true//启用实时刷新的功能&#125;);&#125;);gulp.task('default',['server','watch']);//运行此任务的时候会在8080上启动服务器， jshint可以用此插件进行代码检查,注意必须同时安装jshint和gulp-jshint 全部选项12345678var gulp = require('gulp'), jshint = require("gulp-jshint");gulp.task('jsLint', function () &#123; gulp.src('src/*.js') .pipe(jshint()) //进行代码检查 .pipe(jshint.reporter()); // 输出检查结果&#125;); sass的编译12345678var gulp = require('gulp'), sass = require("gulp-sass"); gulp.task('compile-sass', function () &#123; gulp.src('sass/*.sass') .pipe(sass()) .pipe(gulp.dest('dist/css'));&#125;); 自定义插件gulp.src()中这个流里的内容不是原始的文件流,而是一个虚拟文件对象流,这个虚拟文件对象中存储着原始文件的路径、文件名和内容等信息 vinyl123456789101112var File = require('vinyl');var indexFile = new File(&#123; cwd: "/",//当前路径 base: "/test/",//文件名 path: "/test/index.js",//路径 contents: new Buffer("name=zfpx")//文件内容&#125;);console.log(File.isVinyl(indexFile));//是否是vinylconsole.log(indexFile.isBuffer());//内容是否是Bufferconsole.log(indexFile.isStream());//内容是否是Stream through2through2：Node Stream的简单封装，目的是让链式流操作更加简单二进制流的方式123456789101112131415var through2 = require('through2');var fs = require('fs');fs.createReadStream('src.txt',&#123;highWaterMark:1&#125;) .pipe(through2(function (chunk, encoding, callback) &#123; for (var i = 0; i &lt; chunk.length; i++) chunk[i] = chunk[i] + 1; this.push(chunk); //向流中写数据,每push一次就发射一次data事件 callback(); &#125;)).on('data', function (data) &#123; console.log(data.toString()); &#125;).on('end', function (data) &#123; console.log('end');&#125;)//.pipe(fs.createWriteStream('dest.txt')) 对象方式1234567891011121314151617var through2 = require('through2');var fs = require('fs');var all = [];fs.createReadStream('src.txt', &#123;highWaterMark: 1&#125;).pipe(through2.obj(function (chunk, enc, callback) &#123; var data = &#123; name: chunk.toString() &#125; this.push(data); callback();&#125;)).on('data', function (data) &#123; console.log(data)&#125;).on('end', function () &#123; console.log('end')&#125;) 插件入门1234567891011121314151617181920212223242526module.exports = function (options) &#123; return through.obj(function (file, enc, cb) &#123; //file对象就是虚拟文件流 // 如果文件为空，不做任何操作，转入下一个操作，即下一个 .pipe() if (file.isNull()) &#123; this.push(file); return cb(); &#125; // 插件不支持对 Stream 对直接操作，跑出异常 if (file.isStream()) &#123; this.emit('error', new gutil.PluginError(PLUGIN_NAME, 'Streaming not supported')); return cb(); &#125; // 将文件内容转成字符串，并调用 preprocess 组件进行预处理 // 然后将处理后的字符串，再转成Buffer形式 var content = pp.preprocess(file.contents.toString(), options || &#123;&#125;); file.contents = new Buffer(content); // 下面这两句基本是标配啦，可以参考下 through2 的API this.push(file); cb(); &#125;);&#125;; 参考文档： 插件编写入门 代码]]></content>
      <tags>
        <tag>gulp</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp]]></title>
    <url>%2F2018%2F05%2F29%2Fgulp%2F</url>
    <content type="text"><![CDATA[gulp是一个前端构建工具,它通过nodejs中的stream来读取和操作数据，速度奇快。 gulp和grunt的区别Grunt主要是以文件为媒介来运行它的工作流的，比如在Grunt中执行完一项任务后，会把结果写入到一个临时文件中，然后可以在这个临时文件内容的基础上执行其它任务，执行完成后又把结果写入到临时文件中，然后又以这个为基础继续执行其它任务…就这样反复下去。而在Gulp中，使用的是Nodejs中的stream(流)，首先获取到需要的stream，然后可以通过stream的pipe()方法把流导入到你想要的地方，比如Gulp的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。所以Gulp是以stream为媒介的，它不需要频繁的生成临时文件，这也是Gulp的速度比Grunt快的一个原因。 gulp的安装 先安装node,然后全局安装gulp 1npm install -g gulp 安装局部gulp 1npm i gulp -D 在项目根目录下建立gulpfile.js文件 12345var gulp = require('gulp');gulp.task('default', function() &#123; // 将你的默认的任务代码放在这&#125;); 运行gulp 1gulp gulp的工作流程gulp的使用流程一般是 首先通过gulp.src()方法获取到想要处理的文件流 然后把文件流通过pipe方法导入到gulp的插件中 最后把经过插件处理后的流再通过pipe方法导入gulp.dest()中 gulp.dest()方法则把流中的内容写入文件中123var gulp = require('gulp');gulp.src('script/src.js') // 获取文件的流的api.pipe(gulp.dest('dist/dest.js')); // 写文件的api gulp的API对于gulp我们只需要知道4个api即可,gulp.task()、gulp.src()、gulp.dest()、gulp.watch()其他的可以参考文档 gulp.src()gulp.src()方法正是用来获取流的,它可以将匹配的文件转成流,但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流(Vinyl files)。这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息1gulp.src(globs[, options]) globs参数是文件匹配模式(类似正则表达式),用来匹配文件路径，当多个路径时，可以为数组 options为可选参数。通常情况下我们不需要用到。 gulp匹配规则时node-glob,可以了解。 gulp.dest()gulp.dest()方法是用来写文件的，其语法为：1gulp.dest(path[,options]) path写入文件的路径 options为可选参数。通常情况下我们不需要用到。 gulp.dest()传入的路径参数只能用来指定要生成的文件的目录,而不能指定生成文件的文件名 123// 最终生成的文件路径为 dist/jquery.js/jquery.js,而不是dist/jquery.jsvar gulp = require('gulp');gulp.src('script/jquery.js').pipe(gulp.dest('dist/jquery.js')); 注意：gulp.dest(path)生成的文件路径是我们传入的path参数后面再加上gulp.src()中有通配符开始出现的那部分路径通过指定gulp.src()方法配置参数中的base属性，我们可以更灵活的来改变gulp.dest()生成的文件路径1234//配置了base参数，此时base路径为script//假设匹配到的文件为script/lib/jquery.js//此时生成的文件路径为 build/lib/jquery.jsgulp.src('script/lib/*.js', &#123;base:'script'&#125;).pipe(gulp.dest('build')) gulp.task()gulp.task方法用来定义任务，内部使用的是Orchestrator，其语法为 12gulp.task(name[, deps], fn) name 为任务名 deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数 fn 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。 1234gulp.task('mytask', ['array', 'of', 'task', 'names'], function() &#123; //定义一个有依赖的任务 // Do something &#125;); 如果某个任务所依赖的任务是异步的，就要注意了，gulp并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务 1234567891011gulp.task('one',function()&#123; //one是一个异步执行的任务 setTimeout(function()&#123; console.log('one is done') &#125;,5000);&#125;);//two任务虽然依赖于one任务,但并不会等到one任务中的异步操作完成后再执行gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); 有三种方法解决： 回调函数来通知gulp这个异步任务已经完成,这个回调函数就是任务函数的第一个参数 123456789101112gulp.task('one',function(cb)&#123; //cb为任务函数提供的回调，用来通知任务已经完成 //one是一个异步执行的任务 setTimeout(function()&#123; console.log('one is done'); cb(); //执行回调，表示这个异步任务已经完成 &#125;,5000);&#125;);//这时two任务会在one任务中的异步操作完成后再执行gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); 定义任务时返回一个流对象。适用于任务就是操作gulp.src获取到的流的情况 12345678910gulp.task('one',function(cb)&#123; var stream = gulp.src('client/**/*.js') .pipe(dosomething()) //dosomething()中有某些异步操作 .pipe(gulp.dest('build')); return stream;&#125;);gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); 返回一个promise对象 1234567891011gulp.task('one',function()&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(function() &#123; resolve(); &#125;, 5000); &#125;)&#125;);gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); gulp.watch() gulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为 1gulp.watch(glob[, opts], tasks) glob 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。 opts 为一个可选的配置对象，通常不需要用到 tasks 为文件变化后要执行的任务，为一个数组 1234567gulp.task('uglify',function()&#123; //do something&#125;);gulp.task('reload',function()&#123; //do something&#125;);gulp.watch('js/**/*.js', ['uglify','reload']); gulp.watch()还有另外一种使用方式 1gulp.watch(glob[, opts, cb]) glob和opts参数与第一种用法相同 cb参数为一个函数。每当监视的文件发生变化时，就会调用这个函数,并且会给它传入一个对象，该对象包含了文件变化的一些信息，type属性为变化的类型，可以是added,changed,deleted；path属性为发生变化的文件的路径1234gulp.watch('js/**/*.js', function(event)&#123; console.log(event.type); //变化类型 added为新增,deleted为删除，changed为改变 console.log(event.path); //变化的文件的路径&#125;); 参考链接： gulp官网 前端构建工具gulpjs的使用介绍及技巧 gulp文档]]></content>
      <tags>
        <tag>gulp</tag>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npx:一个npm包执行器]]></title>
    <url>%2F2018%2F05%2F25%2Fnpx%2F</url>
    <content type="text"><![CDATA[最近小编在使用node的时候，发现了一个神器—npx,它只有在npm 5.2.0才有的欧 npx是什么？根据zkat/npx的描述,你就会发现它的神奇之处,npx可以帮你执行依赖包里面的二进制文件。 举个栗子： 举例来说，之前我们可能会写这样的命令： 12npm i -D webpack./node_modules/.bin/webpack -v 如果你对 bash 比较熟，可能会写成这样12npm i -D webpack`npm bin`/webpack -v 有了 npx，你只需要这样12npm i -D webpacknpx webpack -v 也就是说 npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装！ npx 甚至支持运行远程仓库的可执行文件，如12345678910npx github:piuccio/cowsay hellonpx: 1 安装成功，用时 1.663 秒 _______&lt; hello &gt; ------- \ ^__^ \ (oo)\_______ (__)\ )\/\ ||----w | || || 再比如 npx http-server 可以一句话帮你开启一个静态服务器！（第一次运行会稍微慢一些）npx 还允许我们单次执行命令而不需要安装；在某些场景下有可能我们安装了某个全局命令行工具之后一直忘了更新，导致以后使用的时候误用了老版本。而使用 npx create-react-app my-cool-new-app 来执行 create-react-app 命令时，它会正常地帮我们创建 React 应用而不会实际安装 create-react-app 命令行。1234567$ npx http-servernpx: 23 安装成功，用时 48.633 秒Starting up http-server, serving ./Available on: http://127.0.0.1:8080 http://192.168.5.14:8080Hit CTRL-C to stop the server]]></content>
      <tags>
        <tag>node</tag>
        <tag>npx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号]]></title>
    <url>%2F2018%2F05%2F25%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[微信公众号开发微信号的分类 企业号 不太适合与我们这种个人小型开发,是企业或组织提供移动应用入口，帮助企业建立与员工、上下游供应链及企业应用间的联系 订阅号 比较适合与个人、小团队，主要是用于信息传播，帮助管理用户以及和用户互动。比如撰写文章，咨询传播，消息定制等等 服务号 企业和组织，提供更强大的业务服务与用户管理能力，比如支付，智能接口 举个栗子 公众号 描述 订阅号 管理一个班级，一个学院的信息订阅，通知和互动 服务号 管理全学校的水果商店或者打印店,可以直接支付送货上门,及时推送一些特价水果 企业号 管理全学校所有学院，团委，学生处各个部门上班人员的考勤，活动进程等,例如OA系统 公众号的权限 公众号分为非认证和认证,认证的一般是需要你有一个开户过的企业 订阅号和服务号三点不同 出现位置不同 单月发送消息数量不同，订阅号可以一天1篇，服务号一个月最多4篇 订阅号没有9大接口和支付功能 服务号的9大接口 语音识别 客服接口 OAuth2.0网页授权 生成带参数二维码 获取用户地理位置 获取用户基本信息 获取关注者列表 用户分组接口 上传下载多媒体文件 订阅号的5大接口 会话界面的自定义菜单 多客服接口，提供贴心快捷的客服服务 获取用户地址位置，精确提供服务 高级群发接口，实现更灵活的群发功能 用户分组接口，方便管理用户 微信的交互流程 开发必备代理服务器的使用 使用localtunnel这个npm模块 需要支付6元的花生壳内网映射 免费的natpp内网映射 配置接入微信公众号 测试号的配置 验证公众号 将token、timestamp、nonce三个参数进行字典序排序 将三个参数字符串拼成一个字符串进行sha1加密 将加密后的字符串与signature对比，如果相同，表示这个请求来源与微信，我们直接原样返会echostr参数内容，接入验证成功了 获取access_token(全局票据) access_token每2个小时自动失效，需要重新获取 只更新了access_token，之前的那个就不能用了 微信js-SDK微信公众号引入网页的步骤 绑定域名 引入js文件 JS SDK初始化SDK与公众号的区别 公众号 是微信这个原生的应用中，开放的特殊账号，让很多人可以通过原生的聊天界面，与公众号互动，其实就是我们与服务器互动 微信的SDK 不是公众号中使用的，而是在微信内置的浏览器中使用的 SDK的作用形象的说：搭建了一座桥，使我们可以在微信内置的浏览器的网页中调用微信的原生应用，以及实现拍照、语音、及扫一扫等功能 SDK接口列表 基础接口 判断当前微信客户端版本是否支持指定js接口,有了这个判断，你就可以大胆的在网页中使用 温馨提示：即便是这个网页不在微信的浏览器中打开比如在电脑的浏览器打开，可以保证一些基础功能的可用性，只需要关掉跟微信 有关的功能就行，可以让这个网页不可访问，替换成一个二维码让用户来扫，也可以进入微信的环境中，算是一个折衷的方案 分享接口 图像接口 音频接口 智能接口 设备接口 地理位置 摇一摇周边 界面操作 微信扫一扫 小店 卡劵 支付 获取jsapi_ticket 参考文档与资料：微信公众号:https://mp.weixin.qq.com/wiki微信SDK:https://mp.weixin.qq.com/wikigithub项目参考:https://github.com/zhangyapeng0222/weixin]]></content>
      <tags>
        <tag>node</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo建站指南]]></title>
    <url>%2F2018%2F05%2F21%2Fhexo%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[简介hexo是一个快速、简洁且高效的静态站点生成框架，它基于 Node.js 。 它有许多的主题框架,小编选择的时Next。文档讲解的非常详细,小编就不在这里为大家介绍文档了，就写一些小编出错和注意的点。 安装安装 Hexo 只需几分钟时间，可以参考官网，若你在安装过程中遇到问题或无法找到解决方式，请留言，我会尽力解决你的问题。 安装前提 Git node 如果你的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装 安装步骤 安装hexo-cli 1npm install -g hexo-cli 安装完成后在指定的目录下执行hexo初始化 1hexo init 生成静态文件 1hexo g 启动本地静态服务器 1hexo s 发布项目 1hexo d 常见问题 - 图标显示Hexo 中的图标使用的是 Font Awesome ,所以，我们的博客已经自带了 Font Awesome 中的所有图标，基本可以满足我们的所有需求，我们可以去 Font Awesome 中查找我们想要使用的图标。123&lt;i class="fa fa-github"&gt;&lt;/i&gt;&lt;i class="fa fa-github fa-lg"&gt;&lt;/i&gt;&lt;i class="fa fa-github fa-2x"&gt;&lt;/i&gt; 常见问题 - 代码压缩优化在项目的根目录下，执行以下命令： 12cnpm install gulp -gcnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp --save-dev 然后在 gulpfile.js 里面写上相关代码，详情查看 源码 。 然后执行 gulp min 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 鼠标右键 -&gt; 查看网页源代码，可以看到已经是压缩过的。 常见问题 - 字数统计、阅读时长Next主题已经集成了字数统计、阅读时长,我们只需要在主题配置文件_config.yml中打开wordcount统计功能即可12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true # 单篇 字数统计 min2read: true # 单篇 阅读时长 totalcount: false # 网站 字数统计 separated_meta: true 如果还出现字数统计和阅读时长失效的情况，一般是因为没有安装 hexo-wordcount 插件，查看 Hexo 插件：1hexo --debug 安装 hexo-wordcount 插件1npm i --save hexo-wordcount 常见问题 - 自动备份Hexo博客源文件原理通过监听Hexo的事件来完成自动执行Git命令完成自动备份呢？通过查阅Hexo文档，找到了Hexo的主要事件，见下表： 事件名 事件发生时间 deployBefore 在部署完成前发布 deployAfter 在部署成功后发布 exit 在 Hexo 结束前发布 generateBefore 在静态文件生成前发布 generateAfter 在静态文件生成后发布 new 在文章文件建立后发布 于是我们就可以通过监听Hexo的deployAfter事件，待上传完成之后自动运行Git备份命令，从而达到自动备份的目的。 步骤 在命令中键入以下命令，完成shelljs模块的安装： 1npm install --save shelljs 编写自动备份脚本,在Hexo根目录的scripts文件夹下新建一个js文件，文件名随意取。如果没有scripts目录，请新建一个 1234567891011121314151617181920212223242526272829303132333435require('shelljs/global');try &#123; hexo.on('deployAfter', function() &#123;//当deploy完成后执行备份 run(); &#125;);&#125; catch (e) &#123; console.log("产生了一个错误&lt;(￣3￣)&gt; !，错误详情为：" + e.toString());&#125;function run() &#123; if (!which('git')) &#123; echo('Sorry, this script requires git'); exit(1); &#125; else &#123; echo("======================Auto Backup Begin==========================="); cd('D:/hexo'); //此处修改为Hexo根目录路径 if (exec('git add --all').code !== 0) &#123; echo('Error: Git add failed'); exit(1); &#125; if (exec('git commit -am "Form auto backup script\'s commit"').code !== 0) &#123; echo('Error: Git commit failed'); exit(1); &#125; if (exec('git push origin master').code !== 0) &#123; echo('Error: Git push failed'); exit(1); &#125; echo("==================Auto Backup Complete============================") &#125;&#125; 其中，需要修改第17行的D:/hexo路径为Hexo的根目录路径。（脚本中的路径为博主的Hexo路径） 如果你的Git远程仓库名称不为origin的话，还需要修改第28行执行的push命令，修改成自己的远程仓库名和相应的分支名。 常见问题 - 代码高亮 小编刚开始写的代码往往是这样的，[Next代码高亮]完全没有作用(http://theme-next.iissnan.com/theme-settings.html#syntax-highlight-scheme) 1require(&apos;shelljs/global&apos;); 原来是没有在三个`后加上语言名，如java。 1require('shelljs/global');]]></content>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodemon]]></title>
    <url>%2F2018%2F05%2F21%2Fnodemon%2F</url>
    <content type="text"><![CDATA[nodemon的配置详解nodemon 安装配置平常我们使用node的时候，经常修改一次js代码后，都要重新node xxx 才能看到改动后的效果，调试起来十分不方便。所以我引入了nodemon模块了弥补这样缺点。 首先安装nodemon 1npm i -g nodemon 安装完 nodemon 后，就可以用 nodemon 来代替 node 来启动应用： 1nodemon [your node app]（相当于 node [your node app]） 还可以来指定端口号 1nodemon ./server.js localhost 8080 可以通过帮助选项 1nodemon -h 或者 nodemon -help 有没有感觉好麻烦呀，但是nodemon大火的原因是它的灵活配置，让我们通过nodemon.json文件来了解它的其他参数。 nodemon基本配置12345678910111213141516171819202122232425&#123; "restartable": "rs", "ignore": [ ".git", "node_modules/**/node_modules" ], "verbose": true, "execMap": &#123; "": "node" "js": "node --harmony" &#125;, "events": &#123; "restart": "osascript -e 'display notification \"App restarted due to:\n'$FILENAME'\" with title \"nodemon\"'" &#125;, "watch": [ "test/fixtures/", "test/samples/" ], "env": &#123; "NODE_ENV": "development", "PORT": "3000" &#125;, "ext": "js json", "legacy-watch": false&#125; nodemon参数详解 restartable:重启命令,默认是rs,可以改成你自己喜欢的字符串。当用nodemon启动应用的时,可以直接键入rs直接重启服务。除了字符串值外，还可以设置fasle,这个值的意思是当nodemon影响你自己的终端命令时，设置为false则不会在nodemon运行期间监听rs的重启命令。 ignore: 忽略的文件后缀名或者文件夹 verbose：true表示输出详细启动与重启信息 execMap: 运行服务的后缀名和对应的运行命令,”js”: “node –harmony” 表示用 nodemon 代替 node –harmony 运行 js 后缀文件;”” 指 www 这些没有后缀名的文件;默认的 defaults.js 配置文件会识别一些文件：py:’python’,rb:’ruby’。 events:这个字段表示 nodemon 运行到某些状态时的一些触发事件，总共有五个状态： start - 子进程（即监控的应用）启动 crash - 子进程崩溃，不会触发 exit exit - 子进程完全退出，不是非正常的崩溃 restart - 子进程重启 config:update - nodemon 的 config 文件改变 watch:监控的文件夹路径或者文件路径。 env:运行环境 development 是开发环境，production 是生产环境。port 是端口号。 ext:监控指定后缀名的文件，用空格间隔 legacy-watch:nodemon 使用Chokidar作为底层监控系统，但是如果监控失效，或者提示没有需要监控的文件时，就需要使用轮询模式（polling mode），即设置 legacy-watch 为 true。nodemon监控和忽略文件的顺序 首先 nodemon 会先读取watch里面需要监控的文件或文件路径， 从文件中选择监控ext中指定的后缀名， 最后去掉从ignore中指定的忽略文件或文件路径。 参考文档：http://www.cnblogs.com/JuFoFu/p/5140302.html]]></content>
      <tags>
        <tag>node</tag>
        <tag>nodemon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2018%2F05%2F21%2Fgit%2F</url>
    <content type="text"><![CDATA[gitGIT基础知识 什么是git? 分布式版本控制系统，它是有Linux（全球比较大的服务器系统） 创始人花费两周时间使用C语言编写的工具（在GIT命令窗口中一般都是执行Linux命令） 什么是版本控制系统？ 在没有版本控制系统之前，我们的操作可能会向下面这样： 创建一个word文档，想要编写自己的年终总结，第一天写了一部分，第二天想接着写，但是发现还要吧第一天的内容进行修改，原有的内容就丢失了，以后也找不到了； 本质问题：后面修改的内容会替换原有内容，原有内容没保存，以后想找都找不到版本控制系统的优势 1、备份文件 2、记录历史 3、回到过去 4、多端共享 5、团队协作 常用的版本控制系统 git:分布式版本控制系统 svn:集中式版本控制系统 分布式和集中式的区别？ [集中式] 想做历史记录的查看或者备份，必须链接到中央服务器才可以（需要联网） 处理速度没有git快 [分布式] 每个开发者本地都是单独的仓库，在自己的仓库中就可以完成历史版本的记录和查看（不需要联网） 团队开发才需要中央服务器 GIT处理的速度更快（GIT是按照数据存储的） 个人可以在不联网的情况下，查看各个版本信息 其余还有一些区别，自己扩展 Linux常用命令 ~当前用户的根目录 ls 查看当前目录下的文件（或者文件夹） -l查看详细信息 -a查看隐藏文件 -la同时具备以上特点 clear 清屏 cd 目录切换 cd ../返回上级目录 cd ./返回当前目录 cd /返回根目录 cd xxx 进入到指定文件夹 cd E:进入到指定的磁盘 mkdir 创建文件夹 touch 创建空文件 可以创建无文件名的文件,例如：touch .babel 在电脑隐藏文件后缀名的情况下，我们也不至于创建1.txt.txt这样重复文件后缀名的文件 vi 向指定文件中插入内容 vi 1.txt 首先进入命令模式 我们先按i.进入插入内容模式 编辑需要写入的内容 按ESC键，再按：键，再按wq(保存并退出) 再按q!(强制退出，新输入的内容不保存) echo xxx&gt;1.txt把xxx内容放到1.txt文件中，如果没有这个文件则创建这个文件(新存放的内容会替换原有的内容) echo xxx&gt;&gt;1.txt新的内容会追加到原有内容后面 cat 查看文件中的内容 cp 拷贝文件 rm 删除文件 -r 递归删除(把当前文件夹中所有的后代元素也都遍历到删除) -f 强制删除 -rf强制递归删除，一旦rf后，没办法还原回来，所以删除要慎重慎重慎重 git工作流程及常用命令 安装完成git后，我们最好先把一些基础信息配置一下（只需要一次即可） git config -l 查看当前本机git的配置清单 [相对比较重要的配置 ：user.name/user.email],每次提交的时候知道是谁提交的 git config –global user.name xxx git config –global user.email xxx 设置的用户名和邮箱可以随便写，但是建议最好写成github/Codding等平台账号邮箱 GIT 的工作流程 git 分布式，每一台客户端都是一个独立的git仓库（有git工作的全套机制） 一个Git仓库分为三个区域： 工作区：平常写代码的地方 暂存区：把一些写好的代码暂时存放的地方 历史区： 生成一个个版本记录的地方 工作区可以看见，但是暂存区和历史区都以数据的形式保存在.git文件中 创建git仓库 在指定目录中，执行git init，相当于以当前目录作为基础，创建一个本地git仓库 创建完成后，会在项目的根目录中显示.git这个文件（隐藏文件）：有这个.git文件的才叫git仓库，没有则不能被称为git仓库（因为暂存区和历史区的内容都是存储在这个文件夹中的） 工作区提交到暂存区 git add xxx 把某个文件提交到暂存区git add . 把所有修改的文件（修改和新增的包含，删除不包含） git add -u 把所有修改的文件(包含修改和删除的，但是不包含新增)git add -A 是点和U的结合体，所有修改、新增、删除的信息都会提交到暂存区(点和-A但是真是效果中，两者差不多，用那个都可以) git status 查看当前文件的状态 红色:在工作区，还没有提交到暂存区 绿色：在暂存区，还没有提交到历史区 如果在提交内容的时候，有些内容不想提交，我们可以增加git提交的忽略文件：.gitignore(没有文件名只有后缀名)12345//=&gt;.gitignore中的信息.idea //=&gt;在使用WB打开项目或者编辑项目，会自动生成的文件node_modules //=&gt;使用npm安装模块的时候，当前安装在项目的模块都在这个文件夹中（之所以也忽略提交，是因为这里的东西太多了）.DS_Store //=&gt;MAC默认文件... 把暂存区提交到历史区 git commit git commit -m&quot;xxx&quot; 提交到历史区 git commit -a -m&#39;xxx&#39;把提交到暂存区和历史区的步骤合在一起完成（只适合已经提交过的一次的文件，被修改后，我们可以这样快速提交，对于新增加的文件，一次都没有提交过，是不允许这样操作的） [root-commit] 根提交简单理解为，第一次提交到历史区域，如果我们创建一个新的仓库，但是没有做过根提交，此时我们仓库中没有任何分支（哪怕是master）,也就不存在所谓的分支切换（当前仓库还不完整：一个工作流程走完一遍才算完整） 工作流中的一些细节知识 不管是从工作区提交暂存区，还是从暂存器提交到历史区，每个区域当前的内容是一直保存下来的，不会消失 git log / git reflog 查看历史提交记录（也相当于查看历史版本号），在没有版本回退的时候，我们用那个都可以，有历史版本回滚，git log只能查看当前回退版本以前的版本 git rm --cached . -r 可以把 . 替换为具体的文件名,从暂存区把所有内容（或者是你指定的具体文件）都撤回工作区。 不管暂存区中的内容是否已经提交到历史版本上了 也不管是你第几次放到暂存区的 统统撤回,这种方式太暴力，我们用的很少 git checkout . 把暂存区内容撤回工作区（覆盖现有工作区内容，并且工作区内容无法找回）,也可以理解为：用上一个暂存区存储的内容覆盖现有工作中的内容，工作去内容变为和上一个暂存区一样的内容，暂存区内容还在 问题：只能限制当前代码没有提交的情况，当前代码没提交回滚的就是上一次提交到暂存区的内容（和工作区内容不一样）；如果当前这次也提交了，暂存区和工作区一样，回滚回来也是一样的，这个方式解决不了 此时需要我们： 在暂存区中，回滚到上一次暂存区中的内容（暂存区先回滚一次） \ git reset HEAD . 把最新暂存区的信息回滚到工作区，替换工作区内容 \ git checkout . git diff 工作区 VS 暂存区 ： git diff 工作区 VS 历史区master 分支：git diff master 暂存区 VS 历史区 ： git diff –cached 查看不同区域之间代码的不同，我们一般都是基于可视化的页面来查看不一样的 最重要的一个回滚代码技巧： git reset --hard 版本号 回滚到指定历史版本,暂存区和工作区的内容都将被这个版本内容所代替 git log 查看版本号 --pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 --graph 显示 ASCII 图形表示的分支合并历史 --abbrev-commit仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 --oneline –pretty=oneline –abbrev-commit 的简化用法。 回滚时候指定的版本号不一定要全截取，有七八位即可 history &gt; 文件 把历史操作步骤输出 团队协作开发下的git操作 前面讲的都是单独开发，在本地建立git仓库的一系列操作流程，团队协作开发之下，流程上还是有所区别的 1、 创建中央仓库 一般是由团队技术LEADER或者指派的人完成的，仓库中默认是有一些初始化文件的。 中央仓库可能在：gitHub、Coding、自己公司的git仓库服务平台、自己公司的服务器等。。。 基于github创建远程仓库，创建完成后，会生成一个远程仓库，例：https://github.com/dapenglalala/2018test.git 作为LEADER,还需要把项目中一些基础的信息提交到远程仓库上 在自己本地上创建一个仓库，把一些基础的内容都放在仓库中 把新增加的信息提交到本地仓库历史区中 让本地仓库和远程仓库保持关联 把本地仓库历史区的信息同步（推送）到远程仓库中 让远程仓库和本地仓库保持关联： git remote add 名字（origin）远程仓库地址 git remote rm 名字 移除关联 git remote -v 查看当前仓库和那些远程仓库保持关联 … 让本地历史区信息和远程仓库信息保持同步： git push origin master 把本地信息推送到远程上 git pull origin master 把远程的拉取到本地 (origin是我们本地和远程仓库关联的那个名字，master是远程仓库的主分支) 当然我们创建完成远程仓库后,可以直接通过git clone 仓库地址 仓库别名（可以不写）的方式把远程仓库克隆到本地： 相当于在本地创建了一个仓库 也让本地这个仓库和远程仓库保持了连接（名字：origin） 也把远程仓库中现有的内容克隆到了本地 … 2、无分支模式下的团队协作 作为开发者每天来的第一件事或者提交代码之前，都要先PULL一下 [如果远程仓库和本地仓库不是同一个文件同一行代码冲突] git 会自动依赖于Fast-forward模式进行合并 自动合并后，我们重新提交即可 git add/ commit/push… [同一个文件同一行代码冲突] 找到冲突的文件，留下自己想要的代码 不管之前是否commit过，都要重新commit,然后push即可 3、单独分支管理 每天第一件事情，就是创建一个dev分支，并且切换到这个分支上 正常的开发代码，把每天开发的任务都先提交到自己的分支上 提交到远程仓库上 把本地自己分支DEV中的内容，合并到本地自己的MASTER分支下 把自己本地创建的分支删除（可以不删除，但是有的公司不希望远程中出现分支，或者避免开发人员的分支冲突，提交之前都把自己创建的分支删除掉） 和第一种只使用MASTER分支一样了，把本地最新合并的MASRER分支代码，提交到远程仓库的MASTER分支下（冲突合并即可） 操作分支的基础命令： git branch 查看现有分支 git branch xxx 创建一个新的分支 （当创建某个分支时，会把当期MASTER分支中的新信息同步到这个分支上） git checkout xxx 切换到某个分支上 git checkout -b xxx 创建一个新分支并且切换到这个分支上 git branch -D xxx 删除某个分支（一定要切换到其他分支上才可以删除当前分支） git merge xxx 合并分支内容到MASTER上（当前分支是MASTER） git log --graph/--oneline 在有分支的情况下，可以清楚查看分支的提交和合并内容（了解即可） 4、git rebase与 git merge的异同 两个使用场景是不一样的，merge只是合并另外一个分支的内容，rebase也合并另外一个分支的内容，但是会把本分支的commits顶到最顶端 用merge确实只需要解决一遍冲突，比较简单粗暴。用rebase有时候会需要多次fix冲突（原因在于本地分支已经提交了非常多的commit，而且很久都没有和上游合并过） 个人建议我个人推荐大家开发的时候，尽量及时rebase上游分支（我习惯是每周merge一次），有冲突提前就fix掉，即使我们自己的分支开发了很久（哪怕是几个月），也不会积累太多的(冲突）conflict，最后合并进主分支的时候特别轻松， 非常反对从master checkout出新分支，自己闷头开发几个月，结果最后merge进主分支的时候，一大堆冲突，自己还嗷嗷叫的行为 5、冲突解决 在rebase的过程中，也许会出现冲突(conflict). 在这种情况，Git会停止rebase并会让你去解决冲突；在解决完冲突后，用git add命令去更新这些内容的索引(index), 然后，你无需执行 git commit,只要执行:1git rebase --continue 这样git会继续应用(apply)余下的补丁。在任何时候，你可以用--abort参数来终止rebase的行动，并且”mywork” 分支会回到rebase开始前的状态。1git rebase --abort --skip跳过（注意此操作中当前分支的修改会直接覆盖目标分支的冲突部分） 6、 git merge 两种模式 请注意--no-ff参数，表示禁用Fast forward,默认操作 --ff-only 参数，表示Fast forward(快进模式)，也就是直接把master指向dev的当前提交，所以合并速度非常快.(但是这种模式下，删除分支后，会丢掉分支信息。) 可以发现 --ff-only 生成的历史记录和 rebase 十分相似，但是本质上 –ff-only 仍然是合并操作，但 rebase 并没有做合并，仅仅是提取修改到目标分支后面。 7、git reset –soft 或者 –hard 或者 git revert git reset –-soft：回退到某个版本，只回退了commit的信息，更改工作区文件。如果还要提交，直接commit即可； git reset -–hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，撤销的commit中所包含的更改被冲掉； git revert HEAD~2:Revert撤销一个提交的同时会创建一个新的提交.这是一个安全的方法，因为它不会重写提交历史（一般用在服务端） git revert可以用在公共分支上，git reset应该用在私有分支上。 如果已经git push了，使用git revert &lt;commit&gt;，恢复一个指定提交。 8、 当前分支还没开发完，突然需要到另外一个分支修复紧急bug如何处理？ 首先确认当前分支能否提交，可以提交的直接commit，但一般代码没写完不好提交，就储藏工作目录与暂存区的状态到堆栈中git stash，切换到另外一个分支修复bug后，切回本分支，git stash pop。 9、有两个稳定版本，将其中一个版本的功能应用到另外一个版本？ 比如某仓库有VIP版和普通版，分别在两个分支开发，普通版更新了一些功能，VIP版也希望将更新应用到分支，但又不能直接将普通版的分支merge过来，这个时候使用：git cherry-pick &lt;commit id&gt;将另一个分支上面的指定提交应用到当前分支上。 10、 分支太多，如何批量删除一个星期之前分支？ 1234567#!/bin/bash#删除一个星期之前的所有本地分支for k in $(git branch | sed /\*/d); do if [ -n &quot;$(git log -1 --before=&apos;1 week ago&apos; -s $k)&quot; ]; then git branch -D $k fidone 11、git tag（比如 v1.0 等等） git tag &lt;name&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息,-a指定标签名，-m指定说明文字 git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签 git tag可以查看所有标签。 git push origin &lt;tagname&gt;可以推送一个本地标签； git push origin --tags可以推送全部未推送过的本地标签； git tag -d &lt;tagname&gt;可以删除一个本地标签； git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。 12、git fetch 和git pull git fetch 并没更改本地仓库的代码，只是拉取了远程 commit 数据，将远程仓库的 commit id 更新为latest。 首先，你的每一个操作都是要指明来源和目标的，而对于 pull 来说目标就是当前分支其次，你得清楚 git 是有 tracking 的概念的，所谓 tracking 就是把来源和目标绑定在一起，节省一些操作是需要输入的参数。那么，假设你的 master 和 develop 都是 tracking 了的，于是：1234567# 当你在 master 下$ git pull# 等于 fetch origin，然后 merge origin/master# 当你在 develop 下$ git pull# 等于 fetch origin，然后 merge origin/develop 因此，若你有多个 remote，git pull [remote name] 所做的事情是： fetch [remote name] 的所有分支 寻找本地分支有没有 tracking 这些分支的，若有则 merge 这些分支，若没有则 merge 当前分支 另外，若只有一个 remote，假设叫 origin，那么 git pull 等价于 git pull origin；平时养成好习惯，没谱的时候都把 来源带上。 但是，如果我要合并 origin/master 去 develop 呢？123# 当你在 master 下$ git checkout develop # 切换到 develop，这就是 【目标】$ git pull origin master # 合并 origin/master，这就是 【来源】 那我怎么知道 tracking 了没有？ 如果你曾经这么推过：git push -u origin master，那么你执行这条命令时所在的分支就已经 tracking to origin/master 了，-u 的用处就在这里 如果你记不清了：cat .git/config，给你一张截图，注意红色方框标示的地方（上半部分是 tracking 的，下半部分是 untracking 的），由此可见，tracking 的本质就是指明 pull 的 merge 动作来源。别忘了：pull = fetch + merge。git fetch 到底干了些啥？1fetch = +refs/heads/*:refs/remotes/origin/* 它指明了 fetch 动作的来源，在本例中就是 叫做 origin 的那个 remote server 下的所有分支也就是说， git fetch 的操作就是取下上述目标的更新。但是——取下的东西到底在哪儿？就在这里：.git/FETCH_HEAD。上图特意也做了一个对比，第一次 cat 的时候没有 fetch，第二次 cat 的时候 fetch 了，于是你可以看到其中的区别，之后就可以明白 git pull 的 merge 是如何被触发的了。 提醒 git pull = git fetch + merge git fetch 拿到了远程所有分支的更新，我用 cat .git/FETCH_HEAD 可以看到其状态，若都是 not-for-merge 则不会有接下来的 merge 动作 merge 动作的默认目标是当前分支，若要切换目标，可以直接切换分支 merge 动作的来源则取决于你是否有 tracking，若有则读取配置自动完成，若无则请指明来源 13、给git pull默认加上rebase功能 git pull时可以加上–rebase参数, 使之不产生Merge点, 保证了代码的整洁, 即: git pull –rebase但每次都加–rebase似乎有些麻烦，我们可以指定某个分支在执行git pull时默认采用rebase方式：1git config branch.dev.rebase true 请使用以上命令时将 dev 修改成您自己本地的分支名字. 提示： 必须cd到你工程的目录下，才能更改分支的配置； 可以使用 git branch 命令， 列出您当前仓库中的所有本地分支；如果你觉得所有的分支都应该用rebase，那就设置：1git config --global branch.autosetuprebase always 这样对于新建的分支都会设定上面的rebase=true了。已经创建好的分支还是需要手动配置的。 14、删除分支 删除本地分支 1git branch -D [本地分支名];//删除本地master分支 删除远程分支 12git push origin --delete &lt;branchName&gt;//删除远程分支git push origin --delete tag &lt;tagname&gt;//删除远程tag 删除远程master分支 github gitlab当前分支不能为要删除分支 在github上将master分支设置成不是default的分支，这里就要选择temp分支了，因为只有两个分支。github操作，点击后面的settings，选择不是master的分支为默认。 删除本地master分支1git branch -D [本地分支名]; github 界面操作给别的仓库提交代码修改或者建议 首先fork别人的仓库 把别人的仓库克隆一份一模一样的，放到自己的账号下，变成自己的仓库（我们平时可以修改自己仓库中的源码） fork的仓库和别人的原始仓库会默认建立一些关系，我们可以把自己仓库中的和别人仓库中不一样的地方，提交给别人（pull-request） 把自己fork的仓库，克隆到本地 以后有一些新的代码心得，可以自己尝试去修改，然后同步到自己的fork的仓库中 在github中发送new pull request github 还可以发布飞后台项目 gitHub只提供了web站点的发布，后台项目没有提供必要的环境 [把整个仓库作为一个项目发布]这种模式不常用 [master 是项目代码 gh-pages分支下存储的是项目预览页面的代码] 其他人克隆研究的是master分支下的代码 看介绍页面是gh-pages分支下的代码 创建一个仓库 把仓库源码克隆到本地 把源码传到master分支上 在本地仓库中常见gh-pages分支 把介绍页面放在gh-pages分支下 把介绍页面的内容上传到github的gh-pages分支下 访问页面：https://用户名.github.io/仓库名/页面名.html(如果页面是index可以忽略不写)]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
