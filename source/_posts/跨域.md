---
title: 跨域
copyright: true
date: 2018-12-12 16:36:52
tags: ['跨域','前端']
---
## 跨域总结
### 为什么会出现跨域问题
出于浏览器的**同源策略**限制，浏览器会拒绝跨域请求。

严格的说，浏览器并不是**拒绝所有的跨域请求**，实际上拒绝的是跨域的**读**操作。

- 通常浏览器允许进行跨域**写**操作（Cross-origin writes），如`链接`，`重定向`；
- 通常浏览器允许跨域资源**嵌入**（Cross-origin embedding），如 `img`、`script` 标签；
- 通常浏览器不允许跨域**读**操作（Cross-origin reads）。`*`
    - **cookie** **localStorage** 
    - **DOM元素**也有同源策略 `iframe`
    - **ajax**也不支持跨域

### 同源策略
如果两个页面拥有相同的**协议**（protocol），**端口**（port）和**主机**（host），那么这两个页面就属于同一个源（origin）。

![同源策略-20181217112324](http://b.zhangyapeng.club/同源策略-20181217112324.jpg)

### 实现跨域的方法
- **jsonp**只能发送**GET**请求,不支持**post**、**put**、**delete**。不安全,容易手**xss**攻击,不采用

- 利用**script标签**不受跨域限制而形成的一种方案。

```js
function jsonp(url,params,cb){
    const script=document.createElement("script")
    return new Promise((resolve,reject)=>{
        window[cb]=function(data){
            resolve(data)
            document.body.removeChild(script)
        }
        params={...params,cb}
        let str=Object.keys(params).map(item=>{
            return item=params[item]
        }).join("&")
        script.src=`${url}?${str}`
        document.body.appendChild(script)
    })
}
jsonp({
url:'http://localhost:3000/say',
parms:{
                wd:'我爱你'
    },
cb:'show'
}).then((res)=>{
    console.log(res)
})
```
### cors
跨域资源共享标准新增了一组**HTTP**首部字段，允许服务器声明哪些源站有权限访问哪些资源。

#### 两种请求
-----
##### 简单请求（simple request）

1. 请求方法是以下三种方法之一：
    - HEAD
    - GET
    - POST

2. HTTP的头信息不超出以下几种字段：
    - Accept
    - Accept-Language
    - Content-Language
    - Last-Event-ID
    - Content-Type：只限于三个值
        - application/x-www-form-urlencoded
        - multipart/form-data
        - text/plain

##### 非简单请求（not-so-simple request）
凡是**不同时满足**上面两个条件，就属于非简单请求。

#### 简单请求
简单请求只需要**CORS服务端**在接受到携带**Origin**字段的跨域请求后，在**response header**中添加**Access-Control-Allow-Origin**等字段给浏览器做同源判断。

![简单请求-20181217152038](http://b.zhangyapeng.club/简单请求-20181217152038.png)

#### 非简单请求
请求方法是**PUT**或**DELETE**，或者**Content-Type**字段的类型是**application/json**,或者人为设置一些**请求头**

1. 进行非简单请求时候,浏览器会首先发出类型为**OPTIONS**的**预检请求**，请求地址相同,

2. 服务器收到"**预检**"请求以后，检查了**Origin**、**Access-Control-Request-Method**和**Access-Control-Request-Headers**字段以后，确认允许跨源请求，就可以做出回应。

3. 关键的是**Access-Control-Allow-Origin**字段，表示**http://api.bob.com**可以请求数据。该字段也可以设为**星号**，表示同意任意**跨源请求**。

4. 如果浏览器否定了**预检**请求，会返回一个正常的HTTP回应，但是没有任何**CORS相关的头信息**字段。这时，浏览器就会**认定**，服务器**不同意预检**请求

5. 一旦服务器通过了"**预检**"请求，以后每次浏览器正常的CORS请求，就都跟**简单请求**一样，会有一个**Origin**头信息字段。**服务器的回应**，也都会有一个**Access-Control-Allow-Origin**头信息字段。**Access-Control-Allow-Origin**字段是每次回应都必定包含的!

![cors-20181217144424](http://b.zhangyapeng.club/cors-20181217144424.jpg)

server.js
```js
// 白名单
let whitList=['http://localhost:3000']
app.use(function(req,res,next){
    let origin=req.headers.origin;
    if(whitList.includes(origin)){
        // 设置那个源可以访问我
        res.setHeader('Access-Control-Allow-Origin',origin) //允许那个源访问我
        res.setHeader('Access-Control-Allow-Headers','name,age') //允许携带那个头访问我
        res.setHeader('Access-Control-Allow-Methods','PUT')//默认GET POST //允许那个方法访问我
        res.setHeader('Access-Control-Max-Age',6)//options没6s发送一次 //预检的存活时间
        res.setHeader('Access-Control-Allow-Credentials',true); //cookie //允许携带cookie
        res.setHeader('Access-Control-Expose-Headers','name,age') //后台给前台发送的头'name'是安全的，前端可以获取到
        if(req.method==='OPTIONS'){ // 预检请求
            res.end();//options请求不做任何处理
        }
    }

    next()
})
app.put("/getData",function(req,res){
    console.log(req.headers) //请求发过来了,浏览器屏蔽了
    res.setHeader('name','zh')
    res.end('我不爱你')
})
app.listen(3001)
```
client.js
```js
 let xhr=new XMLHttpRequest();
        // xhr.open("GET",'http://localhost:3001/getData?wd=1',true) //是否异步
        document.cookie='name=zyp' //cookie不允许跨域
        xhr.withCredentials=true ;//携带凭证
        xhr.open("POST",'http://localhost:3001/getData',true)
        // xhr.setRequestHeader('name','zyp')
        xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded')
         xhr.setRequestHeader('age','1')
        xhr.onreadystatechange=function(){
            if(xhr.readyState===4 && xhr.status>=200 && xhr.status<=300 || xhr.status==304){
                console.log(xhr.response)
                console.log(xhr.getResponseHeader('name'))
            }
        }
        xhr.send()
```

### iframe---> PostMessage 
**PostMessage**是HTML5为了解决**文档通信**而引入了**跨文档通信** API（Cross-document messaging）这个API为window对象新增了一个**window.postMessage**方法，允许**跨窗口通信**，不论这两个窗口是否**同源**。
```js
otherWindow.postMessage(message, targetOrigin, [transfer]);
```
- **otherWindow**:**其他窗口**的一个引用，比如**iframe**的**contentWindow**属性、执行**window.open**返回的窗口对象、或者是命名过或数值索引的**window.frames**。
- **message**:将要发送到其他**window**的数据。它将会被[结构化克隆算法](https://developer.mozilla.org/en-US/docs/DOM/The_structured_clone_algorithm)序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。
- **targetOrigin**:接收消息的窗口的源（**origin**），即"`协议 + 域名 + 端口`"。也可以设为`*`，表示不限制域名，向所有窗口发送，`URL`会被忽略，所以可以不写，这个参数是为了安全考虑
- **transfer[可选]**：是一串和**message**同时传递的 **Transferable** 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权

子窗口向父窗口发送消息的写法类似。
```js
window.opener.postMessage('Nice to see you', 'http://aaa.com');
```
父窗口和子窗口都可以通过**message**事件，监听对方的消息。
```js
window.addEventListener('message', function(e) {
  console.log(e.data);
},false);
```
**message**事件的事件对象**event**，提供以下三个属性
- **event.source**：发送消息的窗口,子窗口可以通过它引用父窗口，然后发送消息
- **event.origin**: 消息发向的网址,可以过滤不是发给本窗口的消息
- **event.data**: 消息内容

#### 读写其他窗口->[window.open](https://www.cnblogs.com/milo-xie/p/6569017.html)
```js
//a.html
    window.onload = function () {
        var popup = window.open('http://localhost:3001/b.html');

        popup.onload = function () {  //必须要有onload
            // 假设当前页面没有改变location，这条语句会成功添加message到发送队列中去（targetOrigin设置对了）
            popup.postMessage("hello there!", "http://localhost:3001");

            function receiveMessage(event) {
                if (event.origin !== "http://localhost:3000") {
                    return;
                }
                console.log(event.data);
            }
            window.addEventListener("message", receiveMessage, false);
        }
    };

```
```js
//b.html
    document.onreadystatechange = function(e) {
        console.log(document.readyState)
        if (document.readyState === 'complete') {
            console.log('message')
            window.addEventListener('message', receiveMessage, false);
        }
    };

    function receiveMessage(event) {
        console.log('in->message')
        if (event.origin !== "http://localhost:3000") {
            return;
        }
        console.log('message', event.data);
        console.log('origin', event.source);
        document.write(event.data);

        // 假设你已经验证了所受到信息的origin (任何时候你都应该这样做), 一个很方便的方式就是把enent.source
        // 作为回信的对象，并且把event.origin作为targetOrigin
        event.source.postMessage("hi there yourself!  the secret response " + "is: rheeeeet!", event.origin);
    }
```
#### 读写其他窗口->iframe
```html
<!-- a.html -->
<iframe src="http://localhost:3001/b.html" frameborder="0" id="frame" onload="load()"></iframe>
    <script>
        function load(){
            let frame=document.getElementById("frame")
            frame.contentWindow.postMessage('我爱你','http://localhost:3001')
            window.onmessage=function(e){
                console.log(e.data)
            }
        }
    </script>
```
```js
<!-- b.html -->
window.onmessage=function(e){
            console.log(e.data)
            e.source.postMessage('我不爱你',e.origin)
}
```










