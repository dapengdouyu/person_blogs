---
title: 跨域
copyright: true
date: 2018-12-12 16:36:52
tags: ['跨域','前端']
---
## 跨域总结
### 为什么会出现跨域问题
出于浏览器的**同源策略**限制，浏览器会拒绝跨域请求。

严格的说，浏览器并不是**拒绝所有的跨域请求**，实际上拒绝的是跨域的**读**操作。

- 通常浏览器允许进行跨域**写**操作（Cross-origin writes），如`链接`，`重定向`；
- 通常浏览器允许跨域资源**嵌入**（Cross-origin embedding），如 `img`、`script` 标签；
- 通常浏览器不允许跨域**读**操作（Cross-origin reads）。`*`
    - **cookie** **localStorage** 
    - **DOM元素**也有同源策略 `iframe`
    - **ajax**也不支持跨域

### 同源策略
如果两个页面拥有相同的**协议**（protocol），**端口**（port）和**主机**（host），那么这两个页面就属于同一个源（origin）。

![同源策略-20181217112324](http://b.zhangyapeng.club/同源策略-20181217112324.jpg)

### 实现跨域的方法
- **jsonp**只能发送**GET**请求,不支持**post**、**put**、**delete**。不安全,容易手**xss**攻击,不采用

- 利用**script标签**不受跨域限制而形成的一种方案。

```js
function jsonp(url,params,cb){
    const script=document.createElement("script")
    return new Promise((resolve,reject)=>{
        window[cb]=function(data){
            resolve(data)
            document.body.removeChild(script)
        }
        params={...params,cb}
        let str=Object.keys(params).map(item=>{
            return item=params[item]
        }).join("&")
        script.src=`${url}?${str}`
        document.body.appendChild(script)
    })
}
jsonp({
url:'http://localhost:3000/say',
parms:{
                wd:'我爱你'
    },
cb:'show'
}).then((res)=>{
    console.log(res)
})
```
### cors
跨域资源共享标准新增了一组**HTTP**首部字段，允许服务器声明哪些源站有权限访问哪些资源。

#### 两种请求
-----
##### 简单请求（simple request）

1. 请求方法是以下三种方法之一：
    - HEAD
    - GET
    - POST

2. HTTP的头信息不超出以下几种字段：
    - Accept
    - Accept-Language
    - Content-Language
    - Last-Event-ID
    - Content-Type：只限于三个值
        - application/x-www-form-urlencoded
        - multipart/form-data
        - text/plain

##### 非简单请求（not-so-simple request）
凡是**不同时满足**上面两个条件，就属于非简单请求。

#### 简单请求
简单请求只需要**CORS服务端**在接受到携带**Origin**字段的跨域请求后，在**response header**中添加**Access-Control-Allow-Origin**等字段给浏览器做同源判断。

![简单请求-20181217152038](http://b.zhangyapeng.club/简单请求-20181217152038.png)

#### 非简单请求
请求方法是**PUT**或**DELETE**，或者**Content-Type**字段的类型是**application/json**,或者人为设置一些**请求头**

1. 进行非简单请求时候,浏览器会首先发出类型为**OPTIONS**的**预检请求**，请求地址相同,

2. 服务器收到"**预检**"请求以后，检查了**Origin**、**Access-Control-Request-Method**和**Access-Control-Request-Headers**字段以后，确认允许跨源请求，就可以做出回应。

3. 关键的是**Access-Control-Allow-Origin**字段，表示**http://api.bob.com**可以请求数据。该字段也可以设为**星号**，表示同意任意**跨源请求**。

4. 如果浏览器否定了**预检**请求，会返回一个正常的HTTP回应，但是没有任何**CORS相关的头信息**字段。这时，浏览器就会**认定**，服务器**不同意预检**请求

5. 一旦服务器通过了"**预检**"请求，以后每次浏览器正常的CORS请求，就都跟**简单请求**一样，会有一个**Origin**头信息字段。**服务器的回应**，也都会有一个**Access-Control-Allow-Origin**头信息字段。**Access-Control-Allow-Origin**字段是每次回应都必定包含的!

![cors-20181217144424](http://b.zhangyapeng.club/cors-20181217144424.jpg)

server.js
```js
// 白名单
let whitList=['http://localhost:3000']
app.use(function(req,res,next){
    let origin=req.headers.origin;
    if(whitList.includes(origin)){
        // 设置那个源可以访问我
        res.setHeader('Access-Control-Allow-Origin',origin) //允许那个源访问我
        res.setHeader('Access-Control-Allow-Headers','name,age') //允许携带那个头访问我
        res.setHeader('Access-Control-Allow-Methods','PUT')//默认GET POST //允许那个方法访问我
        res.setHeader('Access-Control-Max-Age',6)//options没6s发送一次 //预检的存活时间
        res.setHeader('Access-Control-Allow-Credentials',true); //cookie //允许携带cookie
        res.setHeader('Access-Control-Expose-Headers','name,age') //后台给前台发送的头'name'是安全的，前端可以获取到
        if(req.method==='OPTIONS'){ // 预检请求
            res.end();//options请求不做任何处理
        }
    }

    next()
})
app.put("/getData",function(req,res){
    console.log(req.headers) //请求发过来了,浏览器屏蔽了
    res.setHeader('name','zh')
    res.end('我不爱你')
})
app.listen(3001)
```
client.js
```js
 let xhr=new XMLHttpRequest();
        // xhr.open("GET",'http://localhost:3001/getData?wd=1',true) //是否异步
        document.cookie='name=zyp' //cookie不允许跨域
        xhr.withCredentials=true ;//携带凭证
        xhr.open("POST",'http://localhost:3001/getData',true)
        // xhr.setRequestHeader('name','zyp')
        xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded')
         xhr.setRequestHeader('age','1')
        xhr.onreadystatechange=function(){
            if(xhr.readyState===4 && xhr.status>=200 && xhr.status<=300 || xhr.status==304){
                console.log(xhr.response)
                console.log(xhr.getResponseHeader('name'))
            }
        }
        xhr.send()
```
### iframe
如果两个网页**不同源**，就无法拿到**对方的DOM**。典型的例子是**iframe窗口**和window.open方法打开的窗口，它们与**父窗口无法通信**。


比如，父窗口运行下面的命令，如果**iframe**窗口不是同源，就会报错。
```js
document.getElementById("myIFrame").contentWindow.document
// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.
```
当你的页面处于最顶层，也就是外层没有`iframe`包裹你，求这时`window === window.parent`的返回值。

### document.domain
如果两个窗口**一级域名相同**，只是**二级域名不同**，那么设置**document.domain**属性，就可以规避同源政策，拿到DOM。

A网页是`http://w1.example.com/a.html`，B网页是`http://w2.example.com/b.html`，那么只要设置相同的`document.domain`，两个网页就可以共享Cookie。
```js
document.domain = 'example.com';
```
这种方法只适用于 `Cookie` 和 `iframe` 窗口，`LocalStorage` 和 `IndexDB` 无法通过这种方法，规避同源政策。

服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如`.example.com`
```js
Set-Cookie: key=value; domain=.example.com; path=/
```
这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie

### PostMessage 
**PostMessage**是HTML5为了解决**文档通信**而引入了**跨文档通信** API（Cross-document messaging）这个API为window对象新增了一个**window.postMessage**方法，允许**跨窗口通信**，不论这两个窗口是否**同源**。

> 它可用于解决以下方面的问题：

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的iframe消息传递
- 上面三个场景的跨域数据传递

```js
otherWindow.postMessage(message, targetOrigin, [transfer]);
```
- **otherWindow**:**其他窗口**的一个引用，比如**iframe**的**contentWindow**属性、执行**window.open**返回的窗口对象、或者是命名过或数值索引的**window.frames**。

- **message**:html5规范支持任意基本类型或可复制的对象，`但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化`。

- **targetOrigin**:接收消息的窗口的源（**origin**），即"`协议 + 域名 + 端口`"。也可以设为`*`，表示不限制域名，向所有窗口发送，`URL`会被忽略，所以可以不写，这个参数是为了安全考虑

- **transfer[可选]**：是一串和**message**同时传递的 **Transferable** 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权

子窗口向父窗口发送消息的写法类似。
```js
window.opener.postMessage('Nice to see you', 'http://aaa.com');
```
父窗口和子窗口都可以通过**message**事件，监听对方的消息。
```js
window.addEventListener('message', function(e) {
  console.log(e.data);
},false);
```
**message**事件的事件对象**event**，提供以下三个属性
- **event.source**：发送消息的窗口,子窗口可以通过它引用父窗口，然后发送消息
- **event.origin**: 消息发向的网址,可以过滤不是发给本窗口的消息
- **event.data**: 消息内容

#### 读写其他窗口->[window.open](https://www.cnblogs.com/milo-xie/p/6569017.html)
```js
//a.html
    window.onload = function () {
        var popup = window.open('http://localhost:3001/b.html');

        popup.onload = function () {  //必须要有onload
            // 假设当前页面没有改变location，这条语句会成功添加message到发送队列中去（targetOrigin设置对了）
            popup.postMessage("hello there!", "http://localhost:3001");

            function receiveMessage(event) {
                if (event.origin !== "http://localhost:3000") {
                    return;
                }
                console.log(event.data);
            }
            window.addEventListener("message", receiveMessage, false);
        }
    };

```
```js
//b.html
    document.onreadystatechange = function(e) {
        console.log(document.readyState)
        if (document.readyState === 'complete') {
            console.log('message')
            window.addEventListener('message', receiveMessage, false);
        }
    };

    function receiveMessage(event) {
        console.log('in->message')
        if (event.origin !== "http://localhost:3000") {
            return;
        }
        console.log('message', event.data);
        console.log('origin', event.source);
        document.write(event.data);

        // 假设你已经验证了所受到信息的origin (任何时候你都应该这样做), 一个很方便的方式就是把enent.source
        // 作为回信的对象，并且把event.origin作为targetOrigin
        event.source.postMessage("hi there yourself!  the secret response " + "is: rheeeeet!", event.origin);
    }
```
#### 读写其他窗口->iframe
```html
<!-- a.html -->
<iframe src="http://localhost:3001/b.html" frameborder="0" id="frame" onload="load()"></iframe>
    <script>
        function load(){
            let frame=document.getElementById("frame")
            frame.contentWindow.postMessage('我爱你','http://localhost:3001')
            window.onmessage=function(e){
                console.log(e.data)
            }
        }
    </script>
```
```js
<!-- b.html -->
window.onmessage=function(e){
            console.log(e.data)
            e.source.postMessage('我不爱你',e.origin)
}
```
### window.name
浏览器窗口有**window.name**属性。这个属性的最大特点是，无论是否**同源**，只要在**同一个窗口**里，前一个网页设置了这个属性，后一个网页可以**读取它**。

#### 优点
这种方法的优点是，**window.name**容量很大，可以放置非常长的字符串；缺点是必须监听子窗口**window.name**属性的变化，影响网页性能。
#### 操作
- a和b是同域 http://localhost:3000
- c是独立的 http://localhost:3001
- a获取c的数据
- a先引用c,c把值放到window.name上把a引用的地址改到b

```html
<!-- a.html -->
<iframe src="http://localhost:3001/c.html" frameborder="0" onload="load()" id="iframe"></iframe>
    <script>
        let first=true;
        function load(){
            let iframe=document.getElementById("iframe")
            if(first){
                iframe.src='http://localhost:3000/b.html'
                first=false
            }else{
               console.log(iframe.contentWindow.name) 
            }
            
        }
    </script>
```
```js
<!-- c.html -->
window.name='我爱你'
```

### hash
**片段标识符**（fragment identifier）指的是，`URL`的`#`号后面的部分，比如`http://example.com/x.html#fragment的#fragment`。如果只是改变片段标识符，页面不会重新刷新
- a,b同源,c不同源
- 目的`a`想访问`c`
- `a`给`c`穿一个`hash`值,`c`收到`hash`值后,`c`把`hash`值传递给`b`, `b`将结果放到`a`的`hash`值中

```html
<!-- a.html -->
 <iframe src="http://localhost:3001/c.html#iloveyou" frameborder="0"></iframe>
   <script>
       window.onhashchange=function(){
           console.log(location.hash)
       }
   </script>
```
b.html
```js
window.parent.parent.location.hash=location.hash
```
c.html
```js
  console.log(location.hash)
    let iframe=document.createElement("iframe")
    iframe.src='http://localhost:3000/b.html'+location.hash+'1'
    document.body.appendChild(iframe)
```

### websocket
WebSocket对象提供了用于创建和管理 `WebSocket` 连接，以及可以通过该连接发送和接收数据的 API。它是基于TCP的全双工通信,即服务端和客户端可以双向进行通讯，并且允许跨域通讯。基本协议有`ws://`(非加密)和`wss://`(加密)

socket.html
```js
let socket = new WebSocket('ws://localhost:3000');
// 给服务器发消息
socket.onopen = function() {
    socket.send('hello server')
}
// 接收服务器回复的消息
socket.onmessage = function(e) {
    console.log(e.data)
}
```
server.js
```js
let express = require('express');
let app = express();
let WebSocket = require('ws');//npm i ws
// 设置服务器域为3000端口
let wss = new WebSocket.Server({port:3000});
//连接
wss.on('connection', function(ws){
    // 接收客户端传来的消息
    ws.on('message', function(data){
        console.log(data);
        // 服务端回复消息
        ws.send('hello client')
    })
})
```
### Nginx
[Nginx (engine x)](https://link.juejin.im/?target=https%3A%2F%2Fwww.nginx.com%2Fresources%2Fwiki%2F) 是一个高性能的[HTTP](https://link.juejin.im/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2FHTTP)和[反向代理](https://link.juejin.im/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E5%258F%258D%25E5%2590%2591%25E4%25BB%25A3%25E7%2590%2586%2F7793488)服务器，也是一个`IMAP/POP3/SMTP`服务器。

案例：在`nginx`根目录下创建`json/a.json`，里面随便放些内容
```conf
# 代表输入/时默认去打开root目录下的html文件夹
location / {
    root html;
    index index.html index.htm;
}
# 代表输入任意.json后去打开json文件夹
# location 目的地 去哪里找
# ~ 忽略大小写 .匹配所有 * 0-任意字符
location ~.*\.json{
    root json;
    add_header "Access-Control-Allow-Origin" "*";
}
```

### http-proxy-middleware
NodeJS 中间件 **http-proxy-middleware** 实现跨域代理，原理大致与 `nginx` 相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 `cookieDomainRewrite` 参数修改响应头中 `cookie` 中的域名，实现当前域的 `cookie` 写入，方便接口登录认证

- webpack.config.js
```js
module.exports={
devServer: {
        historyApiFallback: true,
        proxy: [{
            context: '/login',
            target: 'http://www.proxy2.com:8080',  // 代理跨域目标接口
            changeOrigin: true,
            secure: false,  // 当代理某些 https 服务报错时用
            cookieDomainRewrite: 'www.domain1.com'  // 可以为 false，表示不修改
        }],
        noInfo: true
    }
}
```
- node.js
```js
var express = require("express");
var proxy = require("http-proxy-middleware");
var app = express();

app.use(
    "/",
    proxy({
        // 代理跨域目标接口
        target: "http://www.proxy2.com:8080",
        changeOrigin: true,

        // 修改响应头信息，实现跨域并允许带 cookie
        onProxyRes: function(proxyRes, req, res) {
            res.header("Access-Control-Allow-Origin", "http://www.proxy1.com");
            res.header("Access-Control-Allow-Credentials", "true");
        },

        // 修改响应信息中的 cookie 域名
        cookieDomainRewrite: "www.proxy1.com" // 可以为 false，表示不修改
    })
);

app.listen(3000);
```
- server.js
```js
var http = require("http");
var server = http.createServer();
var qs = require("querystring");

server.on("request", function(req, res) {
    var params = qs.parse(req.url.substring(2));

    // 向前台写 cookie
    res.writeHead(200, {
        "Set-Cookie": "l=a123456;Path=/;Domain=www.proxy2.com;HttpOnly" // HttpOnly：脚本无法读取
    });

    res.write(JSON.stringify(params));
    res.end();
});

server.listen("8080");
```

### 参考
- [window.open之postMessage传参数](http://www.cnblogs.com/milo-xie/p/6569017.html)
- [跨域总结](https://juejin.im/post/5b5ff1dfe51d4519610e26ec)


