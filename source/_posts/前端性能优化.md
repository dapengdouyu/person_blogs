---
title: 前端性能优化
copyright: true
date: 2018-09-06 16:46:52
tags: ['性能优化']
---

## 前端性能优化
1. 网络层面
2. 构建层面
3. 服务端层面
4. 浏览器渲染层面

深入理解**http请求的过程**是前端性能优化的核心

### 资源的合并和压缩
- 减少http请求数量
- 减少请求资源的大小

#### 压缩实现
- html压缩
- css压缩
- js的压缩和混乱


#### 合并
- 文件与文件之间有插入的上行请求，增加了N-1个网络延迟受
- 丢包问题影响更严重
- 经过代理服务器时可能会被断开
- 浏览器对于同域名下的静态资源加载数量为5个

##### 文件合并存在的问题：
- 首屏渲染问题
- 缓存失效问题

##### 解决办法：
- 公共库合并
- 不同页面的合并
- 见机行事，随机应变

#### 图片相关的优化的核心概念 
**文件大小**、**色彩丰富程度**的权衡
- JPG-有损压缩
- png8-256色+支持透明
- png24-2^24色+不支持透明
- png32-2^24色+支持透明

每种图片格式都有自己的特点，针对不同的业务场景选择不同的图片格式很重要

##### 不同格式图片常见的业务场景

特点：

- jpg有损压缩，压缩率高，不支持透明
- png支持透明，浏览器兼容好
- webp压缩程度更好，在ios webview有兼容性问题 
- svg矢量图，代码内嵌，相对较小，图片样式相对简单的场景

场景：
- jpg —— 大部分不需要透明图片的业务场景
- png —— 大部分需要透明图片的业务场景
- webp —— 安卓全部
- svg矢量图 —— 图片样式相对简单的业务场景

##### 进行图片压缩
- 针对真实图片情况，舍弃一些相对无关紧要的色彩信息
- css雪碧图
- Image inline(base64)

##### CSS雪碧图
- 把你的网站上用到的一些图片整合到一张单独的图片中
- 优点：减少你的网站的HTTP请求数量
- 缺点：整合图片比较大时，一次加载比较慢

##### Image inline
- 将图片的内容内嵌到html当中
- 减少你的网站的HTTP请求数量

##### 使用矢量图
- 使用SVG进行矢量图的绘制
- 使用iconfont解决icon问题

##### 在安卓下使用webp
**WebP** 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。

##### 使用webp
**\<Picture>** 标签 **\<Picture>**是HTML5中的一个新标签，类似<Video>它也可以指定多个格式的资源，由浏览器选择自己支持的格式进行加载。
```html

<picture class="picture">

<source type="image/webp" srcset="image.webp">

<img class="image" src="image.jpg">

</picture>
```
如果浏览器支持WebP格式，就会加载Image.webp，否则会加载Image.jpg。

即使浏览器不支持<Picture>标签，图片仍然会正常显示，只是CSS可能无法正确选取到Picture元素。比如在IE8中，下面的CSS就不会起作用：
```css
.picture img { width: 100px; height: 100px;}
```
但是可以这样来给图片写样式：
```css
.image { width: 100px; height: 100px;}
```
即使浏览器使用的是WebP格式的图片，最终还是会应用img元素的样式。

不过只要使用了，使旧的浏览器支持这个标签，CSS选择器就可以正常使用了。这种方法是最简单的，但是不能作用于CSS中的图片（如背景）

webp的格式:[http://www.a.jpg_.webp](http://www.a.jpg_.webp)

#### 图片压缩:[https://tinypng.com/](https://tinypng.com/)

### css和js加载与执行


#### 一个网站在浏览器端是如何进行渲染的呢？

**html页面渲染的过程**

![html页面加载渲染](http://b.zhangyapeng.club/html页面加载渲染.png)

#### 特点
- 顺序执行、并发加载
- 是否阻塞
- 依赖关系
- 引入方式

##### 顺序执行、并发加载
- 词法分析
- 并发加载
- 并发上限

#####  css阻塞
- css **head中阻塞页面的渲染**、**link标签加载完才渲染**
- css阻塞js的执行
- css不阻塞外部脚本的加载
- js可能修改dom,有可能涉及到css修改，是基于前面执行的css来修改

##### js阻塞 
- 直接引入的js阻塞**页面的渲染**
- js不阻塞**资源的加载**
- js**顺序执行**，阻塞后续js逻辑的执行

##### 依赖关系
- 页面渲染依赖于css的加载
- js的执行顺序的依赖关系
- js逻辑对于dom节点的依赖关系

##### js引入方式
- 直接引入
- defer
- async
- 异步动态引入js

##### 加载和执行的一些优化点
- css 样式表置顶
- 用 link 代替 import
- js 脚本置底
- 合理使用 js 的异步加载能力

#### 懒加载
- 图片进入可视区域之后请求图片资源
- 对于电商等图片很多，页面很长的业务场景适用
- 减少无效资源的加载
- 并发加载的资源过多会阻塞js的加载，影响网站的正常使用

```html
<img src="" data-origin="" />

<script>
var vierHeight=document.documentElement.clientHeight//可是区域的高度
react=item.getBoundingClientReact() 是否在可视区
</script>

<!-- img要设置高度 -->
```

#### 预加载
- 图片等静态资源在使用之前的提前请求
- 资源使用到的时能缓存中加载，提升用户体验
- 页面展示的依赖关系维护

#### 预加载方式
- html标签
```html
<img src="http://xxx/jpg" style="display:none" />
```
- 使用Image对象
```js
var image=new Image()
image.src="http://xxx.jpg"
```

- 使用XMLHttpRequest对象请求

- preload.js

### 重绘和回流

#### css性能让javascript变慢
- **css**:UI渲染单独的进程
- **js**:javascript解析的进程
- UI渲染与javascript解析是互斥的执行的
- 频繁触发**重绘**与**回流**，会导致UI频繁渲染，最终导致js变慢

#### 回流
- 当**render tree**中的一部分(或全部)因为元素的规模**尺寸**，**布局**，**隐藏**等改变而需要重新**构建**。这就称为回流(reflow)
- 当页面**布局**和**几何属性**改变时就需要回流

#### 重绘
当**render tree**中的一些元素需要更新属性，而这些属性只是影响元素的**外观**，**风格**，而**不**会影响**布局**的，比如**background-color**。则就叫称为重绘。

**注意：**
- 回流必将引起重绘
- 而重绘不一定会引起回流

##### 触发页面冲布局的属性
- 盒子模型相关属性会触发重布局
- 定位属性及浮动也会触发重布局
- 改变节点内部文字结构也会触发重布局

![回流](http://b.zhangyapeng.club/回流.jpg)

##### 只触发重绘的属性

![重绘](http://b.zhangyapeng.club/重绘.jpg)


##### 新建DOM的过程
1. 获取DOM后分割为多个图层
2. 对每个图层的节点计算样式结果（Recalculate style--样式重计算）
3. 为每个节点生成图形和位置（Layout--回流和重布局）
4. 将每个节点绘制填充到图层位图中（Paint Setup和Paint--重绘）
5. 图层作为纹理上传至GPU
6. 符合多个图层到页面上生成最终屏幕图像（Composite Layers--图层重组）

**注意：**
- 将**频繁重绘回流**的DOM元素单独作为一个**独立图层**，那么这个DOM元素的重绘和回流的影响**只会**在这个图层中。
- 因为**合并图层**的时候,也就是**Composite Layers**，会消耗大量的时间，所以尽量少建立图层，除非该图层影响页面性能大的时候。

#### 如何将DOM元素变成新的独立图层？
#### Chrome创建图层的条件
- **3D**或透视变换（perspective transform）CSS属性
- 使用加速视频解码的**<video\>**节点
- 拥有3D（**WebGL**）上下文或加速的2D上下文的**<canvas\>**节点
- 混合插件（如**Flash**）
- 对自己的opacity做**CSS动画**或使用一个动画webkit变换的元素
- 拥有**加速CSS过滤器**的元素
- 元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）
- 元素有一个z-index较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染）

##### 代码实现
```css
/* 两个都可以*/
*{
    transfrom:translateZ(0);
    will-change:transform;
}
```

##### 开启Layers
![laylers](http://b.zhangyapeng.club/laylers.jpg)

##### 开启paint(渲染视图)
![Painers](http://b.zhangyapeng.club/Painers.jpg)


**用例**：**gif**可以使用创建图层，因为gif图会频繁的重绘,但是img标签本身不会创建图层，所以需要我们去创建

#### 优化方案
1. **避免**使用触发重绘、回流的css属性
2. 将重绘、回流的影响范围限制在**单独的图层**之内
3. 图层不能被**滥用**

#### 实战优化点
1. 用**translate**替代**top**改变
2. 用**opacity**替代**visibility**
3. 不要一条一条地修改 DOM 的样式，预先定义好 class，然后修改 DOM 的 className
4. **把 DOM 离线后修改**，比如：先把 DOM 给 display:none (有一次**Reflow回流**)，然后你修改100次，然后再把它显示出来
5. 不要把 **DOM 结点的属性值 (offsetHeight)**放在一个循环里当成**循环**里的变量
6. 不要使用**table**布局，可能很小的一个小改动会造成整个**table**的重新布局
7. 动画实现的**速度的选择**
8. 对于**动画**新建图层
9. 启用**GPU**硬件加速

##### GPU加速(WebGL、3d)
- GPU是并行运算的,对于并行运算的纹理绘制，会非常快
- 因为数据在cpu上,如果GPU加速，要把数据从cpu传输到GPU上，如果数据过多，要慎重考虑


### 浏览器储存
#### Cookie
![cookie](http://b.zhangyapeng.club/cookie.png)
- 因为HTTP请求无状态，所以需要cookie去**维持客户端状态**
- cookie的生成方式
    - 用于浏览器端和服务器端的交互
    - 客户端自身数据的存储
    - http response header中的set-cookie
    - js中可以通过document.cookie可以读写cookie
- 过期时间**expire**
    - 仅仅作为浏览器存储（大小**4KB**左右，能力被**localstorage**替代）
    - **httponly**不支持js的读写
- cookie中在相关**域名**下面 —— **cdn的流量损耗**
    - cdn的域名和主站的域名要分开

#### LocalStorage
- HTML5设计出来专门用于浏览器存储的
- 大小为5M左右
- 仅在客户端使用，不和服务端进行通信
- 接口封装较好
- 浏览器本地缓存方案

#### SessionStorage
- **会话级别**的浏览器存储
- 大小为5M左右
- 仅在客户端使用，不和服务端进行通信
- 接口封装较好
- 对于表单信息的维护

#### IndexedDB
- IndexedDB 是一种低级API，用于客户端存储**大量结构化数据**。该API使用索引来实现对该数据的高性能搜索。虽然**Web Storage**对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案。
- 为应用创建离线版本

#### PWA
PWA (Progressive Web Apps) 是一种 Web App 新模型，并不是具体指某一种前沿的技术或者某一个单一的知识点，我们从英文缩写来看就能看出来，这是一个**渐进式**的 Web App，是通过一系列新的 Web 特性，配合优秀的 UI 交互设计，逐步的增强 Web App 的用户体验。

#### 特点
- **可靠**：在没有网络的环境中也能提供基本的页面访问，而不会出现“未连接到互联网”的页面。
- **快速**：针对网页渲染及网络数据访问有较好优化。
- **融入**（Engaging）：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性

####  检测PWA的支持度
- [lighthouse](https://lavas.baidu.com/doc-assets/lavas/vue/more/downloads/lighthouse_2.1.0_0.zip)

#### Service Worker
- **Service Worker**是一个**脚本**，浏览器独立于当前网页，将其在**后台运行**,为实现一些**不依赖页面**或者**用户交互**的特性打开了一扇大门。在未来这些特性将包括推送消息,背景后台同步， geofencing（地理围栏定位），但它将推出的第一个首要特性，就是**拦截**和**处理网络**请求的能力，包括以编程方式来管理被缓存的响应。

#### 特点
- 使用拦截和处理网络请求的能力，去实现一个离线应用
- 使用**service Worker**在后台运行同时能和页面通信的能力，去实现大规模后台数据的处理

![service](http://b.zhangyapeng.club/service.png)

#### 应用
- [chrome://serviceworker-internals/](chrome://serviceworker-internals/
)

- [chrome://inspect/#service-workers](chrome://inspect/#service-workers
)

#### [测试页面](https://nzv3tos3n.qnssl.com/message/msg-demo.html)
```js
// 当前页
(function () {

    if (navigator.serviceWorker) {

        var msgIpt = document.getElementById('ipt'),
            showArea = document.getElementById('show'),
            sendBtn = document.getElementById('sendBtn');


        navigator.serviceWorker.register('service-worker3.js');


        navigator.serviceWorker.addEventListener('message', function (event) {
            showArea.innerHTML = showArea.innerHTML + ('<li>' + event.data.message + '</li>');
        });

        sendBtn.addEventListener('click', function () {

            // 发送数据
            navigator.serviceWorker.controller.postMessage(msgIpt.value);
            msgIpt.value = '';
        });
    }
})();
```

```js
//servers-work
self.addEventListener('message', function(event) {
    var promise = self.clients.matchAll()
        .then(function(clientList) {
            var senderID = event.source ? event.source.id : 'unknown';

            if (!event.source) {
                console.log('event.source is null; we don\'t know the sender of the ' +
                    'message');
            }

            clientList.forEach(function(client) {

                if (client.id === senderID) {
                    return;
                }
                client.postMessage({
                    client: senderID,
                    message: event.data
                });
            });
        });


    if (event.waitUntil) {
        event.waitUntil(promise);
    }
});


self.addEventListener('activate', function(event) {
    event.waitUntil(self.clients.claim());
});
```

### 缓存
![cache](http://b.zhangyapeng.club/cache.png)
![cache策略](http://b.zhangyapeng.club/cache策略.png)

#### httpHeader
- response
- request
    - max-age
    - s-max-age
    - private
    - public
    - no-cache
    - no-store

##### max-age
- **cache-control**最大过期时间,优先级更高**http1.1**
- **expires**http1.0 过期时间 优先级低
- 返回200

##### s-maxage
- 优先级比**max-age**高
- 只能指定**public设备**的缓存，就是定义**cdn**的缓存时间
    - **private缓存设备**指代**浏览器**，只能当前用户访问的缓存设备
    - **public缓存设备**例如cdn缓存设备，可以支持多用户访问缓存信息

![max-age](http://b.zhangyapeng.club/max-age.png)

![s-max-age](http://b.zhangyapeng.club/s-max-age.png)

##### no-cahce
- 不会像**max-age**一样，不往服务器发请求，而直接读取本地缓存
- 会让浏览器发请求到服务器，让服务器判断当前缓存是否可用，和**last-modified**配合使用
![no-cahce](http://b.zhangyapeng.club/no-cahce.png)

##### no-store
配置**no-store**就不使用任何缓存策略

##### Expires
- 缓存过期时间,用来指定资源到期的时间，是服务器端的具体时间点
- 告诉浏览器在过期时间前浏览器可以直接从浏览器缓存中读取数据，而无需再次请求

![expires](http://b.zhangyapeng.club/expires.jpg)

#### 协商缓存（客户端和服务端协商的结果）（缓存304，没匹配上缓存200）
##### Last-Modifed/IF-Modified-Since
- 基于客户端和服务器端协商的缓存机制
- last-modified----response header
- if-modified-since----request header
- 需要与**cache-control**共同使用,**max-age**没有过期先走**max-age**

![last-modified](http://b.zhangyapeng.club/last-modified.png)


####### last-modified有什么缺点？
- 某些服务端不能获取精确的修改时间
- 文件修改时间改了，但是文件内容却没有变
- 毫秒级别的修改不能区分

##### Etag/If-None-Match
- 文件内容的hash值
- etag--response header
- if-none-match---request header
- 需要与**cache-control**共同使用
- 如果同时有**etag**和**last-modified**存在，在发送请求的时候会一次性的发送给服务器，没有优先级，服务器会比较这两个信息（在具体实现上，大多数做法针对这种情况只会比对**etag**）。服务器在输出上，如果输出了**etag**就没有必要再输出**last-modified**（实际上大多数情况会都输出）。
![etag](http://b.zhangyapeng.club/etag.png)


#### 分级缓存策略
###### 浏览器输入 url 之后敲下回车，刷新 F5 与强制刷新(Ctrl + F5)，又有什么区别？

实际上浏览器输入**url**之后敲下**回车**就是先看本地**cache-control**、**expires**的情况，**刷新**(F5)就是忽略先看本地**cache-control**、**expires**的情况，带上条件**If-None-Match**、**If-Modified-Since**，**强制刷新**(Ctrl + F5)就是不带条件的访问。

值得注意的是，如果是 浏览器输入**url**之后敲下回车 你在**network**里面看到的状态往往是**200**，但是大小是**0**。这是因为这个**200**是上次访问资源返回的状态码。

如果你是一位开发者，还是建议在 Chrome 里面开启**Disable Cache**.

![分级缓存](http://b.zhangyapeng.club/分级缓存.png)


**查看缓存**:
- [http://qqbrowser://view-http-cache/](http://qqbrowser://view-http-cache/)
- [chrome://about/](chrome://about/)

#### 服务端性能优化
- vue渲染面临的问题
    - 首屏加载问题
        - 下载vue.js
        - 执行vue.js
        - 生成html页面
    - 以前没有前端框架时
        - 用jsp/php在**服务器端进行数据的填充**
        - 发送给客户端就是已经**填充好数据**的html
    - 使用Juqery异步加载数据
    - 使用React和Vue前端框架

##### vue性能进行提升方案
- 构建层模板编译
- 数据无关的**prerender**的方式
- 服务端渲染















