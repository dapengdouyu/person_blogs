---
title: 前端性能优化
copyright: true
date: 2018-09-06 16:46:52
tags: ['性能优化']
---

## 前端性能优化
1. 网络层面
2. 构建层面
3. 服务端层面
4. 浏览器渲染层面

深入理解**http请求的过程**是前端性能优化的核心

### 资源的合并和压缩
- 减少http请求数量
- 减少请求资源的大小

#### 压缩实现
- html压缩
- css压缩
- js的压缩和混乱


#### 合并
- 文件与文件之间有插入的上行请求，增加了N-1个网络延迟受
- 丢包问题影响更严重
- 经过代理服务器时可能会被断开
- 浏览器对于同域名下的静态资源加载数量为5个

##### 文件合并存在的问题：
- 首屏渲染问题
- 缓存失效问题

##### 解决办法：
- 公共库合并
- 不同页面的合并
- 见机行事，随机应变

#### 图片相关的优化的核心概念 
**文件大小**、**色彩丰富程度**的权衡
- JPG-有损压缩
- png8-256色+支持透明
- png24-2^24色+不支持透明
- png32-2^24色+支持透明

每种图片格式都有自己的特点，针对不同的业务场景选择不同的图片格式很重要

##### 不同格式图片常见的业务场景

特点：

- jpg有损压缩，压缩率高，不支持透明
- png支持透明，浏览器兼容好
- webp压缩程度更好，在ios webview有兼容性问题 
- svg矢量图，代码内嵌，相对较小，图片样式相对简单的场景

场景：
- jpg —— 大部分不需要透明图片的业务场景
- png —— 大部分需要透明图片的业务场景
- webp —— 安卓全部
- svg矢量图 —— 图片样式相对简单的业务场景

##### 进行图片压缩
- 针对真实图片情况，舍弃一些相对无关紧要的色彩信息
- css雪碧图
- Image inline(base64)

##### CSS雪碧图
- 把你的网站上用到的一些图片整合到一张单独的图片中
- 优点：减少你的网站的HTTP请求数量
- 缺点：整合图片比较大时，一次加载比较慢

##### Image inline
- 将图片的内容内嵌到html当中
- 减少你的网站的HTTP请求数量

##### 使用矢量图
- 使用SVG进行矢量图的绘制
- 使用iconfont解决icon问题

##### 在安卓下使用webp
**WebP** 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。

##### 使用webp
**\<Picture>** 标签 **\<Picture>**是HTML5中的一个新标签，类似<Video>它也可以指定多个格式的资源，由浏览器选择自己支持的格式进行加载。
```html

<picture class="picture">

<source type="image/webp" srcset="image.webp">

<img class="image" src="image.jpg">

</picture>
```
如果浏览器支持WebP格式，就会加载Image.webp，否则会加载Image.jpg。

即使浏览器不支持<Picture>标签，图片仍然会正常显示，只是CSS可能无法正确选取到Picture元素。比如在IE8中，下面的CSS就不会起作用：
```css
.picture img { width: 100px; height: 100px;}
```
但是可以这样来给图片写样式：
```css
.image { width: 100px; height: 100px;}
```
即使浏览器使用的是WebP格式的图片，最终还是会应用img元素的样式。

不过只要使用了，使旧的浏览器支持这个标签，CSS选择器就可以正常使用了。这种方法是最简单的，但是不能作用于CSS中的图片（如背景）

webp的格式:[http://www.a.jpg_.webp](http://www.a.jpg_.webp)

#### 图片压缩:[https://tinypng.com/](https://tinypng.com/)

### css和js加载与执行


#### 一个网站在浏览器端是如何进行渲染的呢？

**html页面渲染的过程**

![html页面加载渲染](http://pe9fmhwrj.bkt.clouddn.com/html页面加载渲染.png)

#### 特点
- 顺序执行、并发加载
- 是否阻塞
- 依赖关系
- 引入方式

##### 顺序执行、并发加载
- 词法分析
- 并发加载
- 并发上限

#####  css阻塞
- css **head中阻塞页面的渲染**、**link标签加载完才渲染**
- css阻塞js的执行
- css不阻塞外部脚本的加载

##### js阻塞 
- 直接引入的js阻塞**页面的渲染**
- js不阻塞**资源的加载**
- js**顺序执行**，阻塞后续js逻辑的执行

##### 依赖关系
- 页面渲染依赖于css的加载
- js的执行顺序的依赖关系
- js逻辑对于dom节点的依赖关系

##### js引入方式
- 直接引入
- defer
- async
- 异步动态引入js

##### 加载和执行的一些优化点
- css 样式表置顶
- 用 link 代替 import
- js 脚本置底
- 合理使用 js 的异步加载能力

#### 懒加载
- 图片进入可视区域之后请求图片资源
- 对于电商等图片很多，页面很长的业务场景适用
- 减少无效资源的加载
- 并发加载的资源过多会阻塞js的加载，影响网站的正常使用

```html
<img src="" data-origin="" />

<script>
var vierHeight=document.documentElement.clientHeight//可是区域的高度
react=item.getBoundingClientReact() 是否在可视区
</script>

<!-- img要设置高度 -->
```

#### 预加载
- 图片等静态资源在使用之前的提前请求
- 资源使用到的时能缓存中加载，提升用户体验
- 页面展示的依赖关系维护

#### 预加载方式
- html标签
```html
<img src="http://xxx/jpg" style="display:none" />
```
- 使用Image对象
```js
var image=new Image()
image.src="http://xxx.jpg"
```

- 使用XMLHttpRequest对象请求

- preload.js

### 重绘和回流

#### css性能让javascript变慢
- **css**:UI渲染
- **js**:javascript解析
- 频繁触发**重绘**与**回流**，会导致UI频繁渲染，最终导致js变慢

#### 回流
- 当**render tree**中的一部分(或全部)因为元素的规模**尺寸**，**布局**，**隐藏**等改变而需要重新**构建**。这就称为回流(reflow)
- 当页面**布局**和**几何属性**改变时就需要回流

#### 重绘
当**render tree**中的一些元素需要更新属性，而这些属性只是影响元素的**外观**，**风格**，而**不**会影响**布局**的，比如**background-color**。则就叫称为重绘。

**注意：**
- 回流必将引起重绘
- 而重绘不一定会引起回流

##### 触发页面冲布局的属性
- 盒子模型相关属性会触发重布局
- 定位属性及浮动也会触发重布局
- 改变节点内部文字结构也会触发重布局

![回流](http://pe9fmhwrj.bkt.clouddn.com/回流.jpg)

##### 只触发重绘的属性

![重绘](http://pe9fmhwrj.bkt.clouddn.com/重绘.jpg)








