---
title: 前端设计模式
copyright: true
date: 2018-09-17 14:31:57
tags: ['设计模式','架构']
---
## 面向对象
### 什么是面向对象
- 类
```js
//类 即 模板
class Person{
    constructor(name,age){
        this.name=name;
        this.age=age;
    }
    eat(){
        alert(`${this.name} eat something`)
    }
    speak(){
        alert(`My name is ${this.name},age${this.age}`)
    }
}
```
- 对象（实例）
```JS
//创建实例
let zhang=new People('zhang',20)
zhang.eat()
zhang.speak()

//创建实例
let wang=new People('wang',21)
wang.eat()
wang.speak()
```
###
- 继承
    - 子类继承父类
    - 父类是公共的，不仅仅服务于单个子类
    - 继承可以将公共方法抽离出来，提高复用，减少冗余
```js
//父类
class Person{
    constructor(name,age){
        this.name=name;
        this.age=age;
    }
    eat(){
        alert(`${this.name} eat something`)
    }
    speak(){
        alert(`My name is ${this.name},age${this.age}`)
    }
}


//子类
class Student extends Person{
    constructor(name,age,number){
        super(name,age)
        this.number=number
    }
}
```
```js
//实例
let xiaoming=new Student('xiaoming',10,'A1')
xiaoming.eat()
```
- 封装
    - 数据的权限和保密
    - 减少耦合，不该外露的不外露
    - 利用数据、接口的权限管理
    - 3个属性
        - public 完全开放
        - protected 对子类开放
        - private 对自己开放
    - es6不支持，一般认为_开头的属性是private，可以用typescipt 来演示
```ts
//父类
class People{
    name
    age
    protected weight //定义 protected 属性 受保护的属性，只能自己访问和子类访问
    constructor(name,age){
        this.name=name;
        this.age=age
        this.weight=120
    }
    eat(){
        alert(`${this.name} eat something`)
    }
    speak(){
        alert(`MY name is ${this.name},age ${this.age}`)
    }
}

//子类
class Student extends People{
    number
    private girlfriend //定义 private 属性
    constructor(name,age,number){
        super(name,age)
        this.number=number
        this.girlfriend='xiaoli'
    }
    study(){
        alert(`${this.name} study`)
    }
    getWeight(){
        alert(`${this.weight}`)
    }
}


//实例
let xiaoming=new Student('xiaoming',10,'A1')
xiaoming.getWeight()
//console.log(xiaoming.girlfriend) //注意，编译会报错，直接编译不通过
```
- 多态
    - 同一接口不同实现
    - js应用极少
    - 需要结合java等语言的接口、重写、重载等功能
    - 保持子类的开放性和灵活性
    - 面向接口编程
    - （js引用极少，了解即可）
```js
class People{
    constructor(name){
        this.name=name
    }
    saysomething(){

    }
}
 
class A extends People{
    constructor(name){
        super(name)
    }
    saySomething(){
        alert('I am A')
    }
}

class B extends People{
    constructor(name){
        super(name)
    }
    saySomething(){
        alert('I am B')
    }
}

let a= new A('a')
a.saySomething()
let b=new B('b)
b.saySomething()
```
### 为何使用面向对象
- 程序执行：顺序、判断、循环---结构化
- 面向对象-- 结构化
- 对于计算机，结构化的才是最简单
- 编程应该 简单 & 抽象

## UML类图
- Unified Modeling Language 统一建模语言
- 类图，UML包含很多种图，和本课相关的是类图
- 关系，主要讲解泛化和关联
- 演示 ，代码和类图结合

### 画图工具
- MS Office visio
- [https://www.processon.com](https://www.processon.com)
### 类图
![类图](http://b.zhangyapeng.club/类图.png)
![类图实例](http://b.zhangyapeng.club/类图实例.png)

### 关系
- 泛化，表示继承
- 关联，表示引用

```js
class People{
    constructor(name,house){
        this.name=name
        this.house=house
    }
    saysomething(){

    }
}
 
class A extends People{
    constructor(name,house){
        super(name,house)
    }
    saySomething(){
        alert('I am A')
    }
}

class B extends People{
    constructor(name,house){
        super(name,house)
    }
    saySomething(){
        alert('I am B')
    }
}
class House{
    constructor(name,house){
    }
}

let aHouse=new House('beijing')
let a= new A('a',aHouse)
a.saySomething()
let b=new B('b)
b.saySomething()
```
![类图例子](http://b.zhangyapeng.club/类图例子.png)