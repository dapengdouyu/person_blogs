---
title: 前端设计模式
copyright: true
date: 2018-09-17 14:31:57
tags: ['设计模式','架构']
---
## 面向对象
### 什么是面向对象
- 类
```js
//类 即 模板
class Person{
    constructor(name,age){
        this.name=name;
        this.age=age;
    }
    eat(){
        alert(`${this.name} eat something`)
    }
    speak(){
        alert(`My name is ${this.name},age${this.age}`)
    }
}
```
- 对象（实例）
```JS
//创建实例
let zhang=new People('zhang',20)
zhang.eat()
zhang.speak()

//创建实例
let wang=new People('wang',21)
wang.eat()
wang.speak()
```
###
- 继承
    - 子类继承父类
    - 父类是公共的，不仅仅服务于单个子类
    - 继承可以将公共方法抽离出来，提高复用，减少冗余
```js
//父类
class Person{
    constructor(name,age){
        this.name=name;
        this.age=age;
    }
    eat(){
        alert(`${this.name} eat something`)
    }
    speak(){
        alert(`My name is ${this.name},age${this.age}`)
    }
}


//子类
class Student extends Person{
    constructor(name,age,number){
        super(name,age)
        this.number=number
    }
}
```
```js
//实例
let xiaoming=new Student('xiaoming',10,'A1')
xiaoming.eat()
```
- 封装
    - 数据的权限和保密
    - 减少耦合，不该外露的不外露
    - 利用数据、接口的权限管理
    - 3个属性
        - public 完全开放
        - protected 对子类开放
        - private 对自己开放
    - es6不支持，一般认为_开头的属性是private，可以用typescipt 来演示
```ts
//父类
class People{
    name
    age
    protected weight //定义 protected 属性 受保护的属性，只能自己访问和子类访问
    constructor(name,age){
        this.name=name;
        this.age=age
        this.weight=120
    }
    eat(){
        alert(`${this.name} eat something`)
    }
    speak(){
        alert(`MY name is ${this.name},age ${this.age}`)
    }
}

//子类
class Student extends People{
    number
    private girlfriend //定义 private 属性
    constructor(name,age,number){
        super(name,age)
        this.number=number
        this.girlfriend='xiaoli'
    }
    study(){
        alert(`${this.name} study`)
    }
    getWeight(){
        alert(`${this.weight}`)
    }
}


//实例
let xiaoming=new Student('xiaoming',10,'A1')
xiaoming.getWeight()
//console.log(xiaoming.girlfriend) //注意，编译会报错，直接编译不通过
```
- 多态
    - 同一接口不同实现
    - js应用极少
    - 需要结合java等语言的接口、重写、重载等功能
    - 保持子类的开放性和灵活性
    - 面向接口编程
    - （js引用极少，了解即可）
```js
class People{
    constructor(name){
        this.name=name
    }
    saysomething(){

    }
}
 
class A extends People{
    constructor(name){
        super(name)
    }
    saySomething(){
        alert('I am A')
    }
}

class B extends People{
    constructor(name){
        super(name)
    }
    saySomething(){
        alert('I am B')
    }
}

let a= new A('a')
a.saySomething()
let b=new B('b)
b.saySomething()
```
### 为何使用面向对象
- 程序执行：顺序、判断、循环---结构化
- 面向对象-- 结构化
- 对于计算机，结构化的才是最简单
- 编程应该 简单 & 抽象

## UML类图
- Unified Modeling Language 统一建模语言
- 类图，UML包含很多种图，和本课相关的是类图
- 关系，主要讲解泛化和关联
- 演示 ，代码和类图结合

### 画图工具
- MS Office visio
- [https://www.processon.com](https://www.processon.com)
### 类图
![类图](http://b.zhangyapeng.club/类图.png)
![类图实例](http://b.zhangyapeng.club/类图实例.png)

### 关系
- 泛化，表示继承
- 关联，表示引用

```js
class People{
    constructor(name,house){
        this.name=name
        this.house=house
    }
    saysomething(){

    }
}
 
class A extends People{
    constructor(name,house){
        super(name,house)
    }
    saySomething(){
        alert('I am A')
    }
}

class B extends People{
    constructor(name,house){
        super(name,house)
    }
    saySomething(){
        alert('I am B')
    }
}
class House{
    constructor(name,house){
    }
}

let aHouse=new House('beijing')
let a= new A('a',aHouse)
a.saySomething()
let b=new B('b)
b.saySomething()
```
![类图例子](http://b.zhangyapeng.club/类图例子.png)

## 设计原则
### 何为设计
#### 描述
- 即按照哪一种思路或者标准来实现功能
- 功能相同，可以有不同设计方案来实现
- 伴随着需求增加，设计的作用才能体现出来

#### 《UNIX/LINUX设计哲学》设计准则
1. 小即是美
2. 让每个程序只做好一件事
3. 快速建立原型
4. 舍弃高效率而取可移植性
5. 采用纯文本来存储数据
6. 充分利用软件的杠杆效应(软件复用)
7. 使用shell脚本来提高杠杆效应和可移植性
8. 避免强制性的用户界面
9. 让每个程序都称为过滤器
10. 小准则：允许用户定制环境
11. 小准则：尽量使用操作系统内核小而轻量化
12. 小准则：使用小写字母并尽量简写
13. 小准则：沉默是金
14. 小准则：各部分之和大于整体
15. 小准则：寻求90%的解决方案

#### 演示：沉默是金+让每个程序成为过滤器
```sh
# 让每个程序成为过滤器
ls | grep *.json | grep 'package'
```
### S O L I D 五大设计原则
- **S**: 单一职责原则
- **O**: 开放封闭原则
- **L**: 李氏置换原则
- **I**: 接口独立原则
- **D**: 依赖倒置原则

#### 单一职责原则
- 一个程序只做好一件事
- 如果功能过于复杂就拆分开，每个部分保持独立

#### 开放封闭原则
- 对**扩展**开放，对**修改**封闭
- 增加需求时，扩展新代码，而非修改已有代码
- 这是软件设计的终极目标

#### 李氏置换原则

- 子类能覆盖父类
- 父类能出现的地方子类就能出现
- js使用较少（弱类型 && 继承使用较少）

#### 接口独立原则
- 保持接口的单一独立，避免出现“胖接口”
- JS中没有接口（typescript例外）,使用较少
- 类似与单一职责原则，这里更关注接口

#### 依赖倒置原则
- 面向接口编程，依赖于抽象而不依赖于具体
- 使用方只关注接口而不关注具体类的实现
- JS中使用较少(没有接口 & 弱类型)

#### 总结
- SO 体现较多，详细介绍
- LID体现较少，但是要了解其用意

```js
// 单一职责 开放封闭原则
// 加载图片
function loadImg(src){
    let promise=new Promise(function(resolve,reject){
        let img=document.createElement('img')
        img.onlad=function(){
            resolve(img)
        }
        img.onerror=function(err){
            reject('图片加载失败')
        }
        img.src=src
    })
    return promise
}
let src='http://'
let result=loadImg(src)
result.then(function(img){
    console.log(img.width)
    //part1 
    return img
}).then(function(img){
    //part2
    console.log(img.height)
})
.catch(function(ex){
    console.log(ex)
})
```

## 从设计到模式
- 设计和模式分开
- 从设计到模式

### 23种设计模式
- 创建型
    - 工厂模式(工厂方法模式、抽象工厂模式、建造者模式)
    - 单例模式
    - 原型模式
- 结构型
    - 适配器模式
    - 装饰器模式
    - 代理模式
    - 外观模式
    - 桥接模式
    - 组合模式
    - 享元模式
- 行为型
    - 策略模式
    - 模板方法模式
    - **观察者模式**
    - **迭代器模式**
    - 职责连模式
    - 命令模式
    - 备忘录模式
    - **状态模式**
    - 访问者模式
    - 中介者模式
    - 解释器模式

### 实例
```js
/**
 *  打车时，可以打专车或者快车。 任何车都有车牌号和名称
 *  不同车价格不同，快车每公里1元，专车每公里2元
 *  行程开始时，显示车辆信息
 *  行程结束时，显示打车金额（假定行程就5公里）
 *  画出UML类图
 *  用ES6语法写出该示例
*/

class Car{
    constructor(number,name){
        this.number=number
        this.name=name
    }
}

class KCar extends Car{
    constructor(number,name){
        super(number,name)
        this.price=1
    }
}

class ZCar extends Car{
    constructor(number,name){
        super(number,name)
        this.price=2
    }
}

class Trip{
    constructor(car){
        this.car=car
    }
    start(){
        console.log(this.car.name,this.car.number)
    }
    end(){
        console.log(this.car.price*5)
    }
}

let car=new KCar(100,'桑')
let trip=new Trip(car)
trip.start()
trip.end()
```
![前端设计模式_类图_2018918155045](http://b.zhangyapeng.club/前端设计模式_类图_2018918155045.png)

```js
/**
 *  某停车场，分3层，每层100车位
 *  每个车位都能监控到车辆的驶入和离开
 *  车辆进入前，显示每层的空余车位数量
 *  车辆进入摄像头可识别车牌号和时间
 *  车辆出来时，出口显示器显示车牌号和停车时长
 * 
 *  画出UML类图
 *  1. 多少个类
*/

class Car{
    constructor(num){
        this.num=num
    }
}
//摄像头
class Camera{
    shot(car){
        return {
            num:car.num,
            inTime:Date.now()
        }
    }
}

class Screen{
    show(car,inTime){
        console.log(Date.now()-inTime)
    }
}

class Park{
    constructor(floors){
        this.floors=floors || []
        this.camera=new Camera()
        this.screen=new Screen()
        this.carList={}//存储摄像头拍摄返回信息
    }
    in(car){
        //通过摄像头获取信息
        const info=this.camera.shot(car)
        //停到某个停车位
        const i=parseInt(Math.random()*100%100)
        const place=this.floors[0].places[i]
        place.in()
        info.place=place
        //记录信息
        this.carList[car.num]=info
    }
    out(car){
        //获取信息
        const info=this.carList[car.num]
        //将停车为清空
        const place=info.place
        place.out()
        // 显示时间
        this.screen.show(car,info.inTime)
        //清空记录
        delete this.carList[car.num]
    }
    emptyPlaceNum(){
       return this.floors.map((floor)=>{
           return `${floor.index}层还有${floor.emptyPlaceNum()}`
        }
           ).join("\n")
    }
}
//层
class Floor{
    constructor(index,places){
        this.index=index
        this.places=places || []
    }
    emptyPlaceNum(){
        let num=0;
        this.places.forEach(p=>{
            if(p.empty){
                num=num+1
            }
        })
        return num
    }
}

//车位
class Place{
    constructor(){
        this.empty=true;
    }
    in(){
        this.empty=false
    }
    out(){
        this.empty=true;
    }
}

//测试

// 初始化停车场
const floors=[]
for(var i=0;i<3;i++){
    const places=[]
    for(var j=0;j<100;j++ ){
        places[j]=new Place()
    }
    floors[i]=new Floor(i+1,places)
}

const park=new Park(floors)

// 初始化车辆
const car1=new Car(100)
const car2=new Car(200)
const car3=new Car(300)

console.log('第一辆车进入')
console.log(park.emptyPlaceNum())
park.in(car1)
console.log('第二俩进入')
console.log(park.emptyPlaceNum())
park.in(car2)
console.log('第一俩离开')
park.out(car1)
console.log('第二俩离开')
park.out(car2)
```
### 工厂模式

#### 介绍
- 将new操作单独封装
- 遇到new时，就要考虑是否该使用工厂模式

#### 示例
- 你去购买汉堡，直接点餐、取餐，不会自己亲手做
- 商店要**封装**做汉堡的工作，做好直接给买者

#### UML类图
![前端设计模式_工厂模式_2018919102219](http://b.zhangyapeng.club/前端设计模式_工厂模式_2018919102219.png)

```js
class Creator{
    create(name){
        return new Product(name)
    }
}

class Product{
    constructor(name){
        this.name=name
    }
    init(){
        console.log("int1")
    }
    fun1(){
        console.log("fun1")
    }
    fun2(){
        console.log("fun2")
    }
}

//测试
let c1=new Creator()
let p=c1.create('p1')
p.init()
p.fun1()
```
#### 场景
- jQuery-$("div")
    - $("div")和new $("div") 有何区别？
    - 书写麻烦，jQuery 的链式操作将成为噩梦
    - 一旦jQuery名字变化，将是灾难的
- React.createElement
```js
class Vnode(tag,attrs,children){
    //...省略内部代码
}
React.createElement=function(tag,attrs,children){
    // 可以做验证
    return new Vnode(tag,attrs,children)
}
```
- vue异步组件
```js
Vue.component("async-example",function(resolve,reject){
    setTimeout(function(){
        resolve({
            template:"<div>I am async!</div>"
        })
    },1000)
})
```
#### 设计原则
- 构造函数和创建者分离
- 符合开放封闭原则

### 单例模式

#### 介绍
- 系统中被唯一使用
- 一个类只有一个实例

#### 示例
- 登录框
- 购物车

```js
class SingleObject{
    login(){
        console.log("login)
    }
}
//实例上没有getInstance方法
SingleObject.getInstance=(function(){
let intance;
return function(){
    if(!intance){
        intance=new SingleObject()
    }
    return instance
}
})()

//测试
let obj1=SingleObject.getInstance()
obj1.login()
let obj2=SingleObject.getInstance()
obj2.login()
console.log('obj1===obj2',obj1===obj2)
```
#### 场景
- jQuery只有一个$
```js
//jQuery只有一个$
if(window.jQuery!=null){
    return window.jQuery
}else{
    //初始化
}
```
- 模拟登录框
```js
class LoginForm{
    constructor(){
        this.state='hide'
    }
    show(){
        if(this.state==='show'){
            console.log("已经显示")
            return
        }
        this.state='show'
        console.log('显示')
    }
    hide(){
        if(this.state==='hide'){
            console.log("已经显示")
            return
        }
        this.state='hide'
        console.log('隐藏')
    }
}
LoginForm.getInstance=(function(){
    let instance
    return function(){
        if(!intance){
            intance=new LoginForm()
        }
        return instance
    }
})()

//测试
let login1=LoginForm.getInstance()
login1.show()
let login2=LoginForm.getInstance()
login1.hide()
```
- 其他
    - 购物车(和登录框类似)
    - vuex和redux中的store

#### 设计原则验证
- 符合单一职责原则，只实例化唯一的对象
- 没发具体开放封闭原则，但是绝对不违反开放封闭原则

### 适配器模式

#### 介绍
- 旧接口格式和使用者不兼容
- 中间加一个适配转换接口

#### 示例
![前端设计模式_转换器_2018919143435](http://b.zhangyapeng.club/前端设计模式_转换器_2018919143435.png)
#### UML类图
![前端设计模式_设配器UML_201891914363](http://b.zhangyapeng.club/前端设计模式_设配器UML_201891914363.png)

#### 代码演示
```js
class Adaptee{
    specificRequest(){
        return '德国标准插头'
    }
}

class Target{
    constructor(){
        this.adaptee=new Adaptee()
    }
    requrest(){
        let info=this.adaptee.specificRequest()
        return `${info}-转换器-中国标准插头`
    }
}

//测试
let target=new Target()
let res=target.request()
```
#### 场景
- 封装旧接口
```js
//自己封装的ajax,使用方式如下
ajax({
    url:'/getDate',
    type:"post",
    data:{
        id:"123"
    }
})
.done(function(){})
//但是因为历史原因，代码中全是：
//$.ajax({...})

//做一层适配器
var $={
    ajax:function(options){
        return ajax(options)
    }
}
```
- vue computed
```js
var vm=new Vue({
    el:"#exaple",
    data:{
        message:"hello"
    },
    computed:{
        reversedMessage(){
            return this.message.split("").reverse().join("")
        }
    }
})
```

#### 设计原则验证
- 将旧接口和使用者进行分离
- 符合开放封闭原则

### 装饰器模式
#### 介绍
- 为对象添加新功能
- 不改变其原有的结构和功能

#### 示例
![前端设计模式_装饰器模式_201891915151](http://b.zhangyapeng.club/前端设计模式_装饰器模式_201891915151.png)
**手机壳**

#### UML类图
![前端设计模式_装饰器UML_20189191541](http://b.zhangyapeng.club/前端设计模式_装饰器UML_20189191541.png)

```js
class Cicle{
    draw(){
        console.log("画一个圆形")
    }
}

class Decorator(){
    constructor(cicle){
        this.cicle=cicle
    }
    draw(){
        this.cicle.draw()
        this.setRedBorder(this.cicle)
    }
    setRedBorder(cicle){
        console.log('设着红色边框')
    }
}

//测试
let cicle=new Cicle()
cicle.draw()
let dec=new Decorator()
dec.draw()
```

#### 场景
- es7装饰器
```js
//装饰类 
@testDec
class Demo{
    
}
function testDec(target){
    target.isDec=true
}
console.log(Demo.isDec)

//装饰类  加参数
@testDec(true)
class Demo{
}
function testDec (isDec){
    return function(target){
        target.isDec=isDec
    }
}
console.log(Demo.isDec)

//装饰类-mixin示例
function mixins(...list){
    return function(target){
        Object.assign(target.prototype,...list)
    }
}
const Foo={
    foo(){
        alert('foo')
    }
}

@mixins(Foo)
class MyClass{}

let obj=new MyClass();
obj.foo()//'foo'

//装饰方法
class Person{
    constructor(){
        this.first='A'
        this.last='B'
    }

    //装饰方法
    @readonly
    name(){return `${this.first} ${this.last}`}
}

var p= new Person()
console.log(p.name())
//p.name=function(){} //这里会报错，因为name是只读的

function readonly(target,name,descriptor){
    //默认是
    //{
    //     value :specifiedFunction,
    //     enumerable:false,
    //     configurable:true,
    //     writable:true
    // }
    descriptor.writable=false;
    return descriptor
}
```
- core-decorators
    - 第三方开源lib
    - 提供常用的装饰器

#### 设计原则验证
- 将现有对象和装饰器进行分离，两者独立存在
- 符合开放封闭原则

