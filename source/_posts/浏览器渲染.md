---
title: 浏览器渲染
copyright: true
date: 2018-09-05 15:43:59
tags: ['浏览器渲染','浏览器']
---
### Get Started
有这样几个问题，我们来思考一下：
1. 我们平常浏览的网页是否是应用
2. 在操作系统中的应用是如何运行的
3. 浏览器究竟是什么
4. webkit和浏览器的关系
5. 浏览器是如何呈现页面的
6. 经典问题：从浏览器的地址输入一个网址直到网页内容呈现完毕，发生了哪些事情

### 基本概念
#### 浏览器
浏览器是用户访问互联网最重要的接口

本质上,浏览器是方便一般互联网用户通过界面解析和发送HTTP协议的软件
#### 浏览器历史
1. 1991年，第一个浏览器WorldWideWeb(后改为Nexus),功能简单，不支持图片
2. 1993年，Mosaic浏览器出现，可以显示图片，为了区分浏览器是否显示图片，出现了**UserAgent**
3. 1994年，Mozilla浏览器出现,也就是后面大名鼎鼎的网景浏览器Netscape,它的UserAgent为**Mozilla/1.0**
4. 1995年，IE浏览器出现，为了抢夺市场，UserAgent为**Mozilla/1.22**
5. 1998年，网景浏览器失利，成立Mozilla组织
6. 2003年，网景公司解散，Mozilla基金会成立，这个组织推进了后来的Firefox
7. Mozilla开发了Geoko,变成了Firefox，他的UserAgent**Mozilla/5.0**
8. 群雄并起，众多公司的浏览器的UserAgent上都带有**Mozilla**
9. chrome和safari出现，占有了很大的份额

#### 问题：
- 最初的浏览器做了哪些事情
    1. 创建一个TCP连接
    2. 发送一个文本协议(请求头)
    3. 解析页面的操作(不解析图片)

- User-Agent的起初意义
    1. 告诉服务器,当前浏览器的版本，系统
    2. 起初为了区分浏览器是否支持图片

#### 查看用户代理
1. 打开chrome浏览器的控制台
2. 在控制台输入`navigator.userAgent`
3. 会发现类似的字符串`Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36`

#### 用户代理的作用
1. 判断浏览器类型，采用兼容方案
2. 判断是否为移动端
3. 标识H5容器，方便调用H5容器特定接口
4. 要注意`userAgent`伪装成本很低，不要过于依赖

### 内核
对于操作系统来说，**内核**是操作系统的核心，是第一层基于硬件的软件扩充，提供最核心最基础的服务

应用程序通过内核进行**系统调用**来使用计算机的硬件，内核代码简介高效,并且基本没有bug,由于是最底层的服务，一点微小的错误也会造成整个系统的崩溃。好处当然也显而易见，基于一个稳定的内核，开发者可以构建适合不同场景的操作系统和应用软件

对于浏览器来说，同样存在**浏览器内核**，与操作系统内核相似，浏览器内核需要提供API给浏览器开发者使用，同时提供最核心的功能，如`加载和渲染网页`，`调用操作系统所提供的服务`

对于浏览器厂商来说，高效使用和开发浏览器内核是核心问题。对于web开发者来说，理解浏览器内核的基本机制，才能开发出高性能的web应用

### 浏览器内核知识
#### 浏览器内核定义
我们可以初步认为浏览器中**负责将表示页面的字符串转变成可视化的图像的模块**就是**浏览器内核**
### 回到"从输入URL..."的问题
我们将输入URL到远程内容返回之前的阶段略过，从`Response`开始：
使用Node.js的TCP模块来获取，远程主机究竟给我们返回了什么：
```js
const net = require('net')
const fs = require('fs')
const path = require('path')
const desPort = 80
const desHost = '123.57.205.204'
let allBuffer = null
const client = net.createConnection(desPort, desHost, function () {
  console.log('connected to server!')
  client.write(`GET / HTTP/1.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.9\r\nCache-Control: no-cache\r\nConnection: keep-alive\r\nCookie: __cfduid=dcc794c22f91c478f5c0e21bd2a4dc4a71535945679; __root_domain_v=.zhufengpeixun.cn; _qddaz=QD.54jl6y.ec9qho.jllqeote; pgv_pvi=4490024960; tencentSig=320538624; IESESSION=alive; pgv_si=s8736718848; Hm_lvt_418b1c90fa35dc210dd5d2284d9f9f29=1535945692,1535963228,1536047064,1536110767; Hm_lvt_5ca1e1efc366a109d783a085499d59d9=1535964808,1536111794; Hm_lpvt_5ca1e1efc366a109d783a085499d59d9=1536111794; Hm_lpvt_418b1c90fa35dc210dd5d2284d9f9f29=1536140224; _qdda=3-1.1; _qddab=3-vgg4fx.jloy87b0; _qddamta_2852156370=3-0\r\nHost: www.zhufengpeixun.cn\r\nPragma: no-cache\r\n
  Upgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36\r\n\r\n`)
})
client.on('data', function (data) {
  if (!allBuffer) {
    allBuffer = data
  } else {
    allBuffer = Buffer.concat([allBuffer, data])
  }
})
client.on('error', function (err) {
  console.log(err)
})
client.on('end', function () {
  const htmlContent = allBuffer.toString()
  const ws = fs.createWriteStream(
    path.join(__dirname, 'zhufeng.html')
  )
  ws.write(htmlContent)
})

```
几个问题:
1. 以上这段代码的逻辑
2. 返回的字符串该如何解析
3. 想让返回的字符串呈现为图像，怎么做 

#### 远程主机响应
##### HTTP协议
请求报文格式：
- 起始行:[方法][空格][请求URL][空格][HTTP版本][换行符]
- 首部:[首部名称][;][可选空格][首部内容][换行符]
- 首部结束:[换行符]
- 实体

响应报文格式:

- 起始行：[HTTP版本][空格][状态码][空格][原因短语][换行符]
- 首部:[首部名称][;][可选空格][首部内容][换行符]
- 首部结束:[换行符]
- 实体

换行符:\r\n

### 响应组成
响应内容解析如下：
```
HTTP/1.0 302 Found
Location: https://www.baidu.com/error.html
Server: bfe
Date: Wed, 05 Sep 2018 10:10:32 GMT
Content-Length: 0
Content-Type: text/plain; charset=utf-8
# 实体内容 当前为html
<!DOCTYPE html>
<HTML>
....
</HTML>
```
### 网页内容的组成
- doctype:提供浏览器html版本信息，html解析器用那个版本解析
- head:html头部
    - meta:元数据信息
         - charset:此特性声明当前文档所使用的字符编码
         - http-equiv:客户端行为，如渲染模式，缓存等
         - name[keywords]:搜索引擎使用
         - name[description]:搜索引擎使用
         - name[viewport]:**浏览器视口设置**
    - link
    - script:需要在body前完成加载或运行的脚本
- body:html实体
    - script:需要在body解析时加载或运行的脚本

### 问题:X-UA-Compatible是什么
`X-UA-Compatible`是针对`IE8`新加的一个设置，对于`IE8之前`的浏览器是不识别的，这个区别与`content="IE=7"`在无论页面是否包含`<!DOCTYPE>`指令，都像是使用了 `Windows Internet Explorer 7`的标准模式。而`content="IE=EmulateIE7"`模式遵循<!DOCTYPE>指令。对于多数网站来说，它是首选的兼容性模式。

为了避免制作出的页面在IE8下面出现错误，建议直接将IE8使用IE7进行渲染。也就是直接在页面的header的meta标签中加入如下代码：
```html
<meta http-equiv="X-UA-Compatible" content="IE=7" />  
```
### 渲染需要做的工作
![浏览器渲染.jpg](浏览器渲染.jpg)

上图表示了渲染引擎的一般渲染过程，虚线表示该阶段所依赖的外部模块（不属于渲染引擎）

重要组件
- html解释器:解释HTML文本解释器，html文本->DOM树
- css解释器：遇到级联样式时,需要使用级联样式表解释器，为DOM对象计算出样式信息
- Javascript引擎:遇到js代码时,需要使用Javascript解释器，并使得js代码有调用DOM接口和CSSOM接口的能力
- 布局:结合CSS,**计算**出每个DOM对象的**大小位置**信息
- 绘图:将经过布局计算的DOM节点**绘制成图像**

以上重要组件组成了渲染引擎：
![渲染引擎.jpg](渲染引擎.jpg)

#### 思考

几个问题：
1. 通过响应的内容，我们可以看到内容中还存在许多外联资源，浏览器是如何处理的？
2. 著名的优化:"css放在头部，js放在尾部",为什么？
3. 浏览器在渲染之前或者之后还需要做那些事情
4. 移动端的浏览器和pc端的浏览器是否相同

#### 浏览器内核架构

#### 回答上一节
1. 不同的外联资源，webkit中有不同的资源加载器。当浏览器解析到URL地址时，调用特定的资源加载器，如果不是特殊资源，加载过程不会阻碍渲染过程
2. 一般来说css资源不会阻碍渲染过程，但Javascript资源在的浏览器中，会阻碍渲染过程的进行。如果放置在头部，渲染过程会**暂停**,造成"白屏".但现代浏览器的优化已经做的很好了，**preload**，所以当渲染被阻塞时，浏览器会开启新的线程继续渲染。
3. 渲染之前需要加载资源，渲染之后在DOM或者css变化后，重新进行布局计算和重渲染操作
4. 功能基本相同，但所运用的操作系统不同，渲染机制有差异

#### 内核架构

根据上面的问题回答我们会发现，webkit仅仅包含渲染功能是不够的，因为它需要获取网络资源，支持不同的浏览器，支持不用的操作系统，同样还要包含调试工具。

所以我们应该给出一张更全的webkit架构图:
![webkit架构图.jpg](webkit架构图.jpg)
虚线框表示该部分模块在不同浏览器使用webkit的实现是不一样的，实线框是基本一致的。

#### Chromium架构
基于webkit内核就可以构建浏览器应用，了解著名的chromium浏览器对我们的web开发也有很多启发

几个问题
1. 除去webkit内核完成的功能，浏览器的工作有哪些？
2. 进程是什么？
3. IPC是什么？
4. 线程是什么？
5. 线程同步是什么？

#### 现代浏览器的工作？
- 资源管理
- 多页面管理：也就是多个标签页的管理
- 插件和扩展：如flash,油猴，chrome扩展程序
- 账户和同步
- 安全机制
- 多系统支持

#### 进程和线程
- 进程：对CPU,主存，IO设备的抽象，操作系统对一个正在进行的程序的抽象
- 线程：组成进程的执行单元
- 进程通信：进程间传输数据（交换信息）
- 线程同步

#### 进程通讯的方式

#### 线程同步的方式
![进程.jpg](进程.jpg)
#### Chromium的多进程架构
chromium的模块：
![chromium.jpg](chromium.jpg)
主要进程介绍：
- Browser进程：主进程,负责浏览器页面，页面管理等
- render进程：渲染进程
- NPAPI插件进程
- GPU进程：当GPU硬件加速打开时才会创建

多进程架构的目的所在：
- 职责分离，故障范围小
- 隔离性
- 性能

#### javascript中的进程和线程
- 单线程

### 浏览器渲染原理

总共分两步：
1. 加载：加载渲染所必须的html代码
2. 渲染：将html代码绘制成图像结果

#### 加载

##### 资源加载机制

###### 资源加载器

分为三类：
1. 特定资源加载器：针对每种资源类型的特定加载器，仅加载某一种资源。对应设计模式中 的单例模式
2. 缓存资源加载器：与常规的缓存逻辑相同，特定加载器先通过缓存资源加载器来查找是否有缓存资源，如果在资源缓存池中存在缓存资源，则取出以便使用；若不存在，发送请求给网络模块
3. 通用资源加载器：由于加载资源大多属于网络请求，而网络请求的逻辑是可以被特定资源加载器所共享的，所以通用资源加载器只能负责通过网路获得目标资源的数据，但不负责进一步解析

##### 资源缓存
1. page Cache：页面缓存
2. Memory Cache：内存缓存
3. Disk Cache:磁盘缓存

##### 流程

#### 网络栈
![网络栈.jpg](网络栈.jpg)
1. 确定请求类型，协议
2. 判断是否需要建立网络连接
3. 建立HTTP事务
4. 建立TCP socket连接
5. 套接字连接

#### 预先加载
1. DNS预取 **dns-prefetch**
2. 资源的预取
3. TCP preconnect

#### TCP 相关
请参考之前的网络课程

#### 如何提高加载速度
3. 合并请求：nginx模块，sprite雪碧图 **移动端TCP请求建立慢**
4. 缓存:from cache(memory,disk),localstorage，本地缓存策略，HTTP头(结合业务)
5. tcp 网络连接优化：tcp调优，HTTP/2,keep-alive
6. 硬件：加大带宽，使用cdn(对象存储)
7. 资源大小：gzip,webp，image压缩，cookie体积
8. 预加载： dns预取 、多个cdn域名**Chrome在同域名下读资源只能读5个** 、异步读取js

#### 渲染 
###### HTML 解释器
###### 解释过程
资源的变换
1. 字节流
2. 字符流
3. Tokens
4. 节点
5. DOM数

流程：
1. 词法分析
2. XSSAuditor
3. 语法分析
4. 生成DOM数

##### 词法分析
通过HTMLTokenizer来进行词法分析

词法分析的任务是对输入字节流进行逐字扫描，根据构词规则识别单词和符号，分词

词法分析器的主要接口是nextToken()函数，调用者只需要将字符串传入，就会得到一个词语

注意，在这里并不涉及标签类型信息，这是之后语法分析的工作

##### CSS解释器

###### Javascript引擎
执行流程：
1. 源代码
2. 抽象语法数
3. 字节码
4. 解释器
5. JIT
6. 本地代码

###### 渲染
1. renderObject
2. RenderLayer
3. 布局计算
4. 绘图无关上下文